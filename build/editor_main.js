var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
  mod
));

// node_modules/.pnpm/ace-builds@1.41.0/node_modules/ace-builds/src-noconflict/ace.js
var require_ace = __commonJS({
  "node_modules/.pnpm/ace-builds@1.41.0/node_modules/ace-builds/src-noconflict/ace.js"(exports, module) {
    (function() {
      var ACE_NAMESPACE = "ace";
      var global2 = /* @__PURE__ */ function() {
        return this;
      }();
      if (!global2 && typeof window != "undefined") global2 = window;
      if (!ACE_NAMESPACE && typeof requirejs !== "undefined")
        return;
      var define2 = function(module2, deps, payload) {
        if (typeof module2 !== "string") {
          if (define2.original)
            define2.original.apply(this, arguments);
          else {
            console.error("dropping module because define wasn't a string.");
            console.trace();
          }
          return;
        }
        if (arguments.length == 2)
          payload = deps;
        if (!define2.modules[module2]) {
          define2.payloads[module2] = payload;
          define2.modules[module2] = null;
        }
      };
      define2.modules = {};
      define2.payloads = {};
      var _require = function(parentId, module2, callback) {
        if (typeof module2 === "string") {
          var payload = lookup(parentId, module2);
          if (payload != void 0) {
            callback && callback();
            return payload;
          }
        } else if (Object.prototype.toString.call(module2) === "[object Array]") {
          var params = [];
          for (var i = 0, l = module2.length; i < l; ++i) {
            var dep = lookup(parentId, module2[i]);
            if (dep == void 0 && require2.original)
              return;
            params.push(dep);
          }
          return callback && callback.apply(null, params) || true;
        }
      };
      var require2 = function(module2, callback) {
        var packagedModule = _require("", module2, callback);
        if (packagedModule == void 0 && require2.original)
          return require2.original.apply(this, arguments);
        return packagedModule;
      };
      var normalizeModule = function(parentId, moduleName) {
        if (moduleName.indexOf("!") !== -1) {
          var chunks = moduleName.split("!");
          return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        if (moduleName.charAt(0) == ".") {
          var base = parentId.split("/").slice(0, -1).join("/");
          moduleName = base + "/" + moduleName;
          while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
          }
        }
        return moduleName;
      };
      var lookup = function(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);
        var module2 = define2.modules[moduleName];
        if (!module2) {
          module2 = define2.payloads[moduleName];
          if (typeof module2 === "function") {
            var exports2 = {};
            var mod = {
              id: moduleName,
              uri: "",
              exports: exports2,
              packaged: true
            };
            var req = function(module3, callback) {
              return _require(moduleName, module3, callback);
            };
            var returnValue = module2(req, exports2, mod);
            exports2 = returnValue || mod.exports;
            define2.modules[moduleName] = exports2;
            delete define2.payloads[moduleName];
          }
          module2 = define2.modules[moduleName] = exports2 || module2;
        }
        return module2;
      };
      function exportAce(ns) {
        var root2 = global2;
        if (ns) {
          if (!global2[ns])
            global2[ns] = {};
          root2 = global2[ns];
        }
        if (!root2.define || !root2.define.packaged) {
          define2.original = root2.define;
          root2.define = define2;
          root2.define.packaged = true;
        }
        if (!root2.require || !root2.require.packaged) {
          require2.original = root2.require;
          root2.require = require2;
          root2.require.packaged = true;
        }
      }
      exportAce(ACE_NAMESPACE);
    })();
    ace.define("ace/lib/es6-shim", ["require", "exports", "module"], function(require2, exports2, module2) {
      function defineProp(obj, name, val) {
        Object.defineProperty(obj, name, {
          value: val,
          enumerable: false,
          writable: true,
          configurable: true
        });
      }
      if (!String.prototype.startsWith) {
        defineProp(String.prototype, "startsWith", function(searchString, position2) {
          position2 = position2 || 0;
          return this.lastIndexOf(searchString, position2) === position2;
        });
      }
      if (!String.prototype.endsWith) {
        defineProp(String.prototype, "endsWith", function(searchString, position2) {
          var subjectString = this;
          if (position2 === void 0 || position2 > subjectString.length) {
            position2 = subjectString.length;
          }
          position2 -= searchString.length;
          var lastIndex = subjectString.indexOf(searchString, position2);
          return lastIndex !== -1 && lastIndex === position2;
        });
      }
      if (!String.prototype.repeat) {
        defineProp(String.prototype, "repeat", function(count) {
          var result = "";
          var string = this;
          while (count > 0) {
            if (count & 1)
              result += string;
            if (count >>= 1)
              string += string;
          }
          return result;
        });
      }
      if (!String.prototype.includes) {
        defineProp(String.prototype, "includes", function(str, position2) {
          return this.indexOf(str, position2) != -1;
        });
      }
      if (!Object.assign) {
        Object.assign = function(target2) {
          if (target2 === void 0 || target2 === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target2);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== void 0 && source !== null) {
              Object.keys(source).forEach(function(key) {
                output[key] = source[key];
              });
            }
          }
          return output;
        };
      }
      if (!Object.values) {
        Object.values = function(o) {
          return Object.keys(o).map(function(k) {
            return o[k];
          });
        };
      }
      if (!Array.prototype.find) {
        defineProp(Array.prototype, "find", function(predicate) {
          var len = this.length;
          var thisArg = arguments[1];
          for (var k = 0; k < len; k++) {
            var kValue = this[k];
            if (predicate.call(thisArg, kValue, k, this)) {
              return kValue;
            }
          }
        });
      }
      if (!Array.prototype.findIndex) {
        defineProp(Array.prototype, "findIndex", function(predicate) {
          var len = this.length;
          var thisArg = arguments[1];
          for (var k = 0; k < len; k++) {
            var kValue = this[k];
            if (predicate.call(thisArg, kValue, k, this)) {
              return k;
            }
          }
        });
      }
      if (!Array.prototype.includes) {
        defineProp(Array.prototype, "includes", function(item, position2) {
          return this.indexOf(item, position2) != -1;
        });
      }
      if (!Array.prototype.fill) {
        defineProp(Array.prototype, "fill", function(value) {
          var O = this;
          var len = O.length >>> 0;
          var start = arguments[1];
          var relativeStart = start >> 0;
          var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
          var end = arguments[2];
          var relativeEnd = end === void 0 ? len : end >> 0;
          var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
          while (k < final) {
            O[k] = value;
            k++;
          }
          return O;
        });
      }
      if (!Array.of) {
        defineProp(Array, "of", function() {
          return Array.prototype.slice.call(arguments);
        });
      }
    });
    ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/es6-shim"], function(require2, exports2, module2) {
      "use strict";
      require2("./es6-shim");
    });
    ace.define("ace/lib/deep_copy", ["require", "exports", "module"], function(require2, exports2, module2) {
      exports2.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj)
          return obj;
        var copy;
        if (Array.isArray(obj)) {
          copy = [];
          for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
          }
          return copy;
        }
        if (Object.prototype.toString.call(obj) !== "[object Object]")
          return obj;
        copy = {};
        for (var key in obj)
          copy[key] = deepCopy(obj[key]);
        return copy;
      };
    });
    ace.define("ace/lib/lang", ["require", "exports", "module", "ace/lib/deep_copy"], function(require2, exports2, module2) {
      "use strict";
      exports2.last = function(a) {
        return a[a.length - 1];
      };
      exports2.stringReverse = function(string) {
        return string.split("").reverse().join("");
      };
      exports2.stringRepeat = function(string, count) {
        var result = "";
        while (count > 0) {
          if (count & 1)
            result += string;
          if (count >>= 1)
            string += string;
        }
        return result;
      };
      var trimBeginRegexp = /^\s\s*/;
      var trimEndRegexp = /\s\s*$/;
      exports2.stringTrimLeft = function(string) {
        return string.replace(trimBeginRegexp, "");
      };
      exports2.stringTrimRight = function(string) {
        return string.replace(trimEndRegexp, "");
      };
      exports2.copyObject = function(obj) {
        var copy = {};
        for (var key in obj) {
          copy[key] = obj[key];
        }
        return copy;
      };
      exports2.copyArray = function(array) {
        var copy = [];
        for (var i = 0, l = array.length; i < l; i++) {
          if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
          else
            copy[i] = array[i];
        }
        return copy;
      };
      exports2.deepCopy = require2("./deep_copy").deepCopy;
      exports2.arrayToMap = function(arr) {
        var map = {};
        for (var i = 0; i < arr.length; i++) {
          map[arr[i]] = 1;
        }
        return map;
      };
      exports2.createMap = function(props2) {
        var map = /* @__PURE__ */ Object.create(null);
        for (var i in props2) {
          map[i] = props2[i];
        }
        return map;
      };
      exports2.arrayRemove = function(array, value) {
        for (var i = 0; i <= array.length; i++) {
          if (value === array[i]) {
            array.splice(i, 1);
          }
        }
      };
      exports2.escapeRegExp = function(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
      };
      exports2.escapeHTML = function(str) {
        return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
      };
      exports2.getMatchOffsets = function(string, regExp) {
        var matches = [];
        string.replace(regExp, function(str) {
          matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
          });
        });
        return matches;
      };
      exports2.deferredCall = function(fcn) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var deferred = function(timeout) {
          deferred.cancel();
          timer = setTimeout(callback, timeout || 0);
          return deferred;
        };
        deferred.schedule = deferred;
        deferred.call = function() {
          this.cancel();
          fcn();
          return deferred;
        };
        deferred.cancel = function() {
          clearTimeout(timer);
          timer = null;
          return deferred;
        };
        deferred.isPending = function() {
          return timer;
        };
        return deferred;
      };
      exports2.delayedCall = function(fcn, defaultTimeout) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var _self = function(timeout) {
          if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.delay = function(timeout) {
          timer && clearTimeout(timer);
          timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;
        _self.call = function() {
          this.cancel();
          fcn();
        };
        _self.cancel = function() {
          timer && clearTimeout(timer);
          timer = null;
        };
        _self.isPending = function() {
          return timer;
        };
        return _self;
      };
      exports2.supportsLookbehind = function() {
        try {
          new RegExp("(?<=.)");
        } catch (e75) {
          return false;
        }
        return true;
      };
      exports2.skipEmptyMatch = function(line, last, supportsUnicodeFlag) {
        return supportsUnicodeFlag && line.codePointAt(last) > 65535 ? 2 : 1;
      };
    });
    ace.define("ace/lib/useragent", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      exports2.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
      };
      exports2.getOS = function() {
        if (exports2.isMac) {
          return exports2.OS.MAC;
        } else if (exports2.isLinux) {
          return exports2.OS.LINUX;
        } else {
          return exports2.OS.WINDOWS;
        }
      };
      var _navigator = typeof navigator == "object" ? navigator : {};
      var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
      var ua = _navigator.userAgent || "";
      var appName = _navigator.appName || "";
      exports2.isWin = os == "win";
      exports2.isMac = os == "mac";
      exports2.isLinux = os == "linux";
      exports2.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
      exports2.isOldIE = exports2.isIE && exports2.isIE < 9;
      exports2.isGecko = exports2.isMozilla = ua.match(/ Gecko\/\d+/);
      exports2.isOpera = typeof opera == "object" && Object.prototype.toString.call(window["opera"]) == "[object Opera]";
      exports2.isWebKit = parseFloat(ua.split("WebKit/")[1]) || void 0;
      exports2.isChrome = parseFloat(ua.split(" Chrome/")[1]) || void 0;
      exports2.isSafari = parseFloat(ua.split(" Safari/")[1]) && !exports2.isChrome || void 0;
      exports2.isEdge = parseFloat(ua.split(" Edge/")[1]) || void 0;
      exports2.isAIR = ua.indexOf("AdobeAIR") >= 0;
      exports2.isAndroid = ua.indexOf("Android") >= 0;
      exports2.isChromeOS = ua.indexOf(" CrOS ") >= 0;
      exports2.isIOS = /iPad|iPhone|iPod/.test(ua) && !window["MSStream"];
      if (exports2.isIOS)
        exports2.isMac = true;
      exports2.isMobile = exports2.isIOS || exports2.isAndroid;
    });
    ace.define("ace/lib/dom", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var useragent = require2("./useragent");
      var XHTML_NS = "http://www.w3.org/1999/xhtml";
      exports2.buildDom = function buildDom(arr, parent, refs) {
        if (typeof arr == "string" && arr) {
          var txt = document.createTextNode(arr);
          if (parent)
            parent.appendChild(txt);
          return txt;
        }
        if (!Array.isArray(arr)) {
          if (arr && arr.appendChild && parent)
            parent.appendChild(arr);
          return arr;
        }
        if (typeof arr[0] != "string" || !arr[0]) {
          var els = [];
          for (var i = 0; i < arr.length; i++) {
            var ch = buildDom(arr[i], parent, refs);
            ch && els.push(ch);
          }
          return els;
        }
        var el = document.createElement(arr[0]);
        var options = arr[1];
        var childIndex = 1;
        if (options && typeof options == "object" && !Array.isArray(options))
          childIndex = 2;
        for (var i = childIndex; i < arr.length; i++)
          buildDom(arr[i], el, refs);
        if (childIndex == 2) {
          Object.keys(options).forEach(function(n) {
            var val = options[n];
            if (n === "class") {
              el.className = Array.isArray(val) ? val.join(" ") : val;
            } else if (typeof val == "function" || n == "value" || n[0] == "$") {
              el[n] = val;
            } else if (n === "ref") {
              if (refs)
                refs[val] = el;
            } else if (n === "style") {
              if (typeof val == "string")
                el.style.cssText = val;
            } else if (val != null) {
              el.setAttribute(n, val);
            }
          });
        }
        if (parent)
          parent.appendChild(el);
        return el;
      };
      exports2.getDocumentHead = function(doc2) {
        if (!doc2)
          doc2 = document;
        return doc2.head || doc2.getElementsByTagName("head")[0] || doc2.documentElement;
      };
      exports2.createElement = function(tag, ns) {
        return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
      };
      exports2.removeChildren = function(element) {
        element.innerHTML = "";
      };
      exports2.createTextNode = function(textContent, element) {
        var doc2 = element ? element.ownerDocument : document;
        return doc2.createTextNode(textContent);
      };
      exports2.createFragment = function(element) {
        var doc2 = element ? element.ownerDocument : document;
        return doc2.createDocumentFragment();
      };
      exports2.hasCssClass = function(el, name) {
        var classes = (el.className + "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
      };
      exports2.addCssClass = function(el, name) {
        if (!exports2.hasCssClass(el, name)) {
          el.className += " " + name;
        }
      };
      exports2.removeCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g);
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          classes.splice(index, 1);
        }
        el.className = classes.join(" ");
      };
      exports2.toggleCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g), add = true;
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          add = false;
          classes.splice(index, 1);
        }
        if (add)
          classes.push(name);
        el.className = classes.join(" ");
        return add;
      };
      exports2.setCssClass = function(node, className, include) {
        if (include) {
          exports2.addCssClass(node, className);
        } else {
          exports2.removeCssClass(node, className);
        }
      };
      exports2.hasCssString = function(id, doc2) {
        var index = 0, sheets;
        doc2 = doc2 || document;
        if (sheets = doc2.querySelectorAll("style")) {
          while (index < sheets.length) {
            if (sheets[index++].id === id) {
              return true;
            }
          }
        }
      };
      exports2.removeElementById = function(id, doc2) {
        doc2 = doc2 || document;
        if (doc2.getElementById(id)) {
          doc2.getElementById(id).remove();
        }
      };
      var strictCSP;
      var cssCache = [];
      exports2.useStrictCSP = function(value) {
        strictCSP = value;
        if (value == false)
          insertPendingStyles();
        else if (!cssCache)
          cssCache = [];
      };
      function insertPendingStyles() {
        var cache = cssCache;
        cssCache = null;
        cache && cache.forEach(function(item) {
          importCssString(item[0], item[1]);
        });
      }
      function importCssString(cssText, id, target2) {
        if (typeof document == "undefined")
          return;
        if (cssCache) {
          if (target2) {
            insertPendingStyles();
          } else if (target2 === false) {
            return cssCache.push([cssText, id]);
          }
        }
        if (strictCSP)
          return;
        var container = target2;
        if (!target2 || !target2.getRootNode) {
          container = document;
        } else {
          container = target2.getRootNode();
          if (!container || container == target2)
            container = document;
        }
        var doc2 = container.ownerDocument || container;
        if (id && exports2.hasCssString(id, container))
          return null;
        if (id)
          cssText += "\n/*# sourceURL=ace/css/" + id + " */";
        var style = exports2.createElement("style");
        style.appendChild(doc2.createTextNode(cssText));
        if (id)
          style.id = id;
        if (container == doc2)
          container = exports2.getDocumentHead(doc2);
        container.insertBefore(style, container.firstChild);
      }
      exports2.importCssString = importCssString;
      exports2.importCssStylsheet = function(uri, doc2) {
        exports2.buildDom(["link", { rel: "stylesheet", href: uri }], exports2.getDocumentHead(doc2));
      };
      exports2.scrollbarWidth = function(doc2) {
        var inner = exports2.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";
        var outer = exports2.createElement("ace_outer");
        var style = outer.style;
        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";
        outer.appendChild(inner);
        var body = doc2 && doc2.documentElement || document && document.documentElement;
        if (!body)
          return 0;
        body.appendChild(outer);
        var noScrollbar = inner.offsetWidth;
        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;
        if (noScrollbar === withScrollbar) {
          withScrollbar = outer.clientWidth;
        }
        body.removeChild(outer);
        return noScrollbar - withScrollbar;
      };
      exports2.computedStyle = function(element, style) {
        return window.getComputedStyle(element, "") || {};
      };
      exports2.setStyle = function(styles, property, value) {
        if (styles[property] !== value) {
          styles[property] = value;
        }
      };
      exports2.HAS_CSS_ANIMATION = false;
      exports2.HAS_CSS_TRANSFORMS = false;
      exports2.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
      if (useragent.isChromeOS)
        exports2.HI_DPI = false;
      if (typeof document !== "undefined") {
        var div = document.createElement("div");
        if (exports2.HI_DPI && div.style.transform !== void 0)
          exports2.HAS_CSS_TRANSFORMS = true;
        if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
          exports2.HAS_CSS_ANIMATION = true;
        div = null;
      }
      if (exports2.HAS_CSS_TRANSFORMS) {
        exports2.translate = function(element, tx, ty) {
          element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
        };
      } else {
        exports2.translate = function(element, tx, ty) {
          element.style.top = Math.round(ty) + "px";
          element.style.left = Math.round(tx) + "px";
        };
      }
    });
    ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("./dom");
      exports2.get = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            callback(xhr.responseText);
          }
        };
        xhr.send(null);
      };
      exports2.loadScript = function(path2, callback) {
        var head = dom.getDocumentHead();
        var s = document.createElement("script");
        s.src = path2;
        head.appendChild(s);
        s.onload = s.onreadystatechange = function(_, isAbort) {
          if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
              callback();
          }
        };
      };
      exports2.qualifyURL = function(url) {
        var a = document.createElement("a");
        a.href = url;
        return a.href;
      };
    });
    ace.define("ace/lib/oop", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      exports2.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
      exports2.mixin = function(obj, mixin) {
        for (var key in mixin) {
          obj[key] = mixin[key];
        }
        return obj;
      };
      exports2.implement = function(proto, mixin) {
        exports2.mixin(proto, mixin);
      };
    });
    ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var EventEmitter = {};
      var stopPropagation = function() {
        this.propagationStopped = true;
      };
      var preventDefault = function() {
        this.defaultPrevented = true;
      };
      EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e75) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
          return;
        if (typeof e75 != "object" || !e75)
          e75 = {};
        if (!e75.type)
          e75.type = eventName;
        if (!e75.stopPropagation)
          e75.stopPropagation = stopPropagation;
        if (!e75.preventDefault)
          e75.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) {
          listeners[i](e75, this);
          if (e75.propagationStopped)
            break;
        }
        if (defaultHandler && !e75.defaultPrevented)
          return defaultHandler(e75, this);
      };
      EventEmitter._signal = function(eventName, e75) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners)
          return;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++)
          listeners[i](e75, this);
      };
      EventEmitter.once = function(eventName, callback) {
        var _self = this;
        this.on(eventName, function newCallback() {
          _self.off(eventName, newCallback);
          callback.apply(null, arguments);
        });
        if (!callback) {
          return new Promise(function(resolve) {
            callback = resolve;
          });
        }
      };
      EventEmitter.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          handlers = this._defaultHandlers = { _disabled_: {} };
        if (handlers[eventName]) {
          var old = handlers[eventName];
          var disabled = handlers._disabled_[eventName];
          if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
          disabled.push(old);
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
      };
      EventEmitter.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          return;
        var disabled = handlers._disabled_[eventName];
        if (handlers[eventName] == callback) {
          if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
      };
      EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
          listeners[capturing ? "unshift" : "push"](callback);
        return callback;
      };
      EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          return;
        var index = listeners.indexOf(callback);
        if (index !== -1)
          listeners.splice(index, 1);
      };
      EventEmitter.removeAllListeners = function(eventName) {
        if (!eventName)
          this._eventRegistry = this._defaultHandlers = void 0;
        if (this._eventRegistry)
          this._eventRegistry[eventName] = void 0;
        if (this._defaultHandlers)
          this._defaultHandlers[eventName] = void 0;
      };
      exports2.EventEmitter = EventEmitter;
    });
    ace.define("ace/lib/report_error", ["require", "exports", "module"], function(require2, exports2, module2) {
      exports2.reportError = function reportError(msg, data) {
        var e75 = new Error(msg);
        e75["data"] = data;
        if (typeof console == "object" && console.error)
          console.error(e75);
        setTimeout(function() {
          throw e75;
        });
      };
    });
    ace.define("ace/lib/default_english_messages", ["require", "exports", "module"], function(require2, exports2, module2) {
      var defaultEnglishMessages = {
        "autocomplete.popup.aria-roledescription": "Autocomplete suggestions",
        "autocomplete.popup.aria-label": "Autocomplete suggestions",
        "autocomplete.popup.item.aria-roledescription": "item",
        "autocomplete.loading": "Loading...",
        "editor.scroller.aria-roledescription": "editor",
        "editor.scroller.aria-label": "Editor content, press Enter to start editing, press Escape to exit",
        "editor.gutter.aria-roledescription": "editor gutter",
        "editor.gutter.aria-label": "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit",
        "error-marker.good-state": "Looks good!",
        "prompt.recently-used": "Recently used",
        "prompt.other-commands": "Other commands",
        "prompt.no-matching-commands": "No matching commands",
        "search-box.find.placeholder": "Search for",
        "search-box.find-all.text": "All",
        "search-box.replace.placeholder": "Replace with",
        "search-box.replace-next.text": "Replace",
        "search-box.replace-all.text": "All",
        "search-box.toggle-replace.title": "Toggle Replace mode",
        "search-box.toggle-regexp.title": "RegExp Search",
        "search-box.toggle-case.title": "CaseSensitive Search",
        "search-box.toggle-whole-word.title": "Whole Word Search",
        "search-box.toggle-in-selection.title": "Search In Selection",
        "search-box.search-counter": "$0 of $1",
        "text-input.aria-roledescription": "editor",
        "text-input.aria-label": "Cursor at row $0",
        "gutter.code-folding.range.aria-label": "Toggle code folding, rows $0 through $1",
        "gutter.code-folding.closed.aria-label": "Toggle code folding, rows $0 through $1",
        "gutter.code-folding.open.aria-label": "Toggle code folding, row $0",
        "gutter.code-folding.closed.title": "Unfold code",
        "gutter.code-folding.open.title": "Fold code",
        "gutter.annotation.aria-label.error": "Error, read annotations row $0",
        "gutter.annotation.aria-label.warning": "Warning, read annotations row $0",
        "gutter.annotation.aria-label.info": "Info, read annotations row $0",
        "inline-fold.closed.title": "Unfold code",
        "gutter-tooltip.aria-label.error.singular": "error",
        "gutter-tooltip.aria-label.error.plural": "errors",
        "gutter-tooltip.aria-label.warning.singular": "warning",
        "gutter-tooltip.aria-label.warning.plural": "warnings",
        "gutter-tooltip.aria-label.info.singular": "information message",
        "gutter-tooltip.aria-label.info.plural": "information messages",
        "gutter.annotation.aria-label.security": "Security finding, read annotations row $0",
        "gutter.annotation.aria-label.hint": "Suggestion, read annotations row $0",
        "gutter-tooltip.aria-label.security.singular": "security finding",
        "gutter-tooltip.aria-label.security.plural": "security findings",
        "gutter-tooltip.aria-label.hint.singular": "suggestion",
        "gutter-tooltip.aria-label.hint.plural": "suggestions",
        "editor.tooltip.disable-editing": "Editing is disabled"
      };
      exports2.defaultEnglishMessages = defaultEnglishMessages;
    });
    ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/report_error", "ace/lib/default_english_messages"], function(require2, exports2, module2) {
      "no use strict";
      var oop = require2("./oop");
      var EventEmitter = require2("./event_emitter").EventEmitter;
      var reportError = require2("./report_error").reportError;
      var defaultEnglishMessages = require2("./default_english_messages").defaultEnglishMessages;
      var optionsProvider = {
        setOptions: function(optList) {
          Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
          }, this);
        },
        getOptions: function(optionNames) {
          var result = {};
          if (!optionNames) {
            var options = this.$options;
            optionNames = Object.keys(options).filter(function(key) {
              return !options[key].hidden;
            });
          } else if (!Array.isArray(optionNames)) {
            optionNames = Object.keys(optionNames);
          }
          optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
          }, this);
          return result;
        },
        setOption: function(name, value) {
          if (this["$" + name] === value)
            return;
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
          if (!opt.handlesSet)
            this["$" + name] = value;
          if (opt && opt.set)
            opt.set.call(this, value);
        },
        getOption: function(name) {
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
          return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
      };
      function warn(message) {
        if (typeof console != "undefined" && console.warn)
          console.warn.apply(console, arguments);
      }
      var messages;
      var nlsPlaceholders;
      var AppConfig = (
        /** @class */
        function() {
          function AppConfig2() {
            this.$defaultOptions = {};
            messages = defaultEnglishMessages;
            nlsPlaceholders = "dollarSigns";
          }
          AppConfig2.prototype.defineOptions = function(obj, path2, options) {
            if (!obj.$options)
              this.$defaultOptions[path2] = obj.$options = {};
            Object.keys(options).forEach(function(key) {
              var opt = options[key];
              if (typeof opt == "string")
                opt = { forwardTo: opt };
              opt.name || (opt.name = key);
              obj.$options[opt.name] = opt;
              if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
            });
            oop.implement(obj, optionsProvider);
            return this;
          };
          AppConfig2.prototype.resetOptions = function(obj) {
            Object.keys(obj.$options).forEach(function(key) {
              var opt = obj.$options[key];
              if ("value" in opt)
                obj.setOption(key, opt.value);
            });
          };
          AppConfig2.prototype.setDefaultValue = function(path2, name, value) {
            if (!path2) {
              for (path2 in this.$defaultOptions)
                if (this.$defaultOptions[path2][name])
                  break;
              if (!this.$defaultOptions[path2][name])
                return false;
            }
            var opts = this.$defaultOptions[path2] || (this.$defaultOptions[path2] = {});
            if (opts[name]) {
              if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
              else
                opts[name].value = value;
            }
          };
          AppConfig2.prototype.setDefaultValues = function(path2, optionHash) {
            Object.keys(optionHash).forEach(function(key) {
              this.setDefaultValue(path2, key, optionHash[key]);
            }, this);
          };
          AppConfig2.prototype.setMessages = function(value, options) {
            messages = value;
            if (options && options.placeholders) {
              nlsPlaceholders = options.placeholders;
            }
          };
          AppConfig2.prototype.nls = function(key, defaultString, params) {
            if (!messages[key]) {
              warn("No message found for the key '" + key + "' in messages with id " + messages.$id + ", trying to find a translation for the default string '" + defaultString + "'.");
              if (!messages[defaultString]) {
                warn("No message found for the default string '" + defaultString + "' in the provided messages. Falling back to the default English message.");
              }
            }
            var translated = messages[key] || messages[defaultString] || defaultString;
            if (params) {
              if (nlsPlaceholders === "dollarSigns") {
                translated = translated.replace(/\$(\$|[\d]+)/g, function(_, dollarMatch) {
                  if (dollarMatch == "$")
                    return "$";
                  return params[dollarMatch];
                });
              }
              if (nlsPlaceholders === "curlyBrackets") {
                translated = translated.replace(/\{([^\}]+)\}/g, function(_, curlyBracketMatch) {
                  return params[curlyBracketMatch];
                });
              }
            }
            return translated;
          };
          return AppConfig2;
        }()
      );
      AppConfig.prototype.warn = warn;
      AppConfig.prototype.reportError = reportError;
      oop.implement(AppConfig.prototype, EventEmitter);
      exports2.AppConfig = AppConfig;
    });
    ace.define("ace/theme/textmate-css", ["require", "exports", "module"], function(require2, exports2, module2) {
      module2.exports = '.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
    });
    ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/theme/textmate-css", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      exports2.isDark = false;
      exports2.cssClass = "ace-tm";
      exports2.cssText = require2("./textmate-css");
      exports2.$id = "ace/theme/textmate";
      var dom = require2("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/net", "ace/lib/dom", "ace/lib/app_config", "ace/theme/textmate"], function(require2, exports2, module2) {
      "no use strict";
      var lang = require2("./lib/lang");
      var net = require2("./lib/net");
      var dom = require2("./lib/dom");
      var AppConfig = require2("./lib/app_config").AppConfig;
      module2.exports = exports2 = new AppConfig();
      var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {},
        loadWorkerFromBlob: true,
        sharedPopups: false,
        useStrictCSP: null
      };
      exports2.get = function(key) {
        if (!options.hasOwnProperty(key))
          throw new Error("Unknown config key: " + key);
        return options[key];
      };
      exports2.set = function(key, value) {
        if (options.hasOwnProperty(key))
          options[key] = value;
        else if (this.setDefaultValue("", key, value) == false)
          throw new Error("Unknown config key: " + key);
        if (key == "useStrictCSP")
          dom.useStrictCSP(value);
      };
      exports2.all = function() {
        return lang.copyObject(options);
      };
      exports2.$modes = {};
      exports2.moduleUrl = function(name, component) {
        if (options.$moduleUrls[name])
          return options.$moduleUrls[name];
        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
          var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
          base = base.replace(re, "");
        }
        if ((!base || base == component) && parts.length > 1)
          base = parts[parts.length - 2];
        var path2 = options[component + "Path"];
        if (path2 == null) {
          path2 = options.basePath;
        } else if (sep == "/") {
          component = sep = "";
        }
        if (path2 && path2.slice(-1) != "/")
          path2 += "/";
        return path2 + component + sep + base + this.get("suffix");
      };
      exports2.setModuleUrl = function(name, subst) {
        return options.$moduleUrls[name] = subst;
      };
      var loader = function(moduleName, cb) {
        if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate")
          return cb(null, require2("./theme/textmate"));
        if (customLoader)
          return customLoader(moduleName, cb);
        console.error("loader is not configured");
      };
      var customLoader;
      exports2.setLoader = function(cb) {
        customLoader = cb;
      };
      exports2.dynamicModules = /* @__PURE__ */ Object.create(null);
      exports2.$loading = {};
      exports2.$loaded = {};
      exports2.loadModule = function(moduleId, onLoad) {
        var loadedModule;
        if (Array.isArray(moduleId)) {
          var moduleType = moduleId[0];
          var moduleName = moduleId[1];
        } else if (typeof moduleId == "string") {
          var moduleName = moduleId;
        }
        var load = function(module3) {
          if (module3 && !exports2.$loading[moduleName])
            return onLoad && onLoad(module3);
          if (!exports2.$loading[moduleName])
            exports2.$loading[moduleName] = [];
          exports2.$loading[moduleName].push(onLoad);
          if (exports2.$loading[moduleName].length > 1)
            return;
          var afterLoad = function() {
            loader(moduleName, function(err, module4) {
              if (module4)
                exports2.$loaded[moduleName] = module4;
              exports2._emit("load.module", { name: moduleName, module: module4 });
              var listeners = exports2.$loading[moduleName];
              exports2.$loading[moduleName] = null;
              listeners.forEach(function(onLoad2) {
                onLoad2 && onLoad2(module4);
              });
            });
          };
          if (!exports2.get("packaged"))
            return afterLoad();
          net.loadScript(exports2.moduleUrl(moduleName, moduleType), afterLoad);
          reportErrorIfPathIsNotConfigured();
        };
        if (exports2.dynamicModules[moduleName]) {
          exports2.dynamicModules[moduleName]().then(function(module3) {
            if (module3.default) {
              load(module3.default);
            } else {
              load(module3);
            }
          });
        } else {
          try {
            loadedModule = this.$require(moduleName);
          } catch (e75) {
          }
          load(loadedModule || exports2.$loaded[moduleName]);
        }
      };
      exports2.$require = function(moduleName) {
        if (typeof module2["require"] == "function") {
          var req = "require";
          return module2[req](moduleName);
        }
      };
      exports2.setModuleLoader = function(moduleName, onLoad) {
        exports2.dynamicModules[moduleName] = onLoad;
      };
      var reportErrorIfPathIsNotConfigured = function() {
        if (!options.basePath && !options.workerPath && !options.modePath && !options.themePath && !Object.keys(options.$moduleUrls).length) {
          console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
          reportErrorIfPathIsNotConfigured = function() {
          };
        }
      };
      exports2.version = "1.41.0";
    });
    ace.define("ace/loader_build", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      require2("./lib/fixoldbrowsers");
      var config2 = require2("./config");
      config2.setLoader(function(moduleName, cb) {
        require2([moduleName], function(module3) {
          cb(null, module3);
        });
      });
      var global2 = /* @__PURE__ */ function() {
        return this || typeof window != "undefined" && window;
      }();
      module2.exports = function(ace4) {
        config2.init = init2;
        config2.$require = require2;
        ace4.require = require2;
        if (typeof define === "function")
          ace4.define = define;
      };
      init2(true);
      function init2(packaged) {
        if (!global2 || !global2.document)
          return;
        config2.set("packaged", packaged || require2.packaged || module2.packaged || global2.define && define.packaged);
        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript2 = document.currentScript || document._currentScript;
        var currentDocument = currentScript2 && currentScript2.ownerDocument || document;
        if (currentScript2 && currentScript2.src) {
          scriptUrl = currentScript2.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "";
        }
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; i++) {
          var script = scripts[i];
          var src2 = script.src || script.getAttribute("src");
          if (!src2)
            continue;
          var attributes = script.attributes;
          for (var j = 0, l = attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
              scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
          }
          var m = src2.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
          if (m)
            scriptUrl = m[1];
        }
        if (scriptUrl) {
          scriptOptions.base = scriptOptions.base || scriptUrl;
          scriptOptions.packaged = true;
        }
        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;
        for (var key in scriptOptions)
          if (typeof scriptOptions[key] !== "undefined")
            config2.set(key, scriptOptions[key]);
      }
      function deHyphenate(str) {
        return str.replace(/-(.)/g, function(m, m1) {
          return m1.toUpperCase();
        });
      }
    });
    ace.define("ace/range", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var Range2 = (
        /** @class */
        function() {
          function Range3(startRow, startColumn, endRow, endColumn) {
            this.start = {
              row: startRow,
              column: startColumn
            };
            this.end = {
              row: endRow,
              column: endColumn
            };
          }
          Range3.prototype.isEqual = function(range) {
            return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
          };
          Range3.prototype.toString = function() {
            return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
          };
          Range3.prototype.contains = function(row, column) {
            return this.compare(row, column) == 0;
          };
          Range3.prototype.compareRange = function(range) {
            var cmp, end = range.end, start = range.start;
            cmp = this.compare(end.row, end.column);
            if (cmp == 1) {
              cmp = this.compare(start.row, start.column);
              if (cmp == 1) {
                return 2;
              } else if (cmp == 0) {
                return 1;
              } else {
                return 0;
              }
            } else if (cmp == -1) {
              return -2;
            } else {
              cmp = this.compare(start.row, start.column);
              if (cmp == -1) {
                return -1;
              } else if (cmp == 1) {
                return 42;
              } else {
                return 0;
              }
            }
          };
          Range3.prototype.comparePoint = function(p) {
            return this.compare(p.row, p.column);
          };
          Range3.prototype.containsRange = function(range) {
            return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
          };
          Range3.prototype.intersects = function(range) {
            var cmp = this.compareRange(range);
            return cmp == -1 || cmp == 0 || cmp == 1;
          };
          Range3.prototype.isEnd = function(row, column) {
            return this.end.row == row && this.end.column == column;
          };
          Range3.prototype.isStart = function(row, column) {
            return this.start.row == row && this.start.column == column;
          };
          Range3.prototype.setStart = function(row, column) {
            if (typeof row == "object") {
              this.start.column = row.column;
              this.start.row = row.row;
            } else {
              this.start.row = row;
              this.start.column = column;
            }
          };
          Range3.prototype.setEnd = function(row, column) {
            if (typeof row == "object") {
              this.end.column = row.column;
              this.end.row = row.row;
            } else {
              this.end.row = row;
              this.end.column = column;
            }
          };
          Range3.prototype.inside = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range3.prototype.insideStart = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range3.prototype.insideEnd = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range3.prototype.compare = function(row, column) {
            if (!this.isMultiLine()) {
              if (row === this.start.row) {
                return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
              }
            }
            if (row < this.start.row)
              return -1;
            if (row > this.end.row)
              return 1;
            if (this.start.row === row)
              return column >= this.start.column ? 0 : -1;
            if (this.end.row === row)
              return column <= this.end.column ? 0 : 1;
            return 0;
          };
          Range3.prototype.compareStart = function(row, column) {
            if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          Range3.prototype.compareEnd = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else {
              return this.compare(row, column);
            }
          };
          Range3.prototype.compareInside = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          Range3.prototype.clipRows = function(firstRow, lastRow) {
            if (this.end.row > lastRow)
              var end = { row: lastRow + 1, column: 0 };
            else if (this.end.row < firstRow)
              var end = { row: firstRow, column: 0 };
            if (this.start.row > lastRow)
              var start = { row: lastRow + 1, column: 0 };
            else if (this.start.row < firstRow)
              var start = { row: firstRow, column: 0 };
            return Range3.fromPoints(start || this.start, end || this.end);
          };
          Range3.prototype.extend = function(row, column) {
            var cmp = this.compare(row, column);
            if (cmp == 0)
              return this;
            else if (cmp == -1)
              var start = { row, column };
            else
              var end = { row, column };
            return Range3.fromPoints(start || this.start, end || this.end);
          };
          Range3.prototype.isEmpty = function() {
            return this.start.row === this.end.row && this.start.column === this.end.column;
          };
          Range3.prototype.isMultiLine = function() {
            return this.start.row !== this.end.row;
          };
          Range3.prototype.clone = function() {
            return Range3.fromPoints(this.start, this.end);
          };
          Range3.prototype.collapseRows = function() {
            if (this.end.column == 0)
              return new Range3(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
            else
              return new Range3(this.start.row, 0, this.end.row, 0);
          };
          Range3.prototype.toScreenRange = function(session) {
            var screenPosStart = session.documentToScreenPosition(this.start);
            var screenPosEnd = session.documentToScreenPosition(this.end);
            return new Range3(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
          };
          Range3.prototype.moveBy = function(row, column) {
            this.start.row += row;
            this.start.column += column;
            this.end.row += row;
            this.end.column += column;
          };
          return Range3;
        }()
      );
      Range2.fromPoints = function(start, end) {
        return new Range2(start.row, start.column, end.row, end.column);
      };
      Range2.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      exports2.Range = Range2;
    });
    ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/oop"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./oop");
      var Keys = {
        MODIFIER_KEYS: {
          16: "Shift",
          17: "Ctrl",
          18: "Alt",
          224: "Meta",
          91: "MetaLeft",
          92: "MetaRight",
          93: "ContextMenu"
        },
        KEY_MODS: {
          "ctrl": 1,
          "alt": 2,
          "option": 2,
          "shift": 4,
          "super": 8,
          "meta": 8,
          "command": 8,
          "cmd": 8,
          "control": 1
        },
        FUNCTION_KEYS: {
          8: "Backspace",
          9: "Tab",
          13: "Return",
          19: "Pause",
          27: "Esc",
          32: "Space",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "Left",
          38: "Up",
          39: "Right",
          40: "Down",
          44: "Print",
          45: "Insert",
          46: "Delete",
          "-13": "NumpadEnter",
          144: "Numlock",
          145: "Scrolllock"
        },
        PRINTABLE_KEYS: {
          32: " ",
          59: ";",
          61: "=",
          107: "+",
          109: "-",
          110: ".",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
          111: "/",
          106: "*"
        }
      };
      var codeToKeyCode = {
        Command: 224,
        Backspace: 8,
        Tab: 9,
        Return: 13,
        Enter: 13,
        Pause: 19,
        Escape: 27,
        PageUp: 33,
        PageDown: 34,
        End: 35,
        Home: 36,
        Insert: 45,
        Delete: 46,
        ArrowLeft: 37,
        ArrowUp: 38,
        ArrowRight: 39,
        ArrowDown: 40,
        Backquote: 192,
        Minus: 189,
        Equal: 187,
        BracketLeft: 219,
        Backslash: 220,
        BracketRight: 221,
        Semicolon: 186,
        Quote: 222,
        Comma: 188,
        Period: 190,
        Slash: 191,
        Space: 32,
        NumpadAdd: 107,
        NumpadDecimal: 110,
        NumpadSubtract: 109,
        NumpadDivide: 111,
        NumpadMultiply: 106
      };
      for (var i = 0; i < 10; i++) {
        codeToKeyCode["Digit" + i] = 48 + i;
        codeToKeyCode["Numpad" + i] = 96 + i;
        Keys.PRINTABLE_KEYS[48 + i] = "" + i;
        Keys.FUNCTION_KEYS[96 + i] = "Numpad" + i;
      }
      for (var i = 65; i < 91; i++) {
        var chr = String.fromCharCode(i + 32);
        codeToKeyCode["Key" + chr.toUpperCase()] = i;
        Keys.PRINTABLE_KEYS[i] = chr;
      }
      for (var i = 1; i < 13; i++) {
        codeToKeyCode["F" + i] = 111 + i;
        Keys.FUNCTION_KEYS[111 + i] = "F" + i;
      }
      var modifiers = {
        Shift: 16,
        Control: 17,
        Alt: 18,
        Meta: 224
      };
      for (var mod in modifiers) {
        codeToKeyCode[mod] = codeToKeyCode[mod + "Left"] = codeToKeyCode[mod + "Right"] = modifiers[mod];
      }
      exports2.$codeToKeyCode = codeToKeyCode;
      Keys.PRINTABLE_KEYS[173] = "-";
      for (var j in Keys.FUNCTION_KEYS) {
        var name = Keys.FUNCTION_KEYS[j].toLowerCase();
        Keys[name] = parseInt(j, 10);
      }
      for (var j in Keys.PRINTABLE_KEYS) {
        var name = Keys.PRINTABLE_KEYS[j].toLowerCase();
        Keys[name] = parseInt(j, 10);
      }
      oop.mixin(Keys, Keys.MODIFIER_KEYS);
      oop.mixin(Keys, Keys.PRINTABLE_KEYS);
      oop.mixin(Keys, Keys.FUNCTION_KEYS);
      Keys.enter = Keys["return"];
      Keys.escape = Keys.esc;
      Keys.del = Keys["delete"];
      (function() {
        var mods = ["cmd", "ctrl", "alt", "shift"];
        for (var i2 = Math.pow(2, mods.length); i2--; ) {
          Keys.KEY_MODS[i2] = mods.filter(function(x) {
            return i2 & Keys.KEY_MODS[x];
          }).join("-") + "-";
        }
      })();
      Keys.KEY_MODS[0] = "";
      Keys.KEY_MODS[-1] = "input-";
      oop.mixin(exports2, Keys);
      exports2.default = exports2;
      exports2.keyCodeToString = function(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string")
          keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
      };
    });
    ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var keys = require2("./keys");
      var useragent = require2("./useragent");
      var pressedKeys = null;
      var ts = 0;
      var activeListenerOptions;
      function detectListenerOptionsSupport() {
        activeListenerOptions = false;
        try {
          document.createComment("").addEventListener("test", function() {
          }, {
            get passive() {
              activeListenerOptions = { passive: false };
              return true;
            }
          });
        } catch (e75) {
        }
      }
      function getListenerOptions() {
        if (activeListenerOptions == void 0)
          detectListenerOptionsSupport();
        return activeListenerOptions;
      }
      function EventListener(elem, type2, callback) {
        this.elem = elem;
        this.type = type2;
        this.callback = callback;
      }
      EventListener.prototype.destroy = function() {
        removeListener(this.elem, this.type, this.callback);
        this.elem = this.type = this.callback = void 0;
      };
      var addListener = exports2.addListener = function(elem, type2, callback, destroyer) {
        elem.addEventListener(type2, callback, getListenerOptions());
        if (destroyer)
          destroyer.$toDestroy.push(new EventListener(elem, type2, callback));
      };
      var removeListener = exports2.removeListener = function(elem, type2, callback) {
        elem.removeEventListener(type2, callback, getListenerOptions());
      };
      exports2.stopEvent = function(e75) {
        exports2.stopPropagation(e75);
        exports2.preventDefault(e75);
        return false;
      };
      exports2.stopPropagation = function(e75) {
        if (e75.stopPropagation)
          e75.stopPropagation();
      };
      exports2.preventDefault = function(e75) {
        if (e75.preventDefault)
          e75.preventDefault();
      };
      exports2.getButton = function(e75) {
        if (e75.type == "dblclick")
          return 0;
        if (e75.type == "contextmenu" || useragent.isMac && (e75.ctrlKey && !e75.altKey && !e75.shiftKey))
          return 2;
        return e75.button;
      };
      exports2.capture = function(el, eventHandler, releaseCaptureHandler) {
        var ownerDocument = el && el.ownerDocument || document;
        function onMouseUp(e75) {
          eventHandler && eventHandler(e75);
          releaseCaptureHandler && releaseCaptureHandler(e75);
          removeListener(ownerDocument, "mousemove", eventHandler);
          removeListener(ownerDocument, "mouseup", onMouseUp);
          removeListener(ownerDocument, "dragstart", onMouseUp);
        }
        addListener(ownerDocument, "mousemove", eventHandler);
        addListener(ownerDocument, "mouseup", onMouseUp);
        addListener(ownerDocument, "dragstart", onMouseUp);
        return onMouseUp;
      };
      exports2.addMouseWheelListener = function(el, callback, destroyer) {
        addListener(el, "wheel", function(e75) {
          var factor = 0.15;
          var deltaX = e75.deltaX || 0;
          var deltaY = e75.deltaY || 0;
          switch (e75.deltaMode) {
            case e75.DOM_DELTA_PIXEL:
              e75.wheelX = deltaX * factor;
              e75.wheelY = deltaY * factor;
              break;
            case e75.DOM_DELTA_LINE:
              var linePixels = 15;
              e75.wheelX = deltaX * linePixels;
              e75.wheelY = deltaY * linePixels;
              break;
            case e75.DOM_DELTA_PAGE:
              var pagePixels = 150;
              e75.wheelX = deltaX * pagePixels;
              e75.wheelY = deltaY * pagePixels;
              break;
          }
          callback(e75);
        }, destroyer);
      };
      exports2.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
        var clicks = 0;
        var startX, startY, timer;
        var eventNames = {
          2: "dblclick",
          3: "tripleclick",
          4: "quadclick"
        };
        function onMousedown(e75) {
          if (exports2.getButton(e75) !== 0) {
            clicks = 0;
          } else if (e75.detail > 1) {
            clicks++;
            if (clicks > 4)
              clicks = 1;
          } else {
            clicks = 1;
          }
          if (useragent.isIE) {
            var isNewClick = Math.abs(e75.clientX - startX) > 5 || Math.abs(e75.clientY - startY) > 5;
            if (!timer || isNewClick)
              clicks = 1;
            if (timer)
              clearTimeout(timer);
            timer = setTimeout(function() {
              timer = null;
            }, timeouts[clicks - 1] || 600);
            if (clicks == 1) {
              startX = e75.clientX;
              startY = e75.clientY;
            }
          }
          e75._clicks = clicks;
          eventHandler[callbackName]("mousedown", e75);
          if (clicks > 4)
            clicks = 0;
          else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e75);
        }
        if (!Array.isArray(elements))
          elements = [elements];
        elements.forEach(function(el) {
          addListener(el, "mousedown", onMousedown, destroyer);
        });
      };
      function getModifierHash(e75) {
        return 0 | (e75.ctrlKey ? 1 : 0) | (e75.altKey ? 2 : 0) | (e75.shiftKey ? 4 : 0) | (e75.metaKey ? 8 : 0);
      }
      exports2.getModifierString = function(e75) {
        return keys.KEY_MODS[getModifierHash(e75)];
      };
      function normalizeCommandKeys(callback, e75, keyCode) {
        var hashId = getModifierHash(e75);
        if (!keyCode && e75.code) {
          keyCode = keys.$codeToKeyCode[e75.code] || keyCode;
        }
        if (!useragent.isMac && pressedKeys) {
          if (e75.getModifierState && (e75.getModifierState("OS") || e75.getModifierState("Win")))
            hashId |= 8;
          if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
              pressedKeys.altGr = 0;
            else
              return;
          }
          if (keyCode === 18 || keyCode === 17) {
            var location2 = e75.location;
            if (keyCode === 17 && location2 === 1) {
              if (pressedKeys[keyCode] == 1)
                ts = e75.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location2 === 2) {
              var dt = e75.timeStamp - ts;
              if (dt < 50)
                pressedKeys.altGr = true;
            }
          }
        }
        if (keyCode in keys.MODIFIER_KEYS) {
          keyCode = -1;
        }
        if (!hashId && keyCode === 13) {
          if (e75.location === 3) {
            callback(e75, hashId, -keyCode);
            if (e75.defaultPrevented)
              return;
          }
        }
        if (useragent.isChromeOS && hashId & 8) {
          callback(e75, hashId, keyCode);
          if (e75.defaultPrevented)
            return;
          else
            hashId &= ~8;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
          return false;
        }
        return callback(e75, hashId, keyCode);
      }
      exports2.addCommandKeyListener = function(el, callback, destroyer) {
        var lastDefaultPrevented = null;
        addListener(el, "keydown", function(e75) {
          pressedKeys[e75.keyCode] = (pressedKeys[e75.keyCode] || 0) + 1;
          var result = normalizeCommandKeys(callback, e75, e75.keyCode);
          lastDefaultPrevented = e75.defaultPrevented;
          return result;
        }, destroyer);
        addListener(el, "keypress", function(e75) {
          if (lastDefaultPrevented && (e75.ctrlKey || e75.altKey || e75.shiftKey || e75.metaKey)) {
            exports2.stopEvent(e75);
            lastDefaultPrevented = null;
          }
        }, destroyer);
        addListener(el, "keyup", function(e75) {
          pressedKeys[e75.keyCode] = null;
        }, destroyer);
        if (!pressedKeys) {
          resetPressedKeys();
          addListener(window, "focus", resetPressedKeys);
        }
      };
      function resetPressedKeys() {
        pressedKeys = /* @__PURE__ */ Object.create(null);
      }
      if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports2.nextTick = function(callback, win) {
          win = win || window;
          var messageName = "zero-timeout-message-" + postMessageId++;
          var listener = function(e75) {
            if (e75.data == messageName) {
              exports2.stopPropagation(e75);
              removeListener(win, "message", listener);
              callback();
            }
          };
          addListener(win, "message", listener);
          win.postMessage(messageName, "*");
        };
      }
      exports2.$idleBlocked = false;
      exports2.onIdle = function(cb, timeout) {
        return setTimeout(function handler() {
          if (!exports2.$idleBlocked) {
            cb();
          } else {
            setTimeout(handler, 100);
          }
        }, timeout);
      };
      exports2.$idleBlockId = null;
      exports2.blockIdle = function(delay) {
        if (exports2.$idleBlockId)
          clearTimeout(exports2.$idleBlockId);
        exports2.$idleBlocked = true;
        exports2.$idleBlockId = setTimeout(function() {
          exports2.$idleBlocked = false;
        }, delay || 100);
      };
      exports2.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window["mozRequestAnimationFrame"] || window["webkitRequestAnimationFrame"] || window["msRequestAnimationFrame"] || window["oRequestAnimationFrame"]);
      if (exports2.nextFrame)
        exports2.nextFrame = exports2.nextFrame.bind(window);
      else
        exports2.nextFrame = function(callback) {
          setTimeout(callback, 17);
        };
    });
    ace.define("ace/clipboard", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var $cancelT;
      module2.exports = {
        lineMode: false,
        pasteCancelled: function() {
          if ($cancelT && $cancelT > Date.now() - 50)
            return true;
          return $cancelT = false;
        },
        cancel: function() {
          $cancelT = Date.now();
        }
      };
    });
    ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/config", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/clipboard", "ace/lib/keys"], function(require2, exports2, module2) {
      "use strict";
      var event = require2("../lib/event");
      var nls = require2("../config").nls;
      var useragent = require2("../lib/useragent");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var clipboard = require2("../clipboard");
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var HAS_FOCUS_ARGS = useragent.isChrome > 63;
      var MAX_LINE_LENGTH = 400;
      var KEYS = require2("../lib/keys");
      var MODS = KEYS.KEY_MODS;
      var isIOS = useragent.isIOS;
      var valueResetRegex = isIOS ? /\s/ : /\n/;
      var isMobile = useragent.isMobile;
      var TextInput;
      TextInput = function(parentNode, host) {
        var text = dom.createElement("textarea");
        text.className = "ace_text-input";
        text.setAttribute("wrap", "off");
        text.setAttribute("autocorrect", "off");
        text.setAttribute("autocapitalize", "off");
        text.setAttribute("spellcheck", "false");
        text.style.opacity = "0";
        parentNode.insertBefore(text, parentNode.firstChild);
        this.setHost = function(newHost) {
          host = newHost;
        };
        var copied = false;
        var pasted = false;
        var inComposition = false;
        var sendingText = false;
        var tempStyle = "";
        if (!isMobile)
          text.style.fontSize = "1px";
        var commandMode = false;
        var ignoreFocusEvents = false;
        var lastValue = "";
        var lastSelectionStart = 0;
        var lastSelectionEnd = 0;
        var lastRestoreEnd = 0;
        var rowStart = Number.MAX_SAFE_INTEGER;
        var rowEnd = Number.MIN_SAFE_INTEGER;
        var numberOfExtraLines = 0;
        try {
          var isFocused = document.activeElement === text;
        } catch (e75) {
        }
        this.setNumberOfExtraLines = function(number) {
          rowStart = Number.MAX_SAFE_INTEGER;
          rowEnd = Number.MIN_SAFE_INTEGER;
          if (number < 0) {
            numberOfExtraLines = 0;
            return;
          }
          numberOfExtraLines = number;
        };
        this.setAriaLabel = function() {
          var ariaLabel = "";
          if (host.$textInputAriaLabel) {
            ariaLabel += "".concat(host.$textInputAriaLabel, ", ");
          }
          if (host.session) {
            var row = host.session.selection.cursor.row;
            ariaLabel += nls("text-input.aria-label", "Cursor at row $0", [row + 1]);
          }
          text.setAttribute("aria-label", ariaLabel);
        };
        this.setAriaOptions = function(options) {
          if (options.activeDescendant) {
            text.setAttribute("aria-haspopup", "true");
            text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
            text.setAttribute("aria-activedescendant", options.activeDescendant);
          } else {
            text.setAttribute("aria-haspopup", "false");
            text.setAttribute("aria-autocomplete", "both");
            text.removeAttribute("aria-activedescendant");
          }
          if (options.role) {
            text.setAttribute("role", options.role);
          }
          if (options.setLabel) {
            text.setAttribute("aria-roledescription", nls("text-input.aria-roledescription", "editor"));
            this.setAriaLabel();
          }
        };
        this.setAriaOptions({ role: "textbox" });
        event.addListener(text, "blur", function(e75) {
          if (ignoreFocusEvents)
            return;
          host.onBlur(e75);
          isFocused = false;
        }, host);
        event.addListener(text, "focus", function(e75) {
          if (ignoreFocusEvents)
            return;
          isFocused = true;
          if (useragent.isEdge) {
            try {
              if (!document.hasFocus())
                return;
            } catch (e76) {
            }
          }
          host.onFocus(e75);
          if (useragent.isEdge)
            setTimeout(resetSelection);
          else
            resetSelection();
        }, host);
        this.$focusScroll = false;
        this.focus = function() {
          this.setAriaOptions({
            setLabel: host.renderer.enableKeyboardAccessibility
          });
          if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
            return text.focus({ preventScroll: true });
          var top = text.style.top;
          text.style.position = "fixed";
          text.style.top = "0px";
          try {
            var isTransformed = text.getBoundingClientRect().top != 0;
          } catch (e75) {
            return;
          }
          var ancestors = [];
          if (isTransformed) {
            var t2 = text.parentElement;
            while (t2 && t2.nodeType == 1) {
              ancestors.push(t2);
              t2.setAttribute("ace_nocontext", "true");
              if (!t2.parentElement && t2.getRootNode)
                t2 = t2.getRootNode()["host"];
              else
                t2 = t2.parentElement;
            }
          }
          text.focus({ preventScroll: true });
          if (isTransformed) {
            ancestors.forEach(function(p) {
              p.removeAttribute("ace_nocontext");
            });
          }
          setTimeout(function() {
            text.style.position = "";
            if (text.style.top == "0px")
              text.style.top = top;
          }, 0);
        };
        this.blur = function() {
          text.blur();
        };
        this.isFocused = function() {
          return isFocused;
        };
        host.on("beforeEndOperation", function() {
          var curOp = host.curOp;
          var commandName = curOp && curOp.command && curOp.command.name;
          if (commandName == "insertstring")
            return;
          var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
          if (inComposition && isUserAction) {
            lastValue = text.value = "";
            onCompositionEnd();
          }
          resetSelection();
        });
        host.on("changeSelection", this.setAriaLabel);
        var positionToSelection = function(row, column) {
          var selection = column;
          for (var i = 1; i <= row - rowStart && i < 2 * numberOfExtraLines + 1; i++) {
            selection += host.session.getLine(row - i).length + 1;
          }
          return selection;
        };
        var resetSelection = isIOS ? function(value) {
          if (!isFocused || copied && !value || sendingText)
            return;
          if (!value)
            value = "";
          var newValue = "\n ab" + value + "cde fg\n";
          if (newValue != text.value)
            text.value = lastValue = newValue;
          var selectionStart = 4;
          var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
          if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
            text.setSelectionRange(selectionStart, selectionEnd);
          }
          lastSelectionStart = selectionStart;
          lastSelectionEnd = selectionEnd;
        } : function() {
          if (inComposition || sendingText)
            return;
          if (!isFocused && !afterContextMenu)
            return;
          inComposition = true;
          var selectionStart = 0;
          var selectionEnd = 0;
          var line = "";
          if (host.session) {
            var selection = host.selection;
            var range = selection.getRange();
            var row = selection.cursor.row;
            if (row === rowEnd + 1) {
              rowStart = rowEnd + 1;
              rowEnd = rowStart + 2 * numberOfExtraLines;
            } else if (row === rowStart - 1) {
              rowEnd = rowStart - 1;
              rowStart = rowEnd - 2 * numberOfExtraLines;
            } else if (row < rowStart - 1 || row > rowEnd + 1) {
              rowStart = row > numberOfExtraLines ? row - numberOfExtraLines : 0;
              rowEnd = row > numberOfExtraLines ? row + numberOfExtraLines : 2 * numberOfExtraLines;
            }
            var lines = [];
            for (var i = rowStart; i <= rowEnd; i++) {
              lines.push(host.session.getLine(i));
            }
            line = lines.join("\n");
            selectionStart = positionToSelection(range.start.row, range.start.column);
            selectionEnd = positionToSelection(range.end.row, range.end.column);
            if (range.start.row < rowStart) {
              var prevLine = host.session.getLine(rowStart - 1);
              selectionStart = range.start.row < rowStart - 1 ? 0 : selectionStart;
              selectionEnd += prevLine.length + 1;
              line = prevLine + "\n" + line;
            } else if (range.end.row > rowEnd) {
              var nextLine = host.session.getLine(rowEnd + 1);
              selectionEnd = range.end.row > rowEnd + 1 ? nextLine.length : range.end.column;
              selectionEnd += line.length + 1;
              line = line + "\n" + nextLine;
            } else if (isMobile && row > 0) {
              line = "\n" + line;
              selectionEnd += 1;
              selectionStart += 1;
            }
            if (line.length > MAX_LINE_LENGTH) {
              if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                line = line.slice(0, MAX_LINE_LENGTH);
              } else {
                line = "\n";
                if (selectionStart == selectionEnd) {
                  selectionStart = selectionEnd = 0;
                } else {
                  selectionStart = 0;
                  selectionEnd = 1;
                }
              }
            }
            var newValue = line + "\n\n";
            if (newValue != lastValue) {
              text.value = lastValue = newValue;
              lastSelectionStart = lastSelectionEnd = newValue.length;
            }
          }
          if (afterContextMenu) {
            lastSelectionStart = text.selectionStart;
            lastSelectionEnd = text.selectionEnd;
          }
          if (lastSelectionEnd != selectionEnd || lastSelectionStart != selectionStart || text.selectionEnd != lastSelectionEnd) {
            try {
              text.setSelectionRange(selectionStart, selectionEnd);
              lastSelectionStart = selectionStart;
              lastSelectionEnd = selectionEnd;
            } catch (e75) {
            }
          }
          inComposition = false;
        };
        this.resetSelection = resetSelection;
        if (isFocused)
          host.onFocus();
        var isAllSelected = function(text2) {
          return text2.selectionStart === 0 && text2.selectionEnd >= lastValue.length && text2.value === lastValue && lastValue && text2.selectionEnd !== lastSelectionEnd;
        };
        var onSelect = function(e75) {
          if (inComposition)
            return;
          if (copied) {
            copied = false;
          } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
          } else if (isMobile && text.selectionStart != lastSelectionStart) {
            resetSelection();
          }
        };
        var inputHandler = null;
        this.setInputHandler = function(cb) {
          inputHandler = cb;
        };
        this.getInputHandler = function() {
          return inputHandler;
        };
        var afterContextMenu = false;
        var sendText = function(value, fromInput) {
          if (afterContextMenu)
            afterContextMenu = false;
          if (pasted) {
            resetSelection();
            if (value)
              host.onPaste(value);
            pasted = false;
            return "";
          } else {
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            var extendLeft = lastSelectionStart;
            var extendRight = lastValue.length - lastSelectionEnd;
            var inserted = value;
            var restoreStart = value.length - selectionStart;
            var restoreEnd = value.length - selectionEnd;
            var i = 0;
            while (extendLeft > 0 && lastValue[i] == value[i]) {
              i++;
              extendLeft--;
            }
            inserted = inserted.slice(i);
            i = 1;
            while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]) {
              i++;
              extendRight--;
            }
            restoreStart -= i - 1;
            restoreEnd -= i - 1;
            var endIndex = inserted.length - i + 1;
            if (endIndex < 0) {
              extendLeft = -endIndex;
              endIndex = 0;
            }
            inserted = inserted.slice(0, endIndex);
            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
              return "";
            sendingText = true;
            var shouldReset = false;
            if (useragent.isAndroid && inserted == ". ") {
              inserted = "  ";
              shouldReset = true;
            }
            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
              host.onTextInput(inserted);
            } else {
              host.onTextInput(inserted, {
                extendLeft,
                extendRight,
                restoreStart,
                restoreEnd
              });
            }
            sendingText = false;
            lastValue = value;
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
            lastRestoreEnd = restoreEnd;
            return shouldReset ? "\n" : inserted;
          }
        };
        var onInput = function(e75) {
          if (inComposition)
            return onCompositionUpdate();
          if (e75 && e75.inputType) {
            if (e75.inputType == "historyUndo")
              return host.execCommand("undo");
            if (e75.inputType == "historyRedo")
              return host.execCommand("redo");
          }
          var data = text.value;
          var inserted = sendText(data, true);
          if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {
            resetSelection();
          }
        };
        var handleClipboardData = function(e75, data, forceIEMime) {
          var clipboardData = e75.clipboardData || window["clipboardData"];
          if (!clipboardData || BROKEN_SETDATA)
            return;
          var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
          try {
            if (data) {
              return clipboardData.setData(mime, data) !== false;
            } else {
              return clipboardData.getData(mime);
            }
          } catch (e76) {
            if (!forceIEMime)
              return handleClipboardData(e76, data, true);
          }
        };
        var doCopy = function(e75, isCut) {
          var data = host.getCopyText();
          if (!data)
            return event.preventDefault(e75);
          if (handleClipboardData(e75, data)) {
            if (isIOS) {
              resetSelection(data);
              copied = data;
              setTimeout(function() {
                copied = false;
              }, 10);
            }
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e75);
          } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function() {
              copied = false;
              resetSelection();
              isCut ? host.onCut() : host.onCopy();
            });
          }
        };
        var onCut = function(e75) {
          doCopy(e75, true);
        };
        var onCopy = function(e75) {
          doCopy(e75, false);
        };
        var onPaste = function(e75) {
          var data = handleClipboardData(e75);
          if (clipboard.pasteCancelled())
            return;
          if (typeof data == "string") {
            if (data)
              host.onPaste(data, e75);
            if (useragent.isIE)
              setTimeout(resetSelection);
            event.preventDefault(e75);
          } else {
            text.value = "";
            pasted = true;
          }
        };
        event.addCommandKeyListener(text, function(e75, hashId, keyCode) {
          if (inComposition)
            return;
          return host.onCommandKey(e75, hashId, keyCode);
        }, host);
        event.addListener(text, "select", onSelect, host);
        event.addListener(text, "input", onInput, host);
        event.addListener(text, "cut", onCut, host);
        event.addListener(text, "copy", onCopy, host);
        event.addListener(text, "paste", onPaste, host);
        if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) {
          event.addListener(parentNode, "keydown", function(e75) {
            if (useragent.isMac && !e75.metaKey || !e75.ctrlKey)
              return;
            switch (e75.keyCode) {
              case 67:
                onCopy(e75);
                break;
              case 86:
                onPaste(e75);
                break;
              case 88:
                onCut(e75);
                break;
            }
          }, host);
        }
        var onCompositionStart = function(e75) {
          if (inComposition || !host.onCompositionStart || host.$readOnly)
            return;
          inComposition = {};
          if (commandMode)
            return;
          if (e75.data)
            inComposition.useTextareaForIME = false;
          setTimeout(onCompositionUpdate, 0);
          host._signal("compositionStart");
          host.on("mousedown", cancelComposition);
          var range = host.getSelectionRange();
          range.end.row = range.start.row;
          range.end.column = range.start.column;
          inComposition.markerRange = range;
          inComposition.selectionStart = lastSelectionStart;
          host.onCompositionStart(inComposition);
          if (inComposition.useTextareaForIME) {
            lastValue = text.value = "";
            lastSelectionStart = 0;
            lastSelectionEnd = 0;
          } else {
            if (text.msGetInputContext)
              inComposition.context = text.msGetInputContext();
            if (text.getInputContext)
              inComposition.context = text.getInputContext();
          }
        };
        var onCompositionUpdate = function() {
          if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
          if (commandMode)
            return cancelComposition();
          if (inComposition.useTextareaForIME) {
            host.onCompositionUpdate(text.value);
          } else {
            var data = text.value;
            sendText(data);
            if (inComposition.markerRange) {
              if (inComposition.context) {
                inComposition.markerRange.start.column = inComposition.selectionStart = inComposition.context.compositionStartOffset;
              }
              inComposition.markerRange.end.column = inComposition.markerRange.start.column + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
            }
          }
        };
        var onCompositionEnd = function(e75) {
          if (!host.onCompositionEnd || host.$readOnly)
            return;
          inComposition = false;
          host.onCompositionEnd();
          host.off("mousedown", cancelComposition);
          if (e75)
            onInput();
        };
        function cancelComposition() {
          ignoreFocusEvents = true;
          text.blur();
          text.focus();
          ignoreFocusEvents = false;
        }
        var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
        function onKeyup(e75) {
          if (e75.keyCode == 27 && text.value.length < text.selectionStart) {
            if (!inComposition)
              lastValue = text.value;
            lastSelectionStart = lastSelectionEnd = -1;
            resetSelection();
          }
          syncComposition();
        }
        event.addListener(text, "compositionstart", onCompositionStart, host);
        event.addListener(text, "compositionupdate", onCompositionUpdate, host);
        event.addListener(text, "keyup", onKeyup, host);
        event.addListener(text, "keydown", syncComposition, host);
        event.addListener(text, "compositionend", onCompositionEnd, host);
        this.getElement = function() {
          return text;
        };
        this.setCommandMode = function(value) {
          commandMode = value;
          text.readOnly = false;
        };
        this.setReadOnly = function(readOnly) {
          if (!commandMode)
            text.readOnly = readOnly;
        };
        this.setCopyWithEmptySelection = function(value) {
        };
        this.onContextMenu = function(e75) {
          afterContextMenu = true;
          resetSelection();
          host._emit("nativecontextmenu", { target: host, domEvent: e75 });
          this.moveToMouse(e75, true);
        };
        this.moveToMouse = function(e75, bringToFront) {
          if (!tempStyle)
            tempStyle = text.style.cssText;
          text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
          var rect = host.container.getBoundingClientRect();
          var style = dom.computedStyle(host.container);
          var top = rect.top + (parseInt(style.borderTopWidth) || 0);
          var left = rect.left + (parseInt(style.borderLeftWidth) || 0);
          var maxTop = rect.bottom - top - text.clientHeight - 2;
          var move = function(e76) {
            dom.translate(text, e76.clientX - left - 2, Math.min(e76.clientY - top - 2, maxTop));
          };
          move(e75);
          if (e75.type != "mousedown")
            return;
          host.renderer.$isMousePressed = true;
          clearTimeout(closeTimeout);
          if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
        };
        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
          clearTimeout(closeTimeout);
          closeTimeout = setTimeout(function() {
            if (tempStyle) {
              text.style.cssText = tempStyle;
              tempStyle = "";
            }
            host.renderer.$isMousePressed = false;
            if (host.renderer.$keepTextAreaAtCursor)
              host.renderer.$moveTextAreaToCursor();
          }, 0);
        }
        var onContextMenu = function(e75) {
          host.textInput.onContextMenu(e75);
          onContextMenuClose();
        };
        event.addListener(text, "mouseup", onContextMenu, host);
        event.addListener(text, "mousedown", function(e75) {
          e75.preventDefault();
          onContextMenuClose();
        }, host);
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
        event.addListener(text, "contextmenu", onContextMenu, host);
        if (isIOS)
          addIosSelectionHandler(parentNode, host, text);
        function addIosSelectionHandler(parentNode2, host2, text2) {
          var typingResetTimeout = null;
          var typing = false;
          text2.addEventListener("keydown", function(e75) {
            if (typingResetTimeout)
              clearTimeout(typingResetTimeout);
            typing = true;
          }, true);
          text2.addEventListener("keyup", function(e75) {
            typingResetTimeout = setTimeout(function() {
              typing = false;
            }, 100);
          }, true);
          var detectArrowKeys = function(e75) {
            if (document.activeElement !== text2)
              return;
            if (typing || inComposition || host2.$mouseHandler.isMousePressed)
              return;
            if (copied) {
              return;
            }
            var selectionStart = text2.selectionStart;
            var selectionEnd = text2.selectionEnd;
            var key = null;
            var modifier = 0;
            if (selectionStart == 0) {
              key = KEYS.up;
            } else if (selectionStart == 1) {
              key = KEYS.home;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
              key = KEYS.end;
            } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
              key = KEYS.left;
              modifier = MODS.option;
            } else if (selectionStart < lastSelectionStart || selectionStart == lastSelectionStart && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
              key = KEYS.left;
            } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
              key = KEYS.down;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
              key = KEYS.right;
              modifier = MODS.option;
            } else if (selectionEnd > lastSelectionEnd || selectionEnd == lastSelectionEnd && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
              key = KEYS.right;
            }
            if (selectionStart !== selectionEnd)
              modifier |= MODS.shift;
            if (key) {
              var result = host2.onCommandKey({}, modifier, key);
              if (!result && host2.commands) {
                key = KEYS.keyCodeToString(key);
                var command = host2.commands.findKeyCommand(modifier, key);
                if (command)
                  host2.execCommand(command);
              }
              lastSelectionStart = selectionStart;
              lastSelectionEnd = selectionEnd;
              resetSelection("");
            }
          };
          document.addEventListener("selectionchange", detectArrowKeys);
          host2.on("destroy", function() {
            document.removeEventListener("selectionchange", detectArrowKeys);
          });
        }
        this.destroy = function() {
          if (text.parentElement)
            text.parentElement.removeChild(text);
        };
      };
      exports2.TextInput = TextInput;
      exports2.$setUserAgentForTests = function(_isMobile, _isIOS) {
        isMobile = _isMobile;
        isIOS = _isIOS;
      };
    });
    ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var useragent = require2("../lib/useragent");
      var DRAG_OFFSET = 0;
      var SCROLL_COOLDOWN_T = 550;
      var DefaultHandlers = (
        /** @class */
        function() {
          function DefaultHandlers2(mouseHandler) {
            mouseHandler.$clickSelection = null;
            var editor2 = mouseHandler.editor;
            editor2.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
            editor2.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
            editor2.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
            editor2.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
            editor2.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
            var exports3 = [
              "select",
              "startSelect",
              "selectEnd",
              "selectAllEnd",
              "selectByWordsEnd",
              "selectByLinesEnd",
              "dragWait",
              "dragWaitEnd",
              "focusWait"
            ];
            exports3.forEach(function(x) {
              mouseHandler[x] = this[x];
            }, this);
            mouseHandler["selectByLines"] = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
            mouseHandler["selectByWords"] = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
          }
          DefaultHandlers2.prototype.onMouseDown = function(ev) {
            var inSelection = ev.inSelection();
            var pos = ev.getDocumentPosition();
            this.mousedownEvent = ev;
            var editor2 = this.editor;
            var button = ev.getButton();
            if (button !== 0) {
              var selectionRange = editor2.getSelectionRange();
              var selectionEmpty = selectionRange.isEmpty();
              if (selectionEmpty || button == 1)
                editor2.selection.moveToPosition(pos);
              if (button == 2) {
                editor2.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                  ev.preventDefault();
              }
              return;
            }
            this.mousedownEvent.time = Date.now();
            if (inSelection && !editor2.isFocused()) {
              editor2.focus();
              if (this.$focusTimeout && !this.$clickSelection && !editor2.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
              }
            }
            this.captureMouse(ev);
            this.startSelect(pos, ev.domEvent._clicks > 1);
            return ev.preventDefault();
          };
          DefaultHandlers2.prototype.startSelect = function(pos, waitForClickSelection) {
            pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var editor2 = this.editor;
            if (!this.mousedownEvent)
              return;
            if (this.mousedownEvent.getShiftKey())
              editor2.selection.selectToPosition(pos);
            else if (!waitForClickSelection)
              editor2.selection.moveToPosition(pos);
            if (!waitForClickSelection)
              this.select();
            editor2.setStyle("ace_selecting");
            this.setState("select");
          };
          DefaultHandlers2.prototype.select = function() {
            var anchor, editor2 = this.editor;
            var cursor = editor2.renderer.screenToTextCoordinates(this.x, this.y);
            if (this.$clickSelection) {
              var cmp = this.$clickSelection.comparePoint(cursor);
              if (cmp == -1) {
                anchor = this.$clickSelection.end;
              } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor2.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor2.selection.selectToPosition(cursor);
            editor2.renderer.scrollCursorIntoView();
          };
          DefaultHandlers2.prototype.extendSelectionBy = function(unitName) {
            var anchor, editor2 = this.editor;
            var cursor = editor2.renderer.screenToTextCoordinates(this.x, this.y);
            var range = editor2.selection[unitName](cursor.row, cursor.column);
            if (this.$clickSelection) {
              var cmpStart = this.$clickSelection.comparePoint(range.start);
              var cmpEnd = this.$clickSelection.comparePoint(range.end);
              if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                  cursor = range.start;
              } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                  cursor = range.end;
              } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor2.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor2.selection.selectToPosition(cursor);
            editor2.renderer.scrollCursorIntoView();
          };
          DefaultHandlers2.prototype.selectByLinesEnd = function() {
            this.$clickSelection = null;
            this.editor.unsetStyle("ace_selecting");
          };
          DefaultHandlers2.prototype.focusWait = function() {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            var time = Date.now();
            if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
              this.startSelect(this.mousedownEvent.getDocumentPosition());
          };
          DefaultHandlers2.prototype.onDoubleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor2 = this.editor;
            var session = editor2.session;
            var range = session.getBracketRange(pos);
            if (range) {
              if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
              }
              this.setState("select");
            } else {
              range = editor2.selection.getWordRange(pos.row, pos.column);
              this.setState("selectByWords");
            }
            this.$clickSelection = range;
            this.select();
          };
          DefaultHandlers2.prototype.onTripleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor2 = this.editor;
            this.setState("selectByLines");
            var range = editor2.getSelectionRange();
            if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
              this.$clickSelection = editor2.selection.getLineRange(range.start.row);
              this.$clickSelection.end = editor2.selection.getLineRange(range.end.row).end;
            } else {
              this.$clickSelection = editor2.selection.getLineRange(pos.row);
            }
            this.select();
          };
          DefaultHandlers2.prototype.onQuadClick = function(ev) {
            var editor2 = this.editor;
            editor2.selectAll();
            this.$clickSelection = editor2.getSelectionRange();
            this.setState("selectAll");
          };
          DefaultHandlers2.prototype.onMouseWheel = function(ev) {
            if (ev.getAccelKey())
              return;
            if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
              ev.wheelX = ev.wheelY;
              ev.wheelY = 0;
            }
            var editor2 = this.editor;
            if (!this.$lastScroll)
              this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
            var prevScroll = this.$lastScroll;
            var t2 = ev.domEvent.timeStamp;
            var dt = t2 - prevScroll.t;
            var vx = dt ? ev.wheelX / dt : prevScroll.vx;
            var vy = dt ? ev.wheelY / dt : prevScroll.vy;
            if (dt < SCROLL_COOLDOWN_T) {
              vx = (vx + prevScroll.vx) / 2;
              vy = (vy + prevScroll.vy) / 2;
            }
            var direction = Math.abs(vx / vy);
            var canScroll = false;
            if (direction >= 1 && editor2.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
              canScroll = true;
            if (direction <= 1 && editor2.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
              canScroll = true;
            if (canScroll) {
              prevScroll.allowed = t2;
            } else if (t2 - prevScroll.allowed < SCROLL_COOLDOWN_T) {
              var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
              if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t2;
              } else {
                prevScroll.allowed = 0;
              }
            }
            prevScroll.t = t2;
            prevScroll.vx = vx;
            prevScroll.vy = vy;
            if (canScroll) {
              editor2.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
              return ev.stop();
            }
          };
          return DefaultHandlers2;
        }()
      );
      DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
      DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
      DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;
      exports2.DefaultHandlers = DefaultHandlers;
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row)
          var cmp = 2 * cursor.column - range.start.column - range.end.column;
        else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
          var cmp = cursor.column - 4;
        else
          var cmp = 2 * cursor.row - range.start.row - range.end.row;
        if (cmp < 0)
          return { cursor: range.start, anchor: range.end };
        else
          return { cursor: range.end, anchor: range.start };
      }
    });
    ace.define("ace/lib/scroll", ["require", "exports", "module"], function(require2, exports2, module2) {
      exports2.preventParentScroll = function preventParentScroll(event) {
        event.stopPropagation();
        var target2 = event.currentTarget;
        var contentOverflows = target2.scrollHeight > target2.clientHeight;
        if (!contentOverflows) {
          event.preventDefault();
        }
      };
    });
    ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/range", "ace/lib/scroll"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var dom = require2("./lib/dom");
      var event = require2("./lib/event");
      var Range2 = require2("./range").Range;
      var preventParentScroll = require2("./lib/scroll").preventParentScroll;
      var CLASSNAME = "ace_tooltip";
      var Tooltip = (
        /** @class */
        function() {
          function Tooltip2(parentNode) {
            this.isOpen = false;
            this.$element = null;
            this.$parentNode = parentNode;
          }
          Tooltip2.prototype.$init = function() {
            this.$element = dom.createElement("div");
            this.$element.className = CLASSNAME;
            this.$element.style.display = "none";
            this.$parentNode.appendChild(this.$element);
            return this.$element;
          };
          Tooltip2.prototype.getElement = function() {
            return this.$element || this.$init();
          };
          Tooltip2.prototype.setText = function(text) {
            this.getElement().textContent = text;
          };
          Tooltip2.prototype.setHtml = function(html) {
            this.getElement().innerHTML = html;
          };
          Tooltip2.prototype.setPosition = function(x, y) {
            this.getElement().style.left = x + "px";
            this.getElement().style.top = y + "px";
          };
          Tooltip2.prototype.setClassName = function(className) {
            dom.addCssClass(this.getElement(), className);
          };
          Tooltip2.prototype.setTheme = function(theme) {
            this.$element.className = CLASSNAME + " " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
          };
          Tooltip2.prototype.show = function(text, x, y) {
            if (text != null)
              this.setText(text);
            if (x != null && y != null)
              this.setPosition(x, y);
            if (!this.isOpen) {
              this.getElement().style.display = "block";
              this.isOpen = true;
            }
          };
          Tooltip2.prototype.hide = function(e75) {
            if (this.isOpen) {
              this.getElement().style.display = "none";
              this.getElement().className = CLASSNAME;
              this.isOpen = false;
            }
          };
          Tooltip2.prototype.getHeight = function() {
            return this.getElement().offsetHeight;
          };
          Tooltip2.prototype.getWidth = function() {
            return this.getElement().offsetWidth;
          };
          Tooltip2.prototype.destroy = function() {
            this.isOpen = false;
            if (this.$element && this.$element.parentNode) {
              this.$element.parentNode.removeChild(this.$element);
            }
          };
          return Tooltip2;
        }()
      );
      var PopupManager = (
        /** @class */
        function() {
          function PopupManager2() {
            this.popups = [];
          }
          PopupManager2.prototype.addPopup = function(popup) {
            this.popups.push(popup);
            this.updatePopups();
          };
          PopupManager2.prototype.removePopup = function(popup) {
            var index = this.popups.indexOf(popup);
            if (index !== -1) {
              this.popups.splice(index, 1);
              this.updatePopups();
            }
          };
          PopupManager2.prototype.updatePopups = function() {
            var e_1, _a, e_2, _b;
            this.popups.sort(function(a, b) {
              return b.priority - a.priority;
            });
            var visiblepopups = [];
            try {
              for (var _c = __values(this.popups), _d = _c.next(); !_d.done; _d = _c.next()) {
                var popup = _d.value;
                var shouldDisplay = true;
                try {
                  for (var visiblepopups_1 = (e_2 = void 0, __values(visiblepopups)), visiblepopups_1_1 = visiblepopups_1.next(); !visiblepopups_1_1.done; visiblepopups_1_1 = visiblepopups_1.next()) {
                    var visiblePopup = visiblepopups_1_1.value;
                    if (this.doPopupsOverlap(visiblePopup, popup)) {
                      shouldDisplay = false;
                      break;
                    }
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (visiblepopups_1_1 && !visiblepopups_1_1.done && (_b = visiblepopups_1.return)) _b.call(visiblepopups_1);
                  } finally {
                    if (e_2) throw e_2.error;
                  }
                }
                if (shouldDisplay) {
                  visiblepopups.push(popup);
                } else {
                  popup.hide();
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          };
          PopupManager2.prototype.doPopupsOverlap = function(popupA, popupB) {
            var rectA = popupA.getElement().getBoundingClientRect();
            var rectB = popupB.getElement().getBoundingClientRect();
            return rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom > rectB.top;
          };
          return PopupManager2;
        }()
      );
      var popupManager = new PopupManager();
      exports2.popupManager = popupManager;
      exports2.Tooltip = Tooltip;
      var HoverTooltip = (
        /** @class */
        function(_super) {
          __extends(HoverTooltip2, _super);
          function HoverTooltip2(parentNode) {
            if (parentNode === void 0) {
              parentNode = document.body;
            }
            var _this = _super.call(this, parentNode) || this;
            _this.timeout = void 0;
            _this.lastT = 0;
            _this.idleTime = 350;
            _this.lastEvent = void 0;
            _this.onMouseOut = _this.onMouseOut.bind(_this);
            _this.onMouseMove = _this.onMouseMove.bind(_this);
            _this.waitForHover = _this.waitForHover.bind(_this);
            _this.hide = _this.hide.bind(_this);
            var el = _this.getElement();
            el.style.whiteSpace = "pre-wrap";
            el.style.pointerEvents = "auto";
            el.addEventListener("mouseout", _this.onMouseOut);
            el.tabIndex = -1;
            el.addEventListener("blur", function() {
              if (!el.contains(document.activeElement))
                this.hide();
            }.bind(_this));
            el.addEventListener("wheel", preventParentScroll);
            return _this;
          }
          HoverTooltip2.prototype.addToEditor = function(editor2) {
            editor2.on("mousemove", this.onMouseMove);
            editor2.on("mousedown", this.hide);
            editor2.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, true);
          };
          HoverTooltip2.prototype.removeFromEditor = function(editor2) {
            editor2.off("mousemove", this.onMouseMove);
            editor2.off("mousedown", this.hide);
            editor2.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, true);
            if (this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
          };
          HoverTooltip2.prototype.onMouseMove = function(e75, editor2) {
            this.lastEvent = e75;
            this.lastT = Date.now();
            var isMousePressed = editor2.$mouseHandler.isMousePressed;
            if (this.isOpen) {
              var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
              if (!this.range || !this.range.contains(pos.row, pos.column) || isMousePressed || this.isOutsideOfText(this.lastEvent)) {
                this.hide();
              }
            }
            if (this.timeout || isMousePressed)
              return;
            this.lastEvent = e75;
            this.timeout = setTimeout(this.waitForHover, this.idleTime);
          };
          HoverTooltip2.prototype.waitForHover = function() {
            if (this.timeout)
              clearTimeout(this.timeout);
            var dt = Date.now() - this.lastT;
            if (this.idleTime - dt > 10) {
              this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);
              return;
            }
            this.timeout = null;
            if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {
              this.$gatherData(this.lastEvent, this.lastEvent.editor);
            }
          };
          HoverTooltip2.prototype.isOutsideOfText = function(e75) {
            var editor2 = e75.editor;
            var docPos = e75.getDocumentPosition();
            var line = editor2.session.getLine(docPos.row);
            if (docPos.column == line.length) {
              var screenPos = editor2.renderer.pixelToScreenCoordinates(e75.clientX, e75.clientY);
              var clippedPos = editor2.session.documentToScreenPosition(docPos.row, docPos.column);
              if (clippedPos.column != screenPos.column || clippedPos.row != screenPos.row) {
                return true;
              }
            }
            return false;
          };
          HoverTooltip2.prototype.setDataProvider = function(value) {
            this.$gatherData = value;
          };
          HoverTooltip2.prototype.showForRange = function(editor2, range, domNode, startingEvent) {
            var MARGIN = 10;
            if (startingEvent && startingEvent != this.lastEvent)
              return;
            if (this.isOpen && document.activeElement == this.getElement())
              return;
            var renderer = editor2.renderer;
            if (!this.isOpen) {
              popupManager.addPopup(this);
              this.$registerCloseEvents();
              this.setTheme(renderer.theme);
            }
            this.isOpen = true;
            this.addMarker(range, editor2.session);
            this.range = Range2.fromPoints(range.start, range.end);
            var position2 = renderer.textToScreenCoordinates(range.start.row, range.start.column);
            var rect = renderer.scroller.getBoundingClientRect();
            if (position2.pageX < rect.left)
              position2.pageX = rect.left;
            var element = this.getElement();
            element.innerHTML = "";
            element.appendChild(domNode);
            element.style.maxHeight = "";
            element.style.display = "block";
            var labelHeight = element.clientHeight;
            var labelWidth = element.clientWidth;
            var spaceBelow = window.innerHeight - position2.pageY - renderer.lineHeight;
            var isAbove = true;
            if (position2.pageY - labelHeight < 0 && position2.pageY < spaceBelow) {
              isAbove = false;
            }
            element.style.maxHeight = (isAbove ? position2.pageY : spaceBelow) - MARGIN + "px";
            element.style.top = isAbove ? "" : position2.pageY + renderer.lineHeight + "px";
            element.style.bottom = isAbove ? window.innerHeight - position2.pageY + "px" : "";
            element.style.left = Math.min(position2.pageX, window.innerWidth - labelWidth - MARGIN) + "px";
          };
          HoverTooltip2.prototype.addMarker = function(range, session) {
            if (this.marker) {
              this.$markerSession.removeMarker(this.marker);
            }
            this.$markerSession = session;
            this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
          };
          HoverTooltip2.prototype.hide = function(e75) {
            if (!e75 && document.activeElement == this.getElement())
              return;
            if (e75 && e75.target && (e75.type != "keydown" || e75.ctrlKey || e75.metaKey) && this.$element.contains(e75.target))
              return;
            this.lastEvent = null;
            if (this.timeout)
              clearTimeout(this.timeout);
            this.timeout = null;
            this.addMarker(null);
            if (this.isOpen) {
              this.$removeCloseEvents();
              this.getElement().style.display = "none";
              this.isOpen = false;
              popupManager.removePopup(this);
            }
          };
          HoverTooltip2.prototype.$registerCloseEvents = function() {
            window.addEventListener("keydown", this.hide, true);
            window.addEventListener("wheel", this.hide, true);
            window.addEventListener("mousedown", this.hide, true);
          };
          HoverTooltip2.prototype.$removeCloseEvents = function() {
            window.removeEventListener("keydown", this.hide, true);
            window.removeEventListener("wheel", this.hide, true);
            window.removeEventListener("mousedown", this.hide, true);
          };
          HoverTooltip2.prototype.onMouseOut = function(e75) {
            if (this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
            this.lastEvent = null;
            if (!this.isOpen)
              return;
            if (!e75.relatedTarget || this.getElement().contains(e75.relatedTarget))
              return;
            if (e75 && e75.currentTarget.contains(e75.relatedTarget))
              return;
            if (!e75.relatedTarget.classList.contains("ace_content"))
              this.hide();
          };
          return HoverTooltip2;
        }(Tooltip)
      );
      exports2.HoverTooltip = HoverTooltip;
    });
    ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/tooltip", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var dom = require2("../lib/dom");
      var event = require2("../lib/event");
      var Tooltip = require2("../tooltip").Tooltip;
      var nls = require2("../config").nls;
      var GUTTER_TOOLTIP_LEFT_OFFSET = 5;
      var GUTTER_TOOLTIP_TOP_OFFSET = 3;
      exports2.GUTTER_TOOLTIP_LEFT_OFFSET = GUTTER_TOOLTIP_LEFT_OFFSET;
      exports2.GUTTER_TOOLTIP_TOP_OFFSET = GUTTER_TOOLTIP_TOP_OFFSET;
      function GutterHandler(mouseHandler) {
        var editor2 = mouseHandler.editor;
        var gutter = editor2.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor2, true);
        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e75) {
          if (!editor2.isFocused() || e75.getButton() != 0)
            return;
          var gutterRegion = gutter.getRegion(e75);
          if (gutterRegion == "foldWidgets")
            return;
          var row = e75.getDocumentPosition().row;
          var selection = editor2.session.selection;
          if (e75.getShiftKey())
            selection.selectTo(row, 0);
          else {
            if (e75.domEvent.detail == 2) {
              editor2.selectAll();
              return e75.preventDefault();
            }
            mouseHandler.$clickSelection = editor2.selection.getLineRange(row);
          }
          mouseHandler.setState("selectByLines");
          mouseHandler.captureMouse(e75);
          return e75.preventDefault();
        });
        var tooltipTimeout, mouseEvent;
        function showTooltip() {
          var row = mouseEvent.getDocumentPosition().row;
          var maxRow = editor2.session.getLength();
          if (row == maxRow) {
            var screenRow = editor2.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor2.session.documentToScreenRow(pos.row, pos.column))
              return hideTooltip();
          }
          tooltip.showTooltip(row);
          if (!tooltip.isOpen)
            return;
          editor2.on("mousewheel", hideTooltip);
          editor2.on("changeSession", hideTooltip);
          window.addEventListener("keydown", hideTooltip, true);
          if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
          } else {
            var gutterRow = mouseEvent.getGutterRow();
            var gutterCell = gutter.$lines.get(gutterRow);
            if (gutterCell) {
              var gutterElement = gutterCell.element.querySelector(".ace_gutter_annotation");
              var rect = gutterElement.getBoundingClientRect();
              var style = tooltip.getElement().style;
              style.left = rect.right - GUTTER_TOOLTIP_LEFT_OFFSET + "px";
              style.top = rect.bottom - GUTTER_TOOLTIP_TOP_OFFSET + "px";
            } else {
              moveTooltip(mouseEvent);
            }
          }
        }
        function hideTooltip(e75) {
          if (e75 && e75.type === "keydown" && (e75.ctrlKey || e75.metaKey))
            return;
          if (e75 && e75.type === "mouseout" && (!e75.relatedTarget || tooltip.getElement().contains(e75.relatedTarget)))
            return;
          if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
          if (tooltip.isOpen) {
            tooltip.hideTooltip();
            editor2.off("mousewheel", hideTooltip);
            editor2.off("changeSession", hideTooltip);
            window.removeEventListener("keydown", hideTooltip, true);
          }
        }
        function moveTooltip(e75) {
          tooltip.setPosition(e75.x, e75.y);
        }
        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e75) {
          var target2 = e75.domEvent.target || e75.domEvent.srcElement;
          if (dom.hasCssClass(target2, "ace_fold-widget") || dom.hasCssClass(target2, "ace_custom-widget"))
            return hideTooltip();
          if (tooltip.isOpen && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e75);
          mouseEvent = e75;
          if (tooltipTimeout)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
              showTooltip();
          }, 50);
        });
        event.addListener(editor2.renderer.$gutter, "mouseout", function(e75) {
          mouseEvent = null;
          if (!tooltip.isOpen)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip(e75);
          }, 50);
        }, editor2);
      }
      exports2.GutterHandler = GutterHandler;
      var GutterTooltip = (
        /** @class */
        function(_super) {
          __extends(GutterTooltip2, _super);
          function GutterTooltip2(editor2, isHover) {
            if (isHover === void 0) {
              isHover = false;
            }
            var _this = _super.call(this, editor2.container) || this;
            _this.editor = editor2;
            _this.visibleTooltipRow;
            var el = _this.getElement();
            el.setAttribute("role", "tooltip");
            el.style.pointerEvents = "auto";
            if (isHover) {
              _this.onMouseOut = _this.onMouseOut.bind(_this);
              el.addEventListener("mouseout", _this.onMouseOut);
            }
            return _this;
          }
          GutterTooltip2.prototype.onMouseOut = function(e75) {
            if (!this.isOpen)
              return;
            if (!e75.relatedTarget || this.getElement().contains(e75.relatedTarget))
              return;
            if (e75 && e75.currentTarget.contains(e75.relatedTarget))
              return;
            this.hideTooltip();
          };
          GutterTooltip2.prototype.setPosition = function(x, y) {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth;
            var windowHeight = window.innerHeight || document.documentElement.clientHeight;
            var width = this.getWidth();
            var height = this.getHeight();
            x += 15;
            y += 15;
            if (x + width > windowWidth) {
              x -= x + width - windowWidth;
            }
            if (y + height > windowHeight) {
              y -= 20 + height;
            }
            Tooltip.prototype.setPosition.call(this, x, y);
          };
          Object.defineProperty(GutterTooltip2, "annotationLabels", {
            get: function() {
              return {
                error: {
                  singular: nls("gutter-tooltip.aria-label.error.singular", "error"),
                  plural: nls("gutter-tooltip.aria-label.error.plural", "errors")
                },
                security: {
                  singular: nls("gutter-tooltip.aria-label.security.singular", "security finding"),
                  plural: nls("gutter-tooltip.aria-label.security.plural", "security findings")
                },
                warning: {
                  singular: nls("gutter-tooltip.aria-label.warning.singular", "warning"),
                  plural: nls("gutter-tooltip.aria-label.warning.plural", "warnings")
                },
                info: {
                  singular: nls("gutter-tooltip.aria-label.info.singular", "information message"),
                  plural: nls("gutter-tooltip.aria-label.info.plural", "information messages")
                },
                hint: {
                  singular: nls("gutter-tooltip.aria-label.hint.singular", "suggestion"),
                  plural: nls("gutter-tooltip.aria-label.hint.plural", "suggestions")
                }
              };
            },
            enumerable: false,
            configurable: true
          });
          GutterTooltip2.prototype.showTooltip = function(row) {
            var _a;
            var gutter = this.editor.renderer.$gutterLayer;
            var annotationsInRow = gutter.$annotations[row];
            var annotation;
            if (annotationsInRow)
              annotation = {
                displayText: Array.from(annotationsInRow.displayText),
                type: Array.from(annotationsInRow.type)
              };
            else
              annotation = { displayText: [], type: [] };
            var fold2 = gutter.session.getFoldLine(row);
            if (fold2 && gutter.$showFoldedAnnotations) {
              var annotationsInFold = { error: [], security: [], warning: [], info: [], hint: [] };
              var severityRank = { error: 1, security: 2, warning: 3, info: 4, hint: 5 };
              var mostSevereAnnotationTypeInFold;
              for (var i = row + 1; i <= fold2.end.row; i++) {
                if (!gutter.$annotations[i])
                  continue;
                for (var j = 0; j < gutter.$annotations[i].text.length; j++) {
                  var annotationType = gutter.$annotations[i].type[j];
                  annotationsInFold[annotationType].push(gutter.$annotations[i].text[j]);
                  if (!mostSevereAnnotationTypeInFold || severityRank[annotationType] < severityRank[mostSevereAnnotationTypeInFold]) {
                    mostSevereAnnotationTypeInFold = annotationType;
                  }
                }
              }
              if (["error", "security", "warning"].includes(mostSevereAnnotationTypeInFold)) {
                var summaryFoldedAnnotations = "".concat(GutterTooltip2.annotationsToSummaryString(annotationsInFold), " in folded code.");
                annotation.displayText.push(summaryFoldedAnnotations);
                annotation.type.push(mostSevereAnnotationTypeInFold + "_fold");
              }
            }
            if (annotation.displayText.length === 0)
              return this.hideTooltip();
            var annotationMessages = { error: [], security: [], warning: [], info: [], hint: [] };
            var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            for (var i = 0; i < annotation.displayText.length; i++) {
              var lineElement = dom.createElement("span");
              var iconElement = dom.createElement("span");
              (_a = iconElement.classList).add.apply(_a, ["ace_".concat(annotation.type[i]), iconClassName]);
              iconElement.setAttribute("aria-label", "".concat(GutterTooltip2.annotationLabels[annotation.type[i].replace("_fold", "")].singular));
              iconElement.setAttribute("role", "img");
              iconElement.appendChild(dom.createTextNode(" "));
              lineElement.appendChild(iconElement);
              lineElement.appendChild(dom.createTextNode(annotation.displayText[i]));
              lineElement.appendChild(dom.createElement("br"));
              annotationMessages[annotation.type[i].replace("_fold", "")].push(lineElement);
            }
            var tooltipElement = this.getElement();
            dom.removeChildren(tooltipElement);
            annotationMessages.error.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.security.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.warning.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.info.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.hint.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            tooltipElement.setAttribute("aria-live", "polite");
            if (!this.isOpen) {
              this.setTheme(this.editor.renderer.theme);
              this.setClassName("ace_gutter-tooltip");
            }
            this.show();
            this.visibleTooltipRow = row;
            this.editor._signal("showGutterTooltip", this);
          };
          GutterTooltip2.prototype.hideTooltip = function() {
            if (!this.isOpen) {
              return;
            }
            this.$element.removeAttribute("aria-live");
            this.hide();
            this.visibleTooltipRow = void 0;
            this.editor._signal("hideGutterTooltip", this);
          };
          GutterTooltip2.annotationsToSummaryString = function(annotations) {
            var e_1, _a;
            var summary = [];
            var annotationTypes = ["error", "security", "warning", "info", "hint"];
            try {
              for (var annotationTypes_1 = __values(annotationTypes), annotationTypes_1_1 = annotationTypes_1.next(); !annotationTypes_1_1.done; annotationTypes_1_1 = annotationTypes_1.next()) {
                var annotationType = annotationTypes_1_1.value;
                if (!annotations[annotationType].length)
                  continue;
                var label = annotations[annotationType].length === 1 ? GutterTooltip2.annotationLabels[annotationType].singular : GutterTooltip2.annotationLabels[annotationType].plural;
                summary.push("".concat(annotations[annotationType].length, " ").concat(label));
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (annotationTypes_1_1 && !annotationTypes_1_1.done && (_a = annotationTypes_1.return)) _a.call(annotationTypes_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return summary.join(", ");
          };
          return GutterTooltip2;
        }(Tooltip)
      );
      exports2.GutterTooltip = GutterTooltip;
    });
    ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var MouseEvent = (
        /** @class */
        function() {
          function MouseEvent2(domEvent, editor2) {
            this.speed;
            this.wheelX;
            this.wheelY;
            this.domEvent = domEvent;
            this.editor = editor2;
            this.x = this.clientX = domEvent.clientX;
            this.y = this.clientY = domEvent.clientY;
            this.$pos = null;
            this.$inSelection = null;
            this.propagationStopped = false;
            this.defaultPrevented = false;
          }
          MouseEvent2.prototype.stopPropagation = function() {
            event.stopPropagation(this.domEvent);
            this.propagationStopped = true;
          };
          MouseEvent2.prototype.preventDefault = function() {
            event.preventDefault(this.domEvent);
            this.defaultPrevented = true;
          };
          MouseEvent2.prototype.stop = function() {
            this.stopPropagation();
            this.preventDefault();
          };
          MouseEvent2.prototype.getDocumentPosition = function() {
            if (this.$pos)
              return this.$pos;
            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
            return this.$pos;
          };
          MouseEvent2.prototype.getGutterRow = function() {
            var documentRow = this.getDocumentPosition().row;
            var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);
            var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
            return screenRow - screenTopRow;
          };
          MouseEvent2.prototype.inSelection = function() {
            if (this.$inSelection !== null)
              return this.$inSelection;
            var editor2 = this.editor;
            var selectionRange = editor2.getSelectionRange();
            if (selectionRange.isEmpty())
              this.$inSelection = false;
            else {
              var pos = this.getDocumentPosition();
              this.$inSelection = selectionRange.contains(pos.row, pos.column);
            }
            return this.$inSelection;
          };
          MouseEvent2.prototype.getButton = function() {
            return event.getButton(this.domEvent);
          };
          MouseEvent2.prototype.getShiftKey = function() {
            return this.domEvent.shiftKey;
          };
          MouseEvent2.prototype.getAccelKey = function() {
            return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
          };
          return MouseEvent2;
        }()
      );
      exports2.MouseEvent = MouseEvent;
    });
    ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var AUTOSCROLL_DELAY = 200;
      var SCROLL_CURSOR_DELAY = 200;
      var SCROLL_CURSOR_HYSTERESIS = 5;
      function DragdropHandler(mouseHandler) {
        var editor2 = mouseHandler.editor;
        var dragImage = dom.createElement("div");
        dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
        dragImage.textContent = "";
        var exports3 = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
        exports3.forEach(function(x2) {
          mouseHandler[x2] = this[x2];
        }, this);
        editor2.on("mousedown", this.onMouseDown.bind(mouseHandler));
        var mouseTarget = editor2.container;
        var dragSelectionMarker, x, y;
        var timerId, range;
        var dragCursor, counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;
        this.onDragStart = function(e75) {
          if (this.cancelDrag || !mouseTarget.draggable) {
            var self2 = this;
            setTimeout(function() {
              self2.startSelect();
              self2.captureMouse(e75);
            }, 0);
            return e75.preventDefault();
          }
          range = editor2.getSelectionRange();
          var dataTransfer = e75.dataTransfer;
          dataTransfer.effectAllowed = editor2.getReadOnly() ? "copy" : "copyMove";
          editor2.container.appendChild(dragImage);
          dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
          setTimeout(function() {
            editor2.container.removeChild(dragImage);
          });
          dataTransfer.clearData();
          dataTransfer.setData("Text", editor2.session.getTextRange());
          isInternal = true;
          this.setState("drag");
        };
        this.onDragEnd = function(e75) {
          mouseTarget.draggable = false;
          isInternal = false;
          this.setState(null);
          if (!editor2.getReadOnly()) {
            var dropEffect = e75.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
              editor2.session.remove(editor2.getSelectionRange());
            editor2.$resetCursorStyle();
          }
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
        };
        this.onDragEnter = function(e75) {
          if (editor2.getReadOnly() || !canAccept(e75.dataTransfer))
            return;
          x = e75.clientX;
          y = e75.clientY;
          if (!dragSelectionMarker)
            addDragMarker();
          counter++;
          e75.dataTransfer.dropEffect = dragOperation = getDropEffect(e75);
          return event.preventDefault(e75);
        };
        this.onDragOver = function(e75) {
          if (editor2.getReadOnly() || !canAccept(e75.dataTransfer))
            return;
          x = e75.clientX;
          y = e75.clientY;
          if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
          }
          if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;
          e75.dataTransfer.dropEffect = dragOperation = getDropEffect(e75);
          return event.preventDefault(e75);
        };
        this.onDragLeave = function(e75) {
          counter--;
          if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e75);
          }
        };
        this.onDrop = function(e75) {
          if (!dragCursor)
            return;
          var dataTransfer = e75.dataTransfer;
          if (isInternal) {
            switch (dragOperation) {
              case "move":
                if (range.contains(dragCursor.row, dragCursor.column)) {
                  range = {
                    start: dragCursor,
                    end: dragCursor
                  };
                } else {
                  range = editor2.moveText(range, dragCursor);
                }
                break;
              case "copy":
                range = editor2.moveText(range, dragCursor, true);
                break;
            }
          } else {
            var dropData = dataTransfer.getData("Text");
            range = {
              start: dragCursor,
              end: editor2.session.insert(dragCursor, dropData)
            };
            editor2.focus();
            dragOperation = null;
          }
          clearDragMarker();
          return event.preventDefault(e75);
        };
        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor2);
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor2);
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor2);
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor2);
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor2);
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor2);
        function scrollCursorIntoView(cursor, prevCursor) {
          var now = Date.now();
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          var hMovement = !prevCursor || cursor.column != prevCursor.column;
          if (!cursorMovedTime || vMovement || hMovement) {
            editor2.moveCursorToPosition(cursor);
            cursorMovedTime = now;
            cursorPointOnCaretMoved = { x, y };
          } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
              cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
              editor2.renderer.scrollCursorIntoView();
              cursorMovedTime = null;
            }
          }
        }
        function autoScroll(cursor, prevCursor) {
          var now = Date.now();
          var lineHeight = editor2.renderer.layerConfig.lineHeight;
          var characterWidth = editor2.renderer.layerConfig.characterWidth;
          var editorRect = editor2.renderer.scroller.getBoundingClientRect();
          var offsets = {
            x: {
              left: x - editorRect.left,
              right: editorRect.right - x
            },
            y: {
              top: y - editorRect.top,
              bottom: editorRect.bottom - y
            }
          };
          var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
          var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
          var scrollCursor = { row: cursor.row, column: cursor.column };
          if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : 2;
          }
          if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : 1;
          }
          var vScroll = cursor.row != scrollCursor.row;
          var hScroll = cursor.column != scrollCursor.column;
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          if (vScroll || hScroll && !vMovement) {
            if (!autoScrollStartTime)
              autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
              editor2.renderer.scrollCursorIntoView(scrollCursor);
          } else {
            autoScrollStartTime = null;
          }
        }
        function onDragInterval() {
          var prevCursor = dragCursor;
          dragCursor = editor2.renderer.screenToTextCoordinates(x, y);
          scrollCursorIntoView(dragCursor, prevCursor);
          autoScroll(dragCursor, prevCursor);
        }
        function addDragMarker() {
          range = editor2.selection.toOrientedRange();
          dragSelectionMarker = editor2.session.addMarker(range, "ace_selection", editor2.getSelectionStyle());
          editor2.clearSelection();
          if (editor2.isFocused())
            editor2.renderer.$cursorLayer.setBlinking(false);
          clearInterval(timerId);
          onDragInterval();
          timerId = setInterval(onDragInterval, 20);
          counter = 0;
          event.addListener(document, "mousemove", onMouseMove);
        }
        function clearDragMarker() {
          clearInterval(timerId);
          editor2.session.removeMarker(dragSelectionMarker);
          dragSelectionMarker = null;
          editor2.selection.fromOrientedRange(range);
          if (editor2.isFocused() && !isInternal)
            editor2.$resetCursorStyle();
          range = null;
          dragCursor = null;
          counter = 0;
          autoScrollStartTime = null;
          cursorMovedTime = null;
          event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
          if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
              if (onMouseMoveTimer != null && dragSelectionMarker)
                clearDragMarker();
            }, 20);
          }
        }
        function canAccept(dataTransfer) {
          var types = dataTransfer.types;
          return !types || Array.prototype.some.call(types, function(type2) {
            return type2 == "text/plain" || type2 == "Text";
          });
        }
        function getDropEffect(e75) {
          var copyAllowed = ["copy", "copymove", "all", "uninitialized"];
          var moveAllowed = ["move", "copymove", "linkmove", "all", "uninitialized"];
          var copyModifierState = useragent.isMac ? e75.altKey : e75.ctrlKey;
          var effectAllowed = "uninitialized";
          try {
            effectAllowed = e75.dataTransfer.effectAllowed.toLowerCase();
          } catch (e76) {
          }
          var dropEffect = "none";
          if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
          else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          return dropEffect;
        }
      }
      (function() {
        this.dragWait = function() {
          var interval = Date.now() - this.mousedownEvent.time;
          if (interval > this.editor.getDragDelay())
            this.startDrag();
        };
        this.dragWaitEnd = function() {
          var target2 = this.editor.container;
          target2.draggable = false;
          this.startSelect(this.mousedownEvent.getDocumentPosition());
          this.selectEnd();
        };
        this.dragReadyEnd = function(e75) {
          this.editor.$resetCursorStyle();
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
          this.dragWaitEnd();
        };
        this.startDrag = function() {
          this.cancelDrag = false;
          var editor2 = this.editor;
          var target2 = editor2.container;
          target2.draggable = true;
          editor2.renderer.$cursorLayer.setBlinking(false);
          editor2.setStyle("ace_dragging");
          var cursorStyle = useragent.isWin ? "default" : "move";
          editor2.renderer.setCursorStyle(cursorStyle);
          this.setState("dragReady");
        };
        this.onMouseDrag = function(e75) {
          var target2 = this.editor.container;
          if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
              target2.dragDrop();
          }
          if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
              target2.draggable = false;
              this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
          }
        };
        this.onMouseDown = function(e75) {
          if (!this.$dragEnabled)
            return;
          this.mousedownEvent = e75;
          var editor2 = this.editor;
          var inSelection = e75.inSelection();
          var button = e75.getButton();
          var clickCount = e75.domEvent.detail || 1;
          if (clickCount === 1 && button === 0 && inSelection) {
            if (e75.editor.inMultiSelectMode && (e75.getAccelKey() || e75.getShiftKey()))
              return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e75.domEvent.target || e75.domEvent.srcElement;
            if ("unselectable" in eventTarget)
              eventTarget.unselectable = "on";
            if (editor2.getDragDelay()) {
              if (useragent.isWebKit) {
                this.cancelDrag = true;
                var mouseTarget = editor2.container;
                mouseTarget.draggable = true;
              }
              this.setState("dragWait");
            } else {
              this.startDrag();
            }
            this.captureMouse(e75, this.onMouseDrag.bind(this));
            e75.defaultPrevented = true;
          }
        };
      }).call(DragdropHandler.prototype);
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      exports2.DragdropHandler = DragdropHandler;
    });
    ace.define("ace/mouse/touch_handler", ["require", "exports", "module", "ace/mouse/mouse_event", "ace/lib/event", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var MouseEvent = require2("./mouse_event").MouseEvent;
      var event = require2("../lib/event");
      var dom = require2("../lib/dom");
      exports2.addTouchListeners = function(el, editor2) {
        var mode = "scroll";
        var startX;
        var startY;
        var touchStartT;
        var lastT;
        var longTouchTimer;
        var animationTimer;
        var animationSteps = 0;
        var pos;
        var clickCount = 0;
        var vX = 0;
        var vY = 0;
        var pressed;
        var contextMenu;
        function createContextMenu() {
          var clipboard = window.navigator && window.navigator.clipboard;
          var isOpen = false;
          var updateMenu = function() {
            var selected = editor2.getCopyText();
            var hasUndo = editor2.session.getUndoManager().hasUndo();
            contextMenu.replaceChild(dom.buildDom(isOpen ? [
              "span",
              !selected && canExecuteCommand("selectall") && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
              selected && canExecuteCommand("copy") && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
              selected && canExecuteCommand("cut") && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
              clipboard && canExecuteCommand("paste") && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
              hasUndo && canExecuteCommand("undo") && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
              canExecuteCommand("find") && ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
              canExecuteCommand("openCommandPalette") && ["span", { class: "ace_mobile-button", action: "openCommandPalette" }, "Palette"]
            ] : ["span"]), contextMenu.firstChild);
          };
          var canExecuteCommand = function(cmd) {
            return editor2.commands.canExecute(cmd, editor2);
          };
          var handleClick = function(e75) {
            var action = e75.target.getAttribute("action");
            if (action == "more" || !isOpen) {
              isOpen = !isOpen;
              return updateMenu();
            }
            if (action == "paste") {
              clipboard.readText().then(function(text) {
                editor2.execCommand(action, text);
              });
            } else if (action) {
              if (action == "cut" || action == "copy") {
                if (clipboard)
                  clipboard.writeText(editor2.getCopyText());
                else
                  document.execCommand("copy");
              }
              editor2.execCommand(action);
            }
            contextMenu.firstChild.style.display = "none";
            isOpen = false;
            if (action != "openCommandPalette")
              editor2.focus();
          };
          contextMenu = dom.buildDom([
            "div",
            {
              class: "ace_mobile-menu",
              ontouchstart: function(e75) {
                mode = "menu";
                e75.stopPropagation();
                e75.preventDefault();
                editor2.textInput.focus();
              },
              ontouchend: function(e75) {
                e75.stopPropagation();
                e75.preventDefault();
                handleClick(e75);
              },
              onclick: handleClick
            },
            ["span"],
            ["span", { class: "ace_mobile-button", action: "more" }, "..."]
          ], editor2.container);
        }
        function showContextMenu() {
          if (!editor2.getOption("enableMobileMenu")) {
            if (contextMenu) {
              hideContextMenu();
            }
            return;
          }
          if (!contextMenu)
            createContextMenu();
          var cursor = editor2.selection.cursor;
          var pagePos = editor2.renderer.textToScreenCoordinates(cursor.row, cursor.column);
          var leftOffset = editor2.renderer.textToScreenCoordinates(0, 0).pageX;
          var scrollLeft = editor2.renderer.scrollLeft;
          var rect = editor2.container.getBoundingClientRect();
          contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
          if (pagePos.pageX - rect.left < rect.width - 70) {
            contextMenu.style.left = "";
            contextMenu.style.right = "10px";
          } else {
            contextMenu.style.right = "";
            contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
          }
          contextMenu.style.display = "";
          contextMenu.firstChild.style.display = "none";
          editor2.on("input", hideContextMenu);
        }
        function hideContextMenu(e75) {
          if (contextMenu)
            contextMenu.style.display = "none";
          editor2.off("input", hideContextMenu);
        }
        function handleLongTap() {
          longTouchTimer = null;
          clearTimeout(longTouchTimer);
          var range = editor2.selection.getRange();
          var inSelection = range.contains(pos.row, pos.column);
          if (range.isEmpty() || !inSelection) {
            editor2.selection.moveToPosition(pos);
            editor2.selection.selectWord();
          }
          mode = "wait";
          showContextMenu();
        }
        function switchToSelectionMode() {
          longTouchTimer = null;
          clearTimeout(longTouchTimer);
          editor2.selection.moveToPosition(pos);
          var range = clickCount >= 2 ? editor2.selection.getLineRange(pos.row) : editor2.session.getBracketRange(pos);
          if (range && !range.isEmpty()) {
            editor2.selection.setRange(range);
          } else {
            editor2.selection.selectWord();
          }
          mode = "wait";
        }
        event.addListener(el, "contextmenu", function(e75) {
          if (!pressed)
            return;
          var textarea = editor2.textInput.getElement();
          textarea.focus();
        }, editor2);
        event.addListener(el, "touchstart", function(e75) {
          var touches = e75.touches;
          if (longTouchTimer || touches.length > 1) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
            touchStartT = -1;
            mode = "zoom";
            return;
          }
          pressed = editor2.$mouseHandler.isMousePressed = true;
          var h = editor2.renderer.layerConfig.lineHeight;
          var w = editor2.renderer.layerConfig.lineHeight;
          var t2 = e75.timeStamp;
          lastT = t2;
          var touchObj = touches[0];
          var x = touchObj.clientX;
          var y = touchObj.clientY;
          if (Math.abs(startX - x) + Math.abs(startY - y) > h)
            touchStartT = -1;
          startX = e75.clientX = x;
          startY = e75.clientY = y;
          vX = vY = 0;
          var ev = new MouseEvent(e75, editor2);
          pos = ev.getDocumentPosition();
          if (t2 - touchStartT < 500 && touches.length == 1 && !animationSteps) {
            clickCount++;
            e75.preventDefault();
            e75.button = 0;
            switchToSelectionMode();
          } else {
            clickCount = 0;
            var cursor = editor2.selection.cursor;
            var anchor = editor2.selection.isEmpty() ? cursor : editor2.selection.anchor;
            var cursorPos = editor2.renderer.$cursorLayer.getPixelPosition(cursor, true);
            var anchorPos = editor2.renderer.$cursorLayer.getPixelPosition(anchor, true);
            var rect = editor2.renderer.scroller.getBoundingClientRect();
            var offsetTop = editor2.renderer.layerConfig.offset;
            var offsetLeft = editor2.renderer.scrollLeft;
            var weightedDistance = function(x2, y2) {
              x2 = x2 / w;
              y2 = y2 / h - 0.75;
              return x2 * x2 + y2 * y2;
            };
            if (e75.clientX < rect.left) {
              mode = "zoom";
              return;
            }
            var diff1 = weightedDistance(e75.clientX - rect.left - cursorPos.left + offsetLeft, e75.clientY - rect.top - cursorPos.top + offsetTop);
            var diff2 = weightedDistance(e75.clientX - rect.left - anchorPos.left + offsetLeft, e75.clientY - rect.top - anchorPos.top + offsetTop);
            if (diff1 < 3.5 && diff2 < 3.5)
              mode = diff1 > diff2 ? "cursor" : "anchor";
            if (diff2 < 3.5)
              mode = "anchor";
            else if (diff1 < 3.5)
              mode = "cursor";
            else
              mode = "scroll";
            longTouchTimer = setTimeout(handleLongTap, 450);
          }
          touchStartT = t2;
        }, editor2);
        event.addListener(el, "touchend", function(e75) {
          pressed = editor2.$mouseHandler.isMousePressed = false;
          if (animationTimer)
            clearInterval(animationTimer);
          if (mode == "zoom") {
            mode = "";
            animationSteps = 0;
          } else if (longTouchTimer) {
            editor2.selection.moveToPosition(pos);
            animationSteps = 0;
            showContextMenu();
          } else if (mode == "scroll") {
            animate();
            hideContextMenu();
          } else {
            showContextMenu();
          }
          clearTimeout(longTouchTimer);
          longTouchTimer = null;
        }, editor2);
        event.addListener(el, "touchmove", function(e75) {
          if (longTouchTimer) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
          }
          var touches = e75.touches;
          if (touches.length > 1 || mode == "zoom")
            return;
          var touchObj = touches[0];
          var wheelX = startX - touchObj.clientX;
          var wheelY = startY - touchObj.clientY;
          if (mode == "wait") {
            if (wheelX * wheelX + wheelY * wheelY > 4)
              mode = "cursor";
            else
              return e75.preventDefault();
          }
          startX = touchObj.clientX;
          startY = touchObj.clientY;
          e75.clientX = touchObj.clientX;
          e75.clientY = touchObj.clientY;
          var t2 = e75.timeStamp;
          var dt = t2 - lastT;
          lastT = t2;
          if (mode == "scroll") {
            var mouseEvent = new MouseEvent(e75, editor2);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = wheelX;
            mouseEvent.wheelY = wheelY;
            if (10 * Math.abs(wheelX) < Math.abs(wheelY))
              wheelX = 0;
            if (10 * Math.abs(wheelY) < Math.abs(wheelX))
              wheelY = 0;
            if (dt != 0) {
              vX = wheelX / dt;
              vY = wheelY / dt;
            }
            editor2._emit("mousewheel", mouseEvent);
            if (!mouseEvent.propagationStopped) {
              vX = vY = 0;
            }
          } else {
            var ev = new MouseEvent(e75, editor2);
            var pos2 = ev.getDocumentPosition();
            if (mode == "cursor")
              editor2.selection.moveCursorToPosition(pos2);
            else if (mode == "anchor")
              editor2.selection.setSelectionAnchor(pos2.row, pos2.column);
            editor2.renderer.scrollCursorIntoView(pos2);
            e75.preventDefault();
          }
        }, editor2);
        function animate() {
          animationSteps += 60;
          animationTimer = setInterval(function() {
            if (animationSteps-- <= 0) {
              clearInterval(animationTimer);
              animationTimer = null;
            }
            if (Math.abs(vX) < 0.01)
              vX = 0;
            if (Math.abs(vY) < 0.01)
              vY = 0;
            if (animationSteps < 20)
              vX = 0.9 * vX;
            if (animationSteps < 20)
              vY = 0.9 * vY;
            var oldScrollTop = editor2.session.getScrollTop();
            editor2.renderer.scrollBy(10 * vX, 10 * vY);
            if (oldScrollTop == editor2.session.getScrollTop())
              animationSteps = 0;
          }, 10);
        }
      };
    });
    ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/mouse/touch_handler", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var DefaultHandlers = require2("./default_handlers").DefaultHandlers;
      var DefaultGutterHandler = require2("./default_gutter_handler").GutterHandler;
      var MouseEvent = require2("./mouse_event").MouseEvent;
      var DragdropHandler = require2("./dragdrop_handler").DragdropHandler;
      var addTouchListeners = require2("./touch_handler").addTouchListeners;
      var config2 = require2("../config");
      var MouseHandler = (
        /** @class */
        function() {
          function MouseHandler2(editor2) {
            this.$dragDelay;
            this.$dragEnabled;
            this.$mouseMoved;
            this.mouseEvent;
            this.$focusTimeout;
            var _self = this;
            this.editor = editor2;
            new DefaultHandlers(this);
            new DefaultGutterHandler(this);
            new DragdropHandler(this);
            var focusEditor = function(e75) {
              var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor2.isFocused() && document.activeElement == (editor2.textInput && editor2.textInput.getElement());
              if (windowBlurred)
                window.focus();
              editor2.focus();
              setTimeout(function() {
                if (!editor2.isFocused())
                  editor2.focus();
              });
            };
            var mouseTarget = editor2.renderer.getMouseEventTarget();
            event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor2);
            event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor2);
            event.addMultiMouseDownListener([
              mouseTarget,
              editor2.renderer.scrollBarV && editor2.renderer.scrollBarV.inner,
              editor2.renderer.scrollBarH && editor2.renderer.scrollBarH.inner,
              editor2.textInput && editor2.textInput.getElement()
            ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor2);
            event.addMouseWheelListener(editor2.container, this.onMouseWheel.bind(this, "mousewheel"), editor2);
            addTouchListeners(editor2.container, editor2);
            var gutterEl = editor2.renderer.$gutter;
            event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor2);
            event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor2);
            event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor2);
            event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor2);
            event.addListener(mouseTarget, "mousedown", focusEditor, editor2);
            event.addListener(gutterEl, "mousedown", focusEditor, editor2);
            if (useragent.isIE && editor2.renderer.scrollBarV) {
              event.addListener(editor2.renderer.scrollBarV.element, "mousedown", focusEditor, editor2);
              event.addListener(editor2.renderer.scrollBarH.element, "mousedown", focusEditor, editor2);
            }
            editor2.on(
              "mousemove",
              function(e75) {
                if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                  return;
                var character = editor2.renderer.screenToTextCoordinates(e75.x, e75.y);
                var range = editor2.session.selection.getRange();
                var renderer = editor2.renderer;
                if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                  renderer.setCursorStyle("default");
                } else {
                  renderer.setCursorStyle("");
                }
              },
              //@ts-expect-error TODO: seems mistyping - should be boolean
              editor2
            );
          }
          MouseHandler2.prototype.onMouseEvent = function(name, e75) {
            if (!this.editor.session)
              return;
            this.editor._emit(name, new MouseEvent(e75, this.editor));
          };
          MouseHandler2.prototype.onMouseMove = function(name, e75) {
            var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!listeners || !listeners.length)
              return;
            this.editor._emit(name, new MouseEvent(e75, this.editor));
          };
          MouseHandler2.prototype.onMouseWheel = function(name, e75) {
            var mouseEvent = new MouseEvent(e75, this.editor);
            mouseEvent.speed = this.$scrollSpeed * 2;
            mouseEvent.wheelX = e75.wheelX;
            mouseEvent.wheelY = e75.wheelY;
            this.editor._emit(name, mouseEvent);
          };
          MouseHandler2.prototype.setState = function(state) {
            this.state = state;
          };
          MouseHandler2.prototype.captureMouse = function(ev, mouseMoveHandler) {
            this.x = ev.x;
            this.y = ev.y;
            this.isMousePressed = true;
            var editor2 = this.editor;
            var renderer = this.editor.renderer;
            renderer.$isMousePressed = true;
            var self2 = this;
            var onMouseMove = function(e75) {
              if (!e75)
                return;
              if (useragent.isWebKit && !e75.which && self2.releaseMouse)
                return self2.releaseMouse();
              self2.x = e75.clientX;
              self2.y = e75.clientY;
              mouseMoveHandler && mouseMoveHandler(e75);
              self2.mouseEvent = new MouseEvent(e75, self2.editor);
              self2.$mouseMoved = true;
            };
            var onCaptureEnd = function(e75) {
              editor2.off("beforeEndOperation", onOperationEnd);
              clearInterval(timerId);
              if (editor2.session)
                onCaptureInterval();
              self2[self2.state + "End"] && self2[self2.state + "End"](e75);
              self2.state = "";
              self2.isMousePressed = renderer.$isMousePressed = false;
              if (renderer.$keepTextAreaAtCursor)
                renderer.$moveTextAreaToCursor();
              self2.$onCaptureMouseMove = self2.releaseMouse = null;
              e75 && self2.onMouseEvent("mouseup", e75);
              editor2.endOperation();
            };
            var onCaptureInterval = function() {
              self2[self2.state] && self2[self2.state]();
              self2.$mouseMoved = false;
            };
            if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
              return setTimeout(function() {
                onCaptureEnd(ev);
              });
            }
            var onOperationEnd = function(e75) {
              if (!self2.releaseMouse)
                return;
              if (editor2.curOp.command.name && editor2.curOp.selectionChanged) {
                self2[self2.state + "End"] && self2[self2.state + "End"]();
                self2.state = "";
                self2.releaseMouse();
              }
            };
            editor2.on("beforeEndOperation", onOperationEnd);
            editor2.startOperation({ command: { name: "mouse" } });
            self2.$onCaptureMouseMove = onMouseMove;
            self2.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
            var timerId = setInterval(onCaptureInterval, 20);
          };
          MouseHandler2.prototype.cancelContextMenu = function() {
            var stop = function(e75) {
              if (e75 && e75.domEvent && e75.domEvent.type != "contextmenu")
                return;
              this.editor.off("nativecontextmenu", stop);
              if (e75 && e75.domEvent)
                event.stopEvent(e75.domEvent);
            }.bind(this);
            setTimeout(stop, 10);
            this.editor.on("nativecontextmenu", stop);
          };
          MouseHandler2.prototype.destroy = function() {
            if (this.releaseMouse)
              this.releaseMouse();
          };
          return MouseHandler2;
        }()
      );
      MouseHandler.prototype.releaseMouse = null;
      config2.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: { initialValue: 2 },
        dragDelay: { initialValue: useragent.isMac ? 150 : 0 },
        dragEnabled: { initialValue: true },
        focusTimeout: { initialValue: 0 },
        tooltipFollowsMouse: { initialValue: true }
      });
      exports2.MouseHandler = MouseHandler;
    });
    ace.define("ace/mouse/fold_handler", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var FoldHandler = (
        /** @class */
        /* @__PURE__ */ function() {
          function FoldHandler2(editor2) {
            editor2.on("click", function(e75) {
              var position2 = e75.getDocumentPosition();
              var session = editor2.session;
              var fold2 = session.getFoldAt(position2.row, position2.column, 1);
              if (fold2) {
                if (e75.getAccelKey())
                  session.removeFold(fold2);
                else
                  session.expandFold(fold2);
                e75.stop();
              }
              var target2 = e75.domEvent && e75.domEvent.target;
              if (target2 && dom.hasCssClass(target2, "ace_inline_button")) {
                if (dom.hasCssClass(target2, "ace_toggle_wrap")) {
                  session.setOption("wrap", !session.getUseWrapMode());
                  editor2.renderer.scrollCursorIntoView();
                }
              }
            });
            editor2.on("gutterclick", function(e75) {
              var gutterRegion = editor2.renderer.$gutterLayer.getRegion(e75);
              if (gutterRegion == "foldWidgets") {
                var row = e75.getDocumentPosition().row;
                var session = editor2.session;
                if (session.foldWidgets && session.foldWidgets[row])
                  editor2.session.onFoldWidgetClick(row, e75);
                if (!editor2.isFocused())
                  editor2.focus();
                e75.stop();
              }
            });
            editor2.on("gutterdblclick", function(e75) {
              var gutterRegion = editor2.renderer.$gutterLayer.getRegion(e75);
              if (gutterRegion == "foldWidgets") {
                var row = e75.getDocumentPosition().row;
                var session = editor2.session;
                var data = session.getParentFoldRangeData(row, true);
                var range = data.range || data.firstRange;
                if (range) {
                  row = range.start.row;
                  var fold2 = session.getFoldAt(row, session.getLine(row).length, 1);
                  if (fold2) {
                    session.removeFold(fold2);
                  } else {
                    session.addFold("...", range);
                    editor2.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                  }
                }
                e75.stop();
              }
            });
          }
          return FoldHandler2;
        }()
      );
      exports2.FoldHandler = FoldHandler;
    });
    ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(require2, exports2, module2) {
      "use strict";
      var keyUtil = require2("../lib/keys");
      var event = require2("../lib/event");
      var KeyBinding = (
        /** @class */
        function() {
          function KeyBinding2(editor2) {
            this.$editor = editor2;
            this.$data = { editor: editor2 };
            this.$handlers = [];
            this.setDefaultHandler(editor2.commands);
          }
          KeyBinding2.prototype.setDefaultHandler = function(kb) {
            this.removeKeyboardHandler(this.$defaultHandler);
            this.$defaultHandler = kb;
            this.addKeyboardHandler(kb, 0);
          };
          KeyBinding2.prototype.setKeyboardHandler = function(kb) {
            var h = this.$handlers;
            if (h[h.length - 1] == kb)
              return;
            while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
              this.removeKeyboardHandler(h[h.length - 1]);
            this.addKeyboardHandler(kb, 1);
          };
          KeyBinding2.prototype.addKeyboardHandler = function(kb, pos) {
            if (!kb)
              return;
            if (typeof kb == "function" && !kb.handleKeyboard)
              kb.handleKeyboard = kb;
            var i = this.$handlers.indexOf(kb);
            if (i != -1)
              this.$handlers.splice(i, 1);
            if (pos == void 0)
              this.$handlers.push(kb);
            else
              this.$handlers.splice(pos, 0, kb);
            if (i == -1 && kb.attach)
              kb.attach(this.$editor);
          };
          KeyBinding2.prototype.removeKeyboardHandler = function(kb) {
            var i = this.$handlers.indexOf(kb);
            if (i == -1)
              return false;
            this.$handlers.splice(i, 1);
            kb.detach && kb.detach(this.$editor);
            return true;
          };
          KeyBinding2.prototype.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
          };
          KeyBinding2.prototype.getStatusText = function() {
            var data = this.$data;
            var editor2 = data.editor;
            return this.$handlers.map(function(h) {
              return h.getStatusText && h.getStatusText(editor2, data) || "";
            }).filter(Boolean).join(" ");
          };
          KeyBinding2.prototype.$callKeyboardHandlers = function(hashId, keyString, keyCode, e75) {
            var toExecute;
            var success = false;
            var commands = this.$editor.commands;
            for (var i = this.$handlers.length; i--; ) {
              toExecute = this.$handlers[i].handleKeyboard(
                this.$data,
                hashId,
                keyString,
                keyCode,
                e75
              );
              if (!toExecute || !toExecute.command)
                continue;
              if (toExecute.command == "null") {
                success = true;
              } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e75);
              }
              if (success && e75 && hashId != -1 && toExecute["passEvent"] != true && toExecute.command["passEvent"] != true) {
                event.stopEvent(e75);
              }
              if (success)
                break;
            }
            if (!success && hashId == -1) {
              toExecute = { command: "insertstring" };
              success = commands.exec("insertstring", this.$editor, keyString);
            }
            if (success && this.$editor._signal)
              this.$editor._signal("keyboardActivity", toExecute);
            return success;
          };
          KeyBinding2.prototype.onCommandKey = function(e75, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            return this.$callKeyboardHandlers(hashId, keyString, keyCode, e75);
          };
          KeyBinding2.prototype.onTextInput = function(text) {
            return this.$callKeyboardHandlers(-1, text);
          };
          return KeyBinding2;
        }()
      );
      exports2.KeyBinding = KeyBinding;
    });
    ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var ArabicAlefBetIntervalsBegine = ["", ""];
      var ArabicAlefBetIntervalsEnd = ["", ""];
      var dir = 0, hiLevel = 0;
      var lastArabic = false, hasUBAT_AL = false, hasUBAT_B = false, hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;
      var impTab_LTR = [
        [0, 3, 0, 1, 0, 0, 0],
        [0, 3, 0, 1, 2, 2, 0],
        [0, 3, 0, 17, 2, 0, 1],
        [0, 3, 5, 5, 4, 1, 0],
        [0, 3, 21, 21, 4, 0, 1],
        [0, 3, 5, 5, 4, 2, 0]
      ];
      var impTab_RTL = [
        [2, 0, 1, 1, 0, 1, 0],
        [2, 0, 1, 1, 0, 2, 0],
        [2, 0, 2, 1, 3, 2, 0],
        [2, 0, 2, 33, 3, 1, 1]
      ];
      var LTR = 0, RTL = 1;
      var L = 0;
      var R = 1;
      var EN = 2;
      var AN = 3;
      var ON = 4;
      var B = 5;
      var S = 6;
      var AL = 7;
      var WS = 8;
      var CS = 9;
      var ES = 10;
      var ET = 11;
      var NSM = 12;
      var LRE = 13;
      var RLE = 14;
      var PDF = 15;
      var LRO = 16;
      var RLO = 17;
      var BN2 = 18;
      var UnicodeTBL00 = [
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        S,
        B,
        S,
        WS,
        B,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        B,
        B,
        B,
        S,
        WS,
        ON,
        ON,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ES,
        CS,
        ES,
        CS,
        CS,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        ON,
        ON,
        ON,
        ON,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        B,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        BN2,
        CS,
        ON,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        L,
        ON,
        ON,
        BN2,
        ON,
        ON,
        ET,
        ET,
        EN,
        EN,
        ON,
        L,
        ON,
        ON,
        ON,
        EN,
        L,
        ON,
        ON,
        ON,
        ON,
        ON
      ];
      var UnicodeTBL20 = [
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        BN2,
        BN2,
        BN2,
        L,
        R,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS,
        B,
        LRE,
        RLE,
        PDF,
        LRO,
        RLO,
        CS,
        ET,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS
      ];
      function _computeLevels(chars, levels, len, charTypes) {
        var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
        if (!charTypes) {
          for (i = 0, charTypes = []; i < len; i++) {
            charTypes[i] = _getCharacterType(chars[i]);
          }
        }
        hiLevel = dir;
        lastArabic = false;
        hasUBAT_AL = false;
        hasUBAT_B = false;
        hasUBAT_S = false;
        for (ix = 0; ix < len; ix++) {
          prevState = newState;
          classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
          newState = impTab[prevState][newClass];
          action = newState & 240;
          newState &= 15;
          levels[ix] = newLevel = impTab[newState][5];
          if (action > 0) {
            if (action == 16) {
              for (i = condPos; i < ix; i++) {
                levels[i] = 1;
              }
              condPos = -1;
            } else {
              condPos = -1;
            }
          }
          cond = impTab[newState][6];
          if (cond) {
            if (condPos == -1) {
              condPos = ix;
            }
          } else {
            if (condPos > -1) {
              for (i = condPos; i < ix; i++) {
                levels[i] = newLevel;
              }
              condPos = -1;
            }
          }
          if (charTypes[ix] == B) {
            levels[ix] = 0;
          }
          hiLevel |= newLevel;
        }
        if (hasUBAT_S) {
          for (i = 0; i < len; i++) {
            if (charTypes[i] == S) {
              levels[i] = dir;
              for (var j = i - 1; j >= 0; j--) {
                if (charTypes[j] == WS) {
                  levels[j] = dir;
                } else {
                  break;
                }
              }
            }
          }
        }
      }
      function _invertLevel(lev, levels, _array) {
        if (hiLevel < lev) {
          return;
        }
        if (lev == 1 && dir == RTL && !hasUBAT_B) {
          _array.reverse();
          return;
        }
        var len = _array.length, start = 0, end, lo, hi, tmp;
        while (start < len) {
          if (levels[start] >= lev) {
            end = start + 1;
            while (end < len && levels[end] >= lev) {
              end++;
            }
            for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {
              tmp = _array[lo];
              _array[lo] = _array[hi];
              _array[hi] = tmp;
            }
            start = end;
          }
          start++;
        }
      }
      function _getCharClass(chars, types, classes, ix) {
        var cType = types[ix], wType, nType, len, i;
        switch (cType) {
          case L:
          case R:
            lastArabic = false;
          case ON:
          case AN:
            return cType;
          case EN:
            return lastArabic ? AN : EN;
          case AL:
            lastArabic = true;
            hasUBAT_AL = true;
            return R;
          case WS:
            return ON;
          case CS:
            if (ix < 1 || ix + 1 >= types.length || (wType = classes[ix - 1]) != EN && wType != AN || (nType = types[ix + 1]) != EN && nType != AN) {
              return ON;
            }
            if (lastArabic) {
              nType = AN;
            }
            return nType == wType ? nType : ON;
          case ES:
            wType = ix > 0 ? classes[ix - 1] : B;
            if (wType == EN && ix + 1 < types.length && types[ix + 1] == EN) {
              return EN;
            }
            return ON;
          case ET:
            if (ix > 0 && classes[ix - 1] == EN) {
              return EN;
            }
            if (lastArabic) {
              return ON;
            }
            i = ix + 1;
            len = types.length;
            while (i < len && types[i] == ET) {
              i++;
            }
            if (i < len && types[i] == EN) {
              return EN;
            }
            return ON;
          case NSM:
            len = types.length;
            i = ix + 1;
            while (i < len && types[i] == NSM) {
              i++;
            }
            if (i < len) {
              var c = chars[ix], rtlCandidate = c >= 1425 && c <= 2303 || c == 64286;
              wType = types[i];
              if (rtlCandidate && (wType == R || wType == AL)) {
                return R;
              }
            }
            if (ix < 1 || (wType = types[ix - 1]) == B) {
              return ON;
            }
            return classes[ix - 1];
          case B:
            lastArabic = false;
            hasUBAT_B = true;
            return dir;
          case S:
            hasUBAT_S = true;
            return ON;
          case LRE:
          case RLE:
          case LRO:
          case RLO:
          case PDF:
            lastArabic = false;
          case BN2:
            return ON;
        }
      }
      function _getCharacterType(ch) {
        var uc = ch.charCodeAt(0), hi = uc >> 8;
        if (hi == 0) {
          return uc > 191 ? L : UnicodeTBL00[uc];
        } else if (hi == 5) {
          return /[\u0591-\u05f4]/.test(ch) ? R : L;
        } else if (hi == 6) {
          if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
            return NSM;
          else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
            return AN;
          else if (uc == 1642)
            return ET;
          else if (/[\u06f0-\u06f9]/.test(ch))
            return EN;
          else
            return AL;
        } else if (hi == 32 && uc <= 8287) {
          return UnicodeTBL20[uc & 255];
        } else if (hi == 254) {
          return uc >= 65136 ? AL : ON;
        }
        return ON;
      }
      function _isArabicDiacritics(ch) {
        return ch >= "" && ch <= "";
      }
      exports2.L = L;
      exports2.R = R;
      exports2.EN = EN;
      exports2.ON_R = 3;
      exports2.AN = 4;
      exports2.R_H = 5;
      exports2.B = 6;
      exports2.RLE = 7;
      exports2.DOT = "";
      exports2.doBidiReorder = function(text, textCharTypes, isRtl) {
        if (text.length < 2)
          return {};
        var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
        dir = isRtl ? RTL : LTR;
        _computeLevels(chars, levels, chars.length, textCharTypes);
        for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)
          ;
        _invertLevel(2, levels, logicalFromVisual);
        _invertLevel(1, levels, logicalFromVisual);
        for (var i = 0; i < logicalFromVisual.length - 1; i++) {
          if (textCharTypes[i] === AN) {
            levels[i] = exports2.AN;
          } else if (levels[i] === R && (textCharTypes[i] > AL && textCharTypes[i] < LRE || textCharTypes[i] === ON || textCharTypes[i] === BN2)) {
            levels[i] = exports2.ON_R;
          } else if (i > 0 && chars[i - 1] === "" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
            levels[i - 1] = levels[i] = exports2.R_H;
            i++;
          }
        }
        if (chars[chars.length - 1] === exports2.DOT)
          levels[chars.length - 1] = exports2.B;
        if (chars[0] === "")
          levels[0] = exports2.RLE;
        for (var i = 0; i < logicalFromVisual.length; i++) {
          bidiLevels[i] = levels[logicalFromVisual[i]];
        }
        return { "logicalFromVisual": logicalFromVisual, "bidiLevels": bidiLevels };
      };
      exports2.hasBidiCharacters = function(text, textCharTypes) {
        var ret = false;
        for (var i = 0; i < text.length; i++) {
          textCharTypes[i] = _getCharacterType(text.charAt(i));
          if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
            ret = true;
        }
        return ret;
      };
      exports2.getVisualFromLogicalIdx = function(logIdx, rowMap) {
        for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
          if (rowMap.logicalFromVisual[i] == logIdx)
            return i;
        }
        return 0;
      };
    });
    ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang"], function(require2, exports2, module2) {
      "use strict";
      var bidiUtil = require2("./lib/bidiutil");
      var lang = require2("./lib/lang");
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
      var BidiHandler = (
        /** @class */
        function() {
          function BidiHandler2(session) {
            this.session = session;
            this.bidiMap = {};
            this.currentRow = null;
            this.bidiUtil = bidiUtil;
            this.charWidths = [];
            this.EOL = "";
            this.showInvisibles = true;
            this.isRtlDir = false;
            this.$isRtl = false;
            this.line = "";
            this.wrapIndent = 0;
            this.EOF = "";
            this.RLE = "";
            this.contentWidth = 0;
            this.fontMetrics = null;
            this.rtlLineOffset = 0;
            this.wrapOffset = 0;
            this.isMoveLeftOperation = false;
            this.seenBidi = bidiRE.test(session.getValue());
          }
          BidiHandler2.prototype.isBidiRow = function(screenRow, docRow, splitIndex) {
            if (!this.seenBidi)
              return false;
            if (screenRow !== this.currentRow) {
              this.currentRow = screenRow;
              this.updateRowLine(docRow, splitIndex);
              this.updateBidiMap();
            }
            return this.bidiMap.bidiLevels;
          };
          BidiHandler2.prototype.onChange = function(delta) {
            if (!this.seenBidi) {
              if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
              }
            } else {
              this.currentRow = null;
            }
          };
          BidiHandler2.prototype.getDocumentRow = function() {
            var docRow = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              if (index >= 0)
                docRow = this.session.$docRowCache[index];
            }
            return docRow;
          };
          BidiHandler2.prototype.getSplitIndex = function() {
            var splitIndex = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                  break;
                prevIndex = currentIndex;
                splitIndex++;
              }
            } else {
              splitIndex = this.currentRow;
            }
            return splitIndex;
          };
          BidiHandler2.prototype.updateRowLine = function(docRow, splitIndex) {
            if (docRow === void 0)
              docRow = this.getDocumentRow();
            var isLastRow = docRow === this.session.getLength() - 1, endOfLine = isLastRow ? this.EOF : this.EOL;
            this.wrapIndent = 0;
            this.line = this.session.getLine(docRow);
            this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
            if (this.session.$useWrapMode) {
              var splits = this.session.$wrapData[docRow];
              if (splits) {
                if (splitIndex === void 0)
                  splitIndex = this.getSplitIndex();
                if (splitIndex > 0 && splits.length) {
                  this.wrapIndent = splits.indent;
                  this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                  this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splitIndex]) : this.line.substring(splits[splits.length - 1]);
                } else {
                  this.line = this.line.substring(0, splits[splitIndex]);
                }
                if (splitIndex == splits.length) {
                  this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
                }
              }
            } else {
              this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
            }
            var session = this.session, shift = 0, size;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i) {
              if (ch === "	" || session.isFullWidth(ch.charCodeAt(0))) {
                size = ch === "	" ? session.getScreenTabSize(i + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
              }
              return ch;
            });
            if (this.isRtlDir) {
              this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == bidiUtil.DOT ? this.line.substr(0, this.line.length - 1) : this.line;
              this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
            }
          };
          BidiHandler2.prototype.updateBidiMap = function() {
            var textCharTypes = [];
            if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
              this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
            } else {
              this.bidiMap = {};
            }
          };
          BidiHandler2.prototype.markAsDirty = function() {
            this.currentRow = null;
          };
          BidiHandler2.prototype.updateCharacterWidths = function(fontMetrics) {
            if (this.characterWidth === fontMetrics.$characterSize.width)
              return;
            this.fontMetrics = fontMetrics;
            var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
            var bidiCharWidth = fontMetrics.$measureCharWidth("");
            this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
            this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
            this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
            this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
            this.currentRow = null;
          };
          BidiHandler2.prototype.setShowInvisibles = function(showInvisibles) {
            this.showInvisibles = showInvisibles;
            this.currentRow = null;
          };
          BidiHandler2.prototype.setEolChar = function(eolChar) {
            this.EOL = eolChar;
          };
          BidiHandler2.prototype.setContentWidth = function(width) {
            this.contentWidth = width;
          };
          BidiHandler2.prototype.isRtlLine = function(row) {
            if (this.$isRtl)
              return true;
            if (row != void 0)
              return this.session.getLine(row).charAt(0) == this.RLE;
            else
              return this.isRtlDir;
          };
          BidiHandler2.prototype.setRtlDirection = function(editor2, isRtlDir) {
            var cursor = editor2.getCursorPosition();
            for (var row = editor2.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
              if (!isRtlDir && editor2.session.getLine(row).charAt(0) === editor2.session.$bidiHandler.RLE)
                editor2.session.doc.removeInLine(row, 0, 1);
              else if (isRtlDir && editor2.session.getLine(row).charAt(0) !== editor2.session.$bidiHandler.RLE)
                editor2.session.doc.insert({ column: 0, row }, editor2.session.$bidiHandler.RLE);
            }
          };
          BidiHandler2.prototype.getPosLeft = function(col) {
            col -= this.wrapIndent;
            var leftBoundary = this.line.charAt(0) === this.RLE ? 1 : 0;
            var logicalIdx = col > leftBoundary ? this.session.getOverwrite() ? col : col - 1 : leftBoundary;
            var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
            if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
              visualIdx++;
            for (var i = 0; i < visualIdx; i++) {
              left += this.charWidths[levels[i]];
            }
            if (!this.session.getOverwrite() && col > leftBoundary && levels[visualIdx] % 2 === 0)
              left += this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              left += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            if (this.isRtlDir)
              left += this.rtlLineOffset;
            return left;
          };
          BidiHandler2.prototype.getSelections = function(startCol, endCol) {
            var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
            if (this.wrapIndent)
              offset += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
              logIdx = map.logicalFromVisual[visIdx];
              level = levels[visIdx];
              isSelected = logIdx >= selColMin && logIdx < selColMax;
              if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
              } else if (!isSelected && isSelectedPrev) {
                selections.push({ left: selectionStart, width: offset - selectionStart });
              }
              offset += this.charWidths[level];
              isSelectedPrev = isSelected;
            }
            if (isSelected && visIdx === levels.length) {
              selections.push({ left: selectionStart, width: offset - selectionStart });
            }
            if (this.isRtlDir) {
              for (var i = 0; i < selections.length; i++) {
                selections[i].left += this.rtlLineOffset;
              }
            }
            return selections;
          };
          BidiHandler2.prototype.offsetToCol = function(posX) {
            if (this.isRtlDir)
              posX -= this.rtlLineOffset;
            var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              posX -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            while (posX > offset + charWidth / 2) {
              offset += charWidth;
              if (visualIdx === levels.length - 1) {
                charWidth = 0;
                break;
              }
              charWidth = this.charWidths[levels[++visualIdx]];
            }
            if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
              if (posX < offset)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
            } else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
            } else {
              if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            }
            if (logicalIdx === 0 && this.isRtlDir)
              logicalIdx++;
            return logicalIdx + this.wrapIndent;
          };
          return BidiHandler2;
        }()
      );
      exports2.BidiHandler = BidiHandler;
    });
    ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var lang = require2("./lib/lang");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Range2 = require2("./range").Range;
      var Selection = (
        /** @class */
        function() {
          function Selection2(session) {
            this.session = session;
            this.doc = session.getDocument();
            this.clearSelection();
            this.cursor = this.lead = this.doc.createAnchor(0, 0);
            this.anchor = this.doc.createAnchor(0, 0);
            this.$silent = false;
            var self2 = this;
            this.cursor.on("change", function(e75) {
              self2.$cursorChanged = true;
              if (!self2.$silent)
                self2._emit("changeCursor");
              if (!self2.$isEmpty && !self2.$silent)
                self2._emit("changeSelection");
              if (!self2.$keepDesiredColumnOnChange && e75.old.column != e75.value.column)
                self2.$desiredColumn = null;
            });
            this.anchor.on("change", function() {
              self2.$anchorChanged = true;
              if (!self2.$isEmpty && !self2.$silent)
                self2._emit("changeSelection");
            });
          }
          Selection2.prototype.isEmpty = function() {
            return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
          };
          Selection2.prototype.isMultiLine = function() {
            return !this.$isEmpty && this.anchor.row != this.cursor.row;
          };
          Selection2.prototype.getCursor = function() {
            return this.lead.getPosition();
          };
          Selection2.prototype.setAnchor = function(row, column) {
            this.$isEmpty = false;
            this.anchor.setPosition(row, column);
          };
          Selection2.prototype.getAnchor = function() {
            if (this.$isEmpty)
              return this.getSelectionLead();
            return this.anchor.getPosition();
          };
          Selection2.prototype.getSelectionLead = function() {
            return this.lead.getPosition();
          };
          Selection2.prototype.isBackwards = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
          };
          Selection2.prototype.getRange = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            if (this.$isEmpty)
              return Range2.fromPoints(lead, lead);
            return this.isBackwards() ? Range2.fromPoints(lead, anchor) : Range2.fromPoints(anchor, lead);
          };
          Selection2.prototype.clearSelection = function() {
            if (!this.$isEmpty) {
              this.$isEmpty = true;
              this._emit("changeSelection");
            }
          };
          Selection2.prototype.selectAll = function() {
            this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
          };
          Selection2.prototype.setRange = function(range, reverse) {
            var start = reverse ? range.end : range.start;
            var end = reverse ? range.start : range.end;
            this.$setSelection(start.row, start.column, end.row, end.column);
          };
          Selection2.prototype.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
            if (this.$silent)
              return;
            var wasEmpty = this.$isEmpty;
            var wasMultiselect = this.inMultiSelectMode;
            this.$silent = true;
            this.$cursorChanged = this.$anchorChanged = false;
            this.anchor.setPosition(anchorRow, anchorColumn);
            this.cursor.setPosition(cursorRow, cursorColumn);
            this.$isEmpty = !Range2.comparePoints(this.anchor, this.cursor);
            this.$silent = false;
            if (this.$cursorChanged)
              this._emit("changeCursor");
            if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
              this._emit("changeSelection");
          };
          Selection2.prototype.$moveSelection = function(mover) {
            var lead = this.lead;
            if (this.$isEmpty)
              this.setSelectionAnchor(lead.row, lead.column);
            mover.call(this);
          };
          Selection2.prototype.selectTo = function(row, column) {
            this.$moveSelection(function() {
              this.moveCursorTo(row, column);
            });
          };
          Selection2.prototype.selectToPosition = function(pos) {
            this.$moveSelection(function() {
              this.moveCursorToPosition(pos);
            });
          };
          Selection2.prototype.moveTo = function(row, column) {
            this.clearSelection();
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveToPosition = function(pos) {
            this.clearSelection();
            this.moveCursorToPosition(pos);
          };
          Selection2.prototype.selectUp = function() {
            this.$moveSelection(this.moveCursorUp);
          };
          Selection2.prototype.selectDown = function() {
            this.$moveSelection(this.moveCursorDown);
          };
          Selection2.prototype.selectRight = function() {
            this.$moveSelection(this.moveCursorRight);
          };
          Selection2.prototype.selectLeft = function() {
            this.$moveSelection(this.moveCursorLeft);
          };
          Selection2.prototype.selectLineStart = function() {
            this.$moveSelection(this.moveCursorLineStart);
          };
          Selection2.prototype.selectLineEnd = function() {
            this.$moveSelection(this.moveCursorLineEnd);
          };
          Selection2.prototype.selectFileEnd = function() {
            this.$moveSelection(this.moveCursorFileEnd);
          };
          Selection2.prototype.selectFileStart = function() {
            this.$moveSelection(this.moveCursorFileStart);
          };
          Selection2.prototype.selectWordRight = function() {
            this.$moveSelection(this.moveCursorWordRight);
          };
          Selection2.prototype.selectWordLeft = function() {
            this.$moveSelection(this.moveCursorWordLeft);
          };
          Selection2.prototype.getWordRange = function(row, column) {
            if (typeof column == "undefined") {
              var cursor = row || this.lead;
              row = cursor.row;
              column = cursor.column;
            }
            return this.session.getWordRange(row, column);
          };
          Selection2.prototype.selectWord = function() {
            this.setSelectionRange(this.getWordRange());
          };
          Selection2.prototype.selectAWord = function() {
            var cursor = this.getCursor();
            var range = this.session.getAWordRange(cursor.row, cursor.column);
            this.setSelectionRange(range);
          };
          Selection2.prototype.getLineRange = function(row, excludeLastChar) {
            var rowStart = typeof row == "number" ? row : this.lead.row;
            var rowEnd;
            var foldLine = this.session.getFoldLine(rowStart);
            if (foldLine) {
              rowStart = foldLine.start.row;
              rowEnd = foldLine.end.row;
            } else {
              rowEnd = rowStart;
            }
            if (excludeLastChar === true)
              return new Range2(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
            else
              return new Range2(rowStart, 0, rowEnd + 1, 0);
          };
          Selection2.prototype.selectLine = function() {
            this.setSelectionRange(this.getLineRange());
          };
          Selection2.prototype.moveCursorUp = function() {
            this.moveCursorBy(-1, 0);
          };
          Selection2.prototype.moveCursorDown = function() {
            this.moveCursorBy(1, 0);
          };
          Selection2.prototype.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
            var start = cursor.column;
            var end = cursor.column + tabSize;
            if (direction < 0) {
              start = cursor.column - tabSize;
              end = cursor.column;
            }
            return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
          };
          Selection2.prototype.moveCursorLeft = function() {
            var cursor = this.lead.getPosition(), fold2;
            if (fold2 = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
              this.moveCursorTo(fold2.start.row, fold2.start.column);
            } else if (cursor.column === 0) {
              if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
              }
            } else {
              var tabSize = this.session.getTabSize();
              if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
              } else {
                this.moveCursorBy(0, -1);
              }
            }
          };
          Selection2.prototype.moveCursorRight = function() {
            var cursor = this.lead.getPosition(), fold2;
            if (fold2 = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
              this.moveCursorTo(fold2.end.row, fold2.end.column);
            } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
              if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
              }
            } else {
              var tabSize = this.session.getTabSize();
              var cursor = this.lead;
              if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
              } else {
                this.moveCursorBy(0, 1);
              }
            }
          };
          Selection2.prototype.moveCursorLineStart = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var screenRow = this.session.documentToScreenRow(row, column);
            var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
            var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
            var leadingSpace = beforeCursor.match(/^\s*/);
            if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
              firstColumnPosition.column += leadingSpace[0].length;
            this.moveCursorToPosition(firstColumnPosition);
          };
          Selection2.prototype.moveCursorLineEnd = function() {
            var lead = this.lead;
            var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
            if (this.lead.column == lineEnd.column) {
              var line = this.session.getLine(lineEnd.row);
              if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                  lineEnd.column = textEnd;
              }
            }
            this.moveCursorTo(lineEnd.row, lineEnd.column);
          };
          Selection2.prototype.moveCursorFileEnd = function() {
            var row = this.doc.getLength() - 1;
            var column = this.doc.getLine(row).length;
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveCursorFileStart = function() {
            this.moveCursorTo(0, 0);
          };
          Selection2.prototype.moveCursorLongWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            var fold2 = this.session.getFoldAt(row, column, 1);
            if (fold2) {
              this.moveCursorTo(fold2.end.row, fold2.end.column);
              return;
            }
            if (this.session.nonTokenRe.exec(rightOfCursor)) {
              column += this.session.nonTokenRe.lastIndex;
              this.session.nonTokenRe.lastIndex = 0;
              rightOfCursor = line.substring(column);
            }
            if (column >= line.length) {
              this.moveCursorTo(row, line.length);
              this.moveCursorRight();
              if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
              return;
            }
            if (this.session.tokenRe.exec(rightOfCursor)) {
              column += this.session.tokenRe.lastIndex;
              this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveCursorLongWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold2;
            if (fold2 = this.session.getFoldAt(row, column, -1)) {
              this.moveCursorTo(fold2.start.row, fold2.start.column);
              return;
            }
            var str = this.session.getFoldStringAt(row, column, -1);
            if (str == null) {
              str = this.doc.getLine(row).substring(0, column);
            }
            var leftOfCursor = lang.stringReverse(str);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            if (this.session.nonTokenRe.exec(leftOfCursor)) {
              column -= this.session.nonTokenRe.lastIndex;
              leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
              this.session.nonTokenRe.lastIndex = 0;
            }
            if (column <= 0) {
              this.moveCursorTo(row, 0);
              this.moveCursorLeft();
              if (row > 0)
                this.moveCursorWordLeft();
              return;
            }
            if (this.session.tokenRe.exec(leftOfCursor)) {
              column -= this.session.tokenRe.lastIndex;
              this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.$shortWordEndIndex = function(rightOfCursor) {
            var index = 0, ch;
            var whitespaceRe = /\s/;
            var tokenRe = this.session.tokenRe;
            tokenRe.lastIndex = 0;
            if (this.session.tokenRe.exec(rightOfCursor)) {
              index = this.session.tokenRe.lastIndex;
            } else {
              while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index++;
              if (index < 1) {
                tokenRe.lastIndex = 0;
                while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                  tokenRe.lastIndex = 0;
                  index++;
                  if (whitespaceRe.test(ch)) {
                    if (index > 2) {
                      index--;
                      break;
                    } else {
                      while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                        index++;
                      if (index > 2)
                        break;
                    }
                  }
                }
              }
            }
            tokenRe.lastIndex = 0;
            return index;
          };
          Selection2.prototype.moveCursorShortWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            var fold2 = this.session.getFoldAt(row, column, 1);
            if (fold2)
              return this.moveCursorTo(fold2.end.row, fold2.end.column);
            if (column == line.length) {
              var l = this.doc.getLength();
              do {
                row++;
                rightOfCursor = this.doc.getLine(row);
              } while (row < l && /^\s*$/.test(rightOfCursor));
              if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
              column = 0;
            }
            var index = this.$shortWordEndIndex(rightOfCursor);
            this.moveCursorTo(row, column + index);
          };
          Selection2.prototype.moveCursorShortWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold2;
            if (fold2 = this.session.getFoldAt(row, column, -1))
              return this.moveCursorTo(fold2.start.row, fold2.start.column);
            var line = this.session.getLine(row).substring(0, column);
            if (column === 0) {
              do {
                row--;
                line = this.doc.getLine(row);
              } while (row > 0 && /^\s*$/.test(line));
              column = line.length;
              if (!/\s+$/.test(line))
                line = "";
            }
            var leftOfCursor = lang.stringReverse(line);
            var index = this.$shortWordEndIndex(leftOfCursor);
            return this.moveCursorTo(row, column - index);
          };
          Selection2.prototype.moveCursorWordRight = function() {
            if (this.session.$selectLongWords)
              this.moveCursorLongWordRight();
            else
              this.moveCursorShortWordRight();
          };
          Selection2.prototype.moveCursorWordLeft = function() {
            if (this.session.$selectLongWords)
              this.moveCursorLongWordLeft();
            else
              this.moveCursorShortWordLeft();
          };
          Selection2.prototype.moveCursorBy = function(rows, chars) {
            var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
            var offsetX;
            if (chars === 0) {
              if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                  offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                  screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                } else {
                  offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
              }
              if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
              else
                this.$desiredColumn = screenPos.column;
            }
            if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
              var widget = this.session.lineWidgets[this.lead.row];
              if (rows < 0)
                rows -= widget.rowsAbove || 0;
              else if (rows > 0)
                rows += widget.rowCount - (widget.rowsAbove || 0);
            }
            var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
            if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            }
            this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
          };
          Selection2.prototype.moveCursorToPosition = function(position2) {
            this.moveCursorTo(position2.row, position2.column);
          };
          Selection2.prototype.moveCursorTo = function(row, column, keepDesiredColumn) {
            var fold2 = this.session.getFoldAt(row, column, 1);
            if (fold2) {
              row = fold2.start.row;
              column = fold2.start.column;
            }
            this.$keepDesiredColumnOnChange = true;
            var line = this.session.getLine(row);
            if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
              if (this.lead.row == row && this.lead.column == column + 1)
                column = column - 1;
              else
                column = column + 1;
            }
            this.lead.setPosition(row, column);
            this.$keepDesiredColumnOnChange = false;
            if (!keepDesiredColumn)
              this.$desiredColumn = null;
          };
          Selection2.prototype.moveCursorToScreen = function(row, column, keepDesiredColumn) {
            var pos = this.session.screenToDocumentPosition(row, column);
            this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
          };
          Selection2.prototype.detach = function() {
            this.lead.detach();
            this.anchor.detach();
          };
          Selection2.prototype.fromOrientedRange = function(range) {
            this.setSelectionRange(range, range.cursor == range.start);
            this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
          };
          Selection2.prototype.toOrientedRange = function(range) {
            var r = this.getRange();
            if (range) {
              range.start.column = r.start.column;
              range.start.row = r.start.row;
              range.end.column = r.end.column;
              range.end.row = r.end.row;
            } else {
              range = r;
            }
            range.cursor = this.isBackwards() ? range.start : range.end;
            range.desiredColumn = this.$desiredColumn;
            return range;
          };
          Selection2.prototype.getRangeOfMovements = function(func) {
            var start = this.getCursor();
            try {
              func(this);
              var end = this.getCursor();
              return Range2.fromPoints(start, end);
            } catch (e75) {
              return Range2.fromPoints(start, start);
            } finally {
              this.moveCursorToPosition(start);
            }
          };
          Selection2.prototype.toJSON = function() {
            if (this.rangeCount) {
              var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
              });
            } else {
              var data = this.getRange();
              data.isBackwards = this.isBackwards();
            }
            return data;
          };
          Selection2.prototype.fromJSON = function(data) {
            if (data.start == void 0) {
              if (this.rangeList && data.length > 1) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                  var r = Range2.fromPoints(data[i].start, data[i].end);
                  if (data[i].isBackwards)
                    r.cursor = r.start;
                  this.addRange(r, true);
                }
                return;
              } else {
                data = data[0];
              }
            }
            if (this.rangeList)
              this.toSingleRange(data);
            this.setSelectionRange(data, data.isBackwards);
          };
          Selection2.prototype.isEqual = function(data) {
            if ((data.length || this.rangeCount) && data.length != this.rangeCount)
              return false;
            if (!data.length || !this.ranges)
              return this.getRange().isEqual(data);
            for (var i = this.ranges.length; i--; ) {
              if (!this.ranges[i].isEqual(data[i]))
                return false;
            }
            return true;
          };
          return Selection2;
        }()
      );
      Selection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;
      Selection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;
      Selection.prototype.setSelectionRange = Selection.prototype.setRange;
      oop.implement(Selection.prototype, EventEmitter);
      exports2.Selection = Selection;
    });
    ace.define("ace/tokenizer", ["require", "exports", "module", "ace/lib/report_error"], function(require2, exports2, module2) {
      "use strict";
      var reportError = require2("./lib/report_error").reportError;
      var MAX_TOKEN_COUNT = 2e3;
      var Tokenizer = (
        /** @class */
        function() {
          function Tokenizer2(rules) {
            this.splitRegex;
            this.states = rules;
            this.regExps = {};
            this.matchMappings = {};
            for (var key in this.states) {
              var state = this.states[key];
              var ruleRegExps = [];
              var matchTotal = 0;
              var mapping2 = this.matchMappings[key] = { defaultToken: "text" };
              var flag = "g";
              var splitterRurles = [];
              for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.defaultToken)
                  mapping2.defaultToken = rule.defaultToken;
                if (rule.caseInsensitive && flag.indexOf("i") === -1)
                  flag += "i";
                if (rule.unicode && flag.indexOf("u") === -1)
                  flag += "u";
                if (rule.regex == null)
                  continue;
                if (rule.regex instanceof RegExp)
                  rule.regex = rule.regex.toString().slice(1, -1);
                var adjustedregex = rule.regex;
                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                if (Array.isArray(rule.token)) {
                  if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                  } else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", {
                      rule,
                      groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                  } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                  }
                } else if (typeof rule.token == "function" && !rule.onMatch) {
                  if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                  else
                    rule.onMatch = rule.token;
                }
                if (matchcount > 1) {
                  if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match2, digit) {
                      return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                  } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                  }
                  if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule);
                }
                mapping2[matchTotal] = i;
                matchTotal += matchcount;
                ruleRegExps.push(adjustedregex);
                if (!rule.onMatch)
                  rule.onMatch = null;
              }
              if (!ruleRegExps.length) {
                mapping2[0] = 0;
                ruleRegExps.push("$");
              }
              splitterRurles.forEach(function(rule2) {
                rule2.splitRegex = this.createSplitterRegexp(rule2.regex, flag);
              }, this);
              this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
            }
          }
          Tokenizer2.prototype.$setMaxTokenCount = function(m) {
            MAX_TOKEN_COUNT = m | 0;
          };
          Tokenizer2.prototype.$applyToken = function(str) {
            var values = this.splitRegex.exec(str).slice(1);
            var types = this.token.apply(this, values);
            if (typeof types === "string")
              return [{ type: types, value: str }];
            var tokens2 = [];
            for (var i = 0, l = types.length; i < l; i++) {
              if (values[i])
                tokens2[tokens2.length] = {
                  type: types[i],
                  value: values[i]
                };
            }
            return tokens2;
          };
          Tokenizer2.prototype.$arrayTokens = function(str) {
            if (!str)
              return [];
            var values = this.splitRegex.exec(str);
            if (!values)
              return "text";
            var tokens2 = [];
            var types = this.tokenArray;
            for (var i = 0, l = types.length; i < l; i++) {
              if (values[i + 1])
                tokens2[tokens2.length] = {
                  type: types[i],
                  value: values[i + 1]
                };
            }
            return tokens2;
          };
          Tokenizer2.prototype.removeCapturingGroups = function(src2) {
            var r = src2.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(x, y) {
              return y ? "(?:" : x;
            });
            return r;
          };
          Tokenizer2.prototype.createSplitterRegexp = function(src2, flag) {
            if (src2.indexOf("(?=") != -1) {
              var stack = 0;
              var inChClass = false;
              var lastCapture = {};
              src2.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index) {
                if (inChClass) {
                  inChClass = square != "]";
                } else if (square) {
                  inChClass = true;
                } else if (parenClose) {
                  if (stack == lastCapture.stack) {
                    lastCapture.end = index + 1;
                    lastCapture.stack = -1;
                  }
                  stack--;
                } else if (parenOpen) {
                  stack++;
                  if (parenOpen.length != 1) {
                    lastCapture.stack = stack;
                    lastCapture.start = index;
                  }
                }
                return m;
              });
              if (lastCapture.end != null && /^\)*$/.test(src2.substr(lastCapture.end)))
                src2 = src2.substring(0, lastCapture.start) + src2.substr(lastCapture.end);
            }
            if (src2.charAt(0) != "^")
              src2 = "^" + src2;
            if (src2.charAt(src2.length - 1) != "$")
              src2 += "$";
            return new RegExp(src2, (flag || "").replace("g", ""));
          };
          Tokenizer2.prototype.getLineTokens = function(line, startState) {
            if (startState && typeof startState != "string") {
              var stack = startState.slice(0);
              startState = stack[0];
              if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
              }
            } else
              var stack = [];
            var currentState = (
              /**@type{string}*/
              startState || "start"
            );
            var state = this.states[currentState];
            if (!state) {
              currentState = "start";
              state = this.states[currentState];
            }
            var mapping2 = this.matchMappings[currentState];
            var re = this.regExps[currentState];
            re.lastIndex = 0;
            var match2, tokens2 = [];
            var lastIndex = 0;
            var matchAttempts = 0;
            var token = { type: null, value: "" };
            while (match2 = re.exec(line)) {
              var type2 = mapping2.defaultToken;
              var rule = null;
              var value = match2[0];
              var index = re.lastIndex;
              if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type2) {
                  token.value += skipped;
                } else {
                  if (token.type)
                    tokens2.push(token);
                  token = { type: type2, value: skipped };
                }
              }
              for (var i = 0; i < match2.length - 2; i++) {
                if (match2[i + 1] === void 0)
                  continue;
                rule = state[mapping2[i]];
                if (rule.onMatch)
                  type2 = rule.onMatch(value, currentState, stack, line);
                else
                  type2 = rule.token;
                if (rule.next) {
                  if (typeof rule.next == "string") {
                    currentState = rule.next;
                  } else {
                    currentState = rule.next(currentState, stack);
                  }
                  state = this.states[currentState];
                  if (!state) {
                    this.reportError("state doesn't exist", currentState);
                    currentState = "start";
                    state = this.states[currentState];
                  }
                  mapping2 = this.matchMappings[currentState];
                  lastIndex = index;
                  re = this.regExps[currentState];
                  re.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                  lastIndex = index;
                break;
              }
              if (value) {
                if (typeof type2 === "string") {
                  if ((!rule || rule.merge !== false) && token.type === type2) {
                    token.value += value;
                  } else {
                    if (token.type)
                      tokens2.push(token);
                    token = { type: type2, value };
                  }
                } else if (type2) {
                  if (token.type)
                    tokens2.push(token);
                  token = { type: null, value: "" };
                  for (var i = 0; i < type2.length; i++)
                    tokens2.push(type2[i]);
                }
              }
              if (lastIndex == line.length)
                break;
              lastIndex = index;
              if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                  this.reportError("infinite loop with in ace tokenizer", {
                    startState,
                    line
                  });
                }
                while (lastIndex < line.length) {
                  if (token.type)
                    tokens2.push(token);
                  token = {
                    value: line.substring(lastIndex, lastIndex += 500),
                    type: "overflow"
                  };
                }
                currentState = "start";
                stack = [];
                break;
              }
            }
            if (token.type)
              tokens2.push(token);
            if (stack.length > 1) {
              if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
            }
            return {
              tokens: tokens2,
              state: stack.length ? stack : currentState
            };
          };
          return Tokenizer2;
        }()
      );
      Tokenizer.prototype.reportError = reportError;
      exports2.Tokenizer = Tokenizer;
    });
    ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/deep_copy"], function(require2, exports2, module2) {
      "use strict";
      var deepCopy = require2("../lib/deep_copy").deepCopy;
      var TextHighlightRules;
      TextHighlightRules = function() {
        this.$rules = {
          "start": [{
            token: "empty_line",
            regex: "^$"
          }, {
            defaultToken: "text"
          }]
        };
      };
      (function() {
        this.addRules = function(rules, prefix) {
          if (!prefix) {
            for (var key in rules)
              this.$rules[key] = rules[key];
            return;
          }
          for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              if (rule.next || rule.onMatch) {
                if (typeof rule.next == "string") {
                  if (rule.next.indexOf(prefix) !== 0)
                    rule.next = prefix + rule.next;
                }
                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                  rule.nextState = prefix + rule.nextState;
              }
            }
            this.$rules[prefix + key] = state;
          }
        };
        this.getRules = function() {
          return this.$rules;
        };
        this.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
          var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
          if (states) {
            for (var i = 0; i < states.length; i++)
              states[i] = prefix + states[i];
          } else {
            states = [];
            for (var key in embedRules)
              states.push(prefix + key);
          }
          this.addRules(embedRules, prefix);
          if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
              addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));
          }
          if (!this.$embeds)
            this.$embeds = [];
          this.$embeds.push(prefix);
        };
        this.getEmbeds = function() {
          return this.$embeds;
        };
        var pushState = function(currentState, stack) {
          if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
          return this.nextState;
        };
        var popState = function(currentState, stack) {
          stack.shift();
          return stack.shift() || "start";
        };
        this.normalizeRules = function() {
          var id = 0;
          var rules = this.$rules;
          function processState(key) {
            var state = rules[key];
            state["processed"] = true;
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              var toInsert = null;
              if (Array.isArray(rule)) {
                toInsert = rule;
                rule = {};
              }
              if (!rule.regex && rule.start) {
                rule.regex = rule.start;
                if (!rule.next)
                  rule.next = [];
                rule.next.push({
                  defaultToken: rule.token
                }, {
                  token: rule.token + ".end",
                  regex: rule.end || rule.start,
                  next: "pop"
                });
                rule.token = rule.token + ".start";
                rule.push = true;
              }
              var next = rule.next || rule.push;
              if (next && Array.isArray(next)) {
                var stateName = rule.stateName;
                if (!stateName) {
                  stateName = rule.token;
                  if (typeof stateName != "string")
                    stateName = stateName[0] || "";
                  if (rules[stateName])
                    stateName += id++;
                }
                rules[stateName] = next;
                rule.next = stateName;
                processState(stateName);
              } else if (next == "pop") {
                rule.next = popState;
              }
              if (rule.push) {
                rule.nextState = rule.next || rule.push;
                rule.next = pushState;
                delete rule.push;
              }
              if (rule.rules) {
                for (var r in rule.rules) {
                  if (rules[r]) {
                    if (rules[r].push)
                      rules[r].push.apply(rules[r], rule.rules[r]);
                  } else {
                    rules[r] = rule.rules[r];
                  }
                }
              }
              var includeName = typeof rule == "string" ? rule : rule.include;
              if (includeName) {
                if (includeName === "$self")
                  includeName = "start";
                if (Array.isArray(includeName))
                  toInsert = includeName.map(function(x) {
                    return rules[x];
                  });
                else
                  toInsert = rules[includeName];
              }
              if (toInsert) {
                var args = [i, 1].concat(toInsert);
                if (rule.noEscape)
                  args = args.filter(function(x) {
                    return !x.next;
                  });
                state.splice.apply(state, args);
                i--;
              }
              if (rule.keywordMap) {
                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                delete rule.defaultToken;
              }
            }
          }
          Object.keys(rules).forEach(processState, this);
        };
        this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
          var keywords = /* @__PURE__ */ Object.create(null);
          this.$keywordList = [];
          Object.keys(map).forEach(function(className) {
            var a = map[className];
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; ) {
              var word = list[i];
              this.$keywordList.push(word);
              if (ignoreCase)
                word = word.toLowerCase();
              keywords[word] = className;
            }
          }, this);
          map = null;
          return ignoreCase ? function(value) {
            return keywords[value.toLowerCase()] || defaultToken;
          } : function(value) {
            return keywords[value] || defaultToken;
          };
        };
        this.getKeywords = function() {
          return this.$keywords;
        };
      }).call(TextHighlightRules.prototype);
      exports2.TextHighlightRules = TextHighlightRules;
    });
    ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var Behaviour;
      Behaviour = function() {
        this.$behaviours = {};
      };
      (function() {
        this.add = function(name, action, callback) {
          switch (void 0) {
            case this.$behaviours:
              this.$behaviours = {};
            case this.$behaviours[name]:
              this.$behaviours[name] = {};
          }
          this.$behaviours[name][action] = callback;
        };
        this.addBehaviours = function(behaviours) {
          for (var key in behaviours) {
            for (var action in behaviours[key]) {
              this.add(key, action, behaviours[key][action]);
            }
          }
        };
        this.remove = function(name) {
          if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
          }
        };
        this.inherit = function(mode, filter) {
          if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
          } else {
            var behaviours = mode.getBehaviours(filter);
          }
          this.addBehaviours(behaviours);
        };
        this.getBehaviours = function(filter) {
          if (!filter) {
            return this.$behaviours;
          } else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
              if (this.$behaviours[filter[i]]) {
                ret[filter[i]] = this.$behaviours[filter[i]];
              }
            }
            return ret;
          }
        };
      }).call(Behaviour.prototype);
      exports2.Behaviour = Behaviour;
    });
    ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var Range2 = require2("./range").Range;
      var TokenIterator = (
        /** @class */
        function() {
          function TokenIterator2(session, initialRow, initialColumn) {
            this.$session = session;
            this.$row = initialRow;
            this.$rowTokens = session.getTokens(initialRow);
            var token = session.getTokenAt(initialRow, initialColumn);
            this.$tokenIndex = token ? token.index : -1;
          }
          TokenIterator2.prototype.stepBackward = function() {
            this.$tokenIndex -= 1;
            while (this.$tokenIndex < 0) {
              this.$row -= 1;
              if (this.$row < 0) {
                this.$row = 0;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = this.$rowTokens.length - 1;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.stepForward = function() {
            this.$tokenIndex += 1;
            var rowCount;
            while (this.$tokenIndex >= this.$rowTokens.length) {
              this.$row += 1;
              if (!rowCount)
                rowCount = this.$session.getLength();
              if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = 0;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.getCurrentToken = function() {
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.getCurrentTokenRow = function() {
            return this.$row;
          };
          TokenIterator2.prototype.getCurrentTokenColumn = function() {
            var rowTokens = this.$rowTokens;
            var tokenIndex = this.$tokenIndex;
            var column = rowTokens[tokenIndex].start;
            if (column !== void 0)
              return column;
            column = 0;
            while (tokenIndex > 0) {
              tokenIndex -= 1;
              column += rowTokens[tokenIndex].value.length;
            }
            return column;
          };
          TokenIterator2.prototype.getCurrentTokenPosition = function() {
            return { row: this.$row, column: this.getCurrentTokenColumn() };
          };
          TokenIterator2.prototype.getCurrentTokenRange = function() {
            var token = this.$rowTokens[this.$tokenIndex];
            var column = this.getCurrentTokenColumn();
            return new Range2(this.$row, column, this.$row, column + token.value.length);
          };
          return TokenIterator2;
        }()
      );
      exports2.TokenIterator = TokenIterator;
    });
    ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("../../lib/oop");
      var Behaviour = require2("../behaviour").Behaviour;
      var TokenIterator = require2("../../token_iterator").TokenIterator;
      var lang = require2("../../lib/lang");
      var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
      var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];
      var context;
      var contextCache = {};
      var defaultQuotes = { '"': '"', "'": "'" };
      var initContext = function(editor2) {
        var id = -1;
        if (editor2.multiSelect) {
          id = editor2.selection.index;
          if (contextCache.rangeCount != editor2.multiSelect.rangeCount)
            contextCache = { rangeCount: editor2.multiSelect.rangeCount };
        }
        if (contextCache[id])
          return context = contextCache[id];
        context = contextCache[id] = {
          autoInsertedBrackets: 0,
          autoInsertedRow: -1,
          autoInsertedLineEnd: "",
          maybeInsertedBrackets: 0,
          maybeInsertedRow: -1,
          maybeInsertedLineStart: "",
          maybeInsertedLineEnd: ""
        };
      };
      var getWrapped = function(selection, selected, opening, closing) {
        var rowDiff = selection.end.row - selection.start.row;
        return {
          text: opening + selected + closing,
          selection: [
            0,
            selection.start.column + 1,
            rowDiff,
            selection.end.column + (rowDiff ? 0 : 1)
          ]
        };
      };
      var CstyleBehaviour;
      CstyleBehaviour = function(options) {
        options = options || {};
        this.add("braces", "insertion", function(state, action, editor2, session, text) {
          var cursor = editor2.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (text == "{") {
            initContext(editor2);
            var selection = editor2.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            var token = session.getTokenAt(cursor.row, cursor.column);
            if (selected !== "" && selected !== "{" && editor2.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "{", "}");
            } else if (token && /(?:string)\.quasi|\.xml/.test(token.type)) {
              var excludeTokens = [
                /tag\-(?:open|name)/,
                /attribute\-name/
              ];
              if (excludeTokens.some(function(el) {
                return el.test(token.type);
              }) || /(string)\.quasi/.test(token.type) && token.value[cursor.column - token.start - 1] !== "$")
                return;
              CstyleBehaviour.recordAutoInsert(editor2, session, "}");
              return {
                text: "{}",
                selection: [1, 1]
              };
            } else if (CstyleBehaviour.isSaneInsertion(editor2, session)) {
              if (/[\]\}\)]/.test(line[cursor.column]) || editor2.inMultiSelectMode || options.braces) {
                CstyleBehaviour.recordAutoInsert(editor2, session, "}");
                return {
                  text: "{}",
                  selection: [1, 1]
                };
              } else {
                CstyleBehaviour.recordMaybeInsert(editor2, session, "{");
                return {
                  text: "{",
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "}") {
            initContext(editor2);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == "}") {
              var matching = session.$findOpeningBracket("}", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "\n" || text == "\r\n") {
            initContext(editor2);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
              closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
              CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === "}") {
              var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, "}");
              if (!openBracePos)
                return null;
              var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
              var next_indent = this.$getIndent(line);
            } else {
              CstyleBehaviour.clearMaybeInsertedClosing();
              return;
            }
            var indent = next_indent + session.getTabString();
            return {
              text: "\n" + indent + "\n" + next_indent + closing,
              selection: [1, indent.length, 1, indent.length]
            };
          } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
          }
        });
        this.add("braces", "deletion", function(state, action, editor2, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "{") {
            initContext(editor2);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == "}") {
              range.end.column++;
              return range;
            } else {
              context.maybeInsertedBrackets--;
            }
          }
        });
        this.add("parens", "insertion", function(state, action, editor2, session, text) {
          if (text == "(") {
            initContext(editor2);
            var selection = editor2.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor2.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "(", ")");
            } else if (CstyleBehaviour.isSaneInsertion(editor2, session)) {
              CstyleBehaviour.recordAutoInsert(editor2, session, ")");
              return {
                text: "()",
                selection: [1, 1]
              };
            }
          } else if (text == ")") {
            initContext(editor2);
            var cursor = editor2.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ")") {
              var matching = session.$findOpeningBracket(")", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("parens", "deletion", function(state, action, editor2, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "(") {
            initContext(editor2);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ")") {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("brackets", "insertion", function(state, action, editor2, session, text) {
          if (text == "[") {
            initContext(editor2);
            var selection = editor2.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor2.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "[", "]");
            } else if (CstyleBehaviour.isSaneInsertion(editor2, session)) {
              CstyleBehaviour.recordAutoInsert(editor2, session, "]");
              return {
                text: "[]",
                selection: [1, 1]
              };
            }
          } else if (text == "]") {
            initContext(editor2);
            var cursor = editor2.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == "]") {
              var matching = session.$findOpeningBracket("]", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("brackets", "deletion", function(state, action, editor2, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "[") {
            initContext(editor2);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == "]") {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("string_dquotes", "insertion", function(state, action, editor2, session, text) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
              return;
            initContext(editor2);
            var quote2 = text;
            var selection = editor2.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor2.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, quote2, quote2);
            } else if (!selected) {
              var cursor = editor2.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var leftChar = line.substring(cursor.column - 1, cursor.column);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              var token = session.getTokenAt(cursor.row, cursor.column);
              var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
              if (leftChar == "\\" && token && /escape/.test(token.type))
                return null;
              var stringBefore = token && /string|escape/.test(token.type);
              var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
              var pair;
              if (rightChar == quote2) {
                pair = stringBefore !== stringAfter;
                if (pair && /string\.end/.test(rightToken.type))
                  pair = false;
              } else {
                if (stringBefore && !stringAfter)
                  return null;
                if (stringBefore && stringAfter)
                  return null;
                var wordRe = session.$mode.tokenRe;
                wordRe.lastIndex = 0;
                var isWordBefore = wordRe.test(leftChar);
                wordRe.lastIndex = 0;
                var isWordAfter = wordRe.test(rightChar);
                var pairQuotesAfter = session.$mode.$pairQuotesAfter;
                var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote2] && pairQuotesAfter[quote2].test(leftChar);
                if (!shouldPairQuotes && isWordBefore || isWordAfter)
                  return null;
                if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                  return null;
                var charBefore = line[cursor.column - 2];
                if (leftChar == quote2 && (charBefore == quote2 || wordRe.test(charBefore)))
                  return null;
                pair = true;
              }
              return {
                text: pair ? quote2 + quote2 : "",
                selection: [1, 1]
              };
            }
          }
        });
        this.add("string_dquotes", "deletion", function(state, action, editor2, session, range) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
            initContext(editor2);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
              range.end.column++;
              return range;
            }
          }
        });
        if (options.closeDocComment !== false) {
          this.add("doc comment end", "insertion", function(state, action, editor2, session, text) {
            if (state === "doc-start" && (text === "\n" || text === "\r\n") && editor2.selection.isEmpty()) {
              var cursor = editor2.getCursorPosition();
              if (cursor.column === 0) {
                return;
              }
              var line = session.doc.getLine(cursor.row);
              var nextLine = session.doc.getLine(cursor.row + 1);
              var tokens2 = session.getTokens(cursor.row);
              var index = 0;
              for (var i = 0; i < tokens2.length; i++) {
                index += tokens2[i].value.length;
                var currentToken = tokens2[i];
                if (index >= cursor.column) {
                  if (index === cursor.column) {
                    if (!/\.doc/.test(currentToken.type)) {
                      return;
                    }
                    if (/\*\//.test(currentToken.value)) {
                      var nextToken = tokens2[i + 1];
                      if (!nextToken || !/\.doc/.test(nextToken.type)) {
                        return;
                      }
                    }
                  }
                  var cursorPosInToken = cursor.column - (index - currentToken.value.length);
                  var closeDocPos = currentToken.value.indexOf("*/");
                  var openDocPos = currentToken.value.indexOf("/**", closeDocPos > -1 ? closeDocPos + 2 : 0);
                  if (openDocPos !== -1 && cursorPosInToken > openDocPos && cursorPosInToken < openDocPos + 3) {
                    return;
                  }
                  if (closeDocPos !== -1 && openDocPos !== -1 && cursorPosInToken >= closeDocPos && cursorPosInToken <= openDocPos || !/\.doc/.test(currentToken.type)) {
                    return;
                  }
                  break;
                }
              }
              var indent = this.$getIndent(line);
              if (/\s*\*/.test(nextLine)) {
                if (/^\s*\*/.test(line)) {
                  return {
                    text: text + indent + "* ",
                    selection: [1, 2 + indent.length, 1, 2 + indent.length]
                  };
                } else {
                  return {
                    text: text + indent + " * ",
                    selection: [1, 3 + indent.length, 1, 3 + indent.length]
                  };
                }
              }
              if (/\/\*\*/.test(line.substring(0, cursor.column))) {
                return {
                  text: text + indent + " * " + text + " " + indent + "*/",
                  selection: [1, 4 + indent.length, 1, 4 + indent.length]
                };
              }
            }
          });
        }
      };
      CstyleBehaviour.isSaneInsertion = function(editor2, session) {
        var cursor = editor2.getCursorPosition();
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
          if (/[)}\]]/.test(editor2.session.getLine(cursor.row)[cursor.column]))
            return true;
          var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
          if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
      };
      CstyleBehaviour["$matchTokenType"] = function(token, types) {
        return types.indexOf(token.type || token) > -1;
      };
      CstyleBehaviour["recordAutoInsert"] = function(editor2, session, bracket) {
        var cursor = editor2.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this["isAutoInsertedClosing"](cursor, line, context.autoInsertedLineEnd[0]))
          context.autoInsertedBrackets = 0;
        context.autoInsertedRow = cursor.row;
        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
        context.autoInsertedBrackets++;
      };
      CstyleBehaviour["recordMaybeInsert"] = function(editor2, session, bracket) {
        var cursor = editor2.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this["isMaybeInsertedClosing"](cursor, line))
          context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = cursor.row;
        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        context.maybeInsertedLineEnd = line.substr(cursor.column);
        context.maybeInsertedBrackets++;
      };
      CstyleBehaviour["isAutoInsertedClosing"] = function(cursor, line, bracket) {
        return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
      };
      CstyleBehaviour["isMaybeInsertedClosing"] = function(cursor, line) {
        return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
      };
      CstyleBehaviour["popAutoInsertedClosing"] = function() {
        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
        context.autoInsertedBrackets--;
      };
      CstyleBehaviour["clearMaybeInsertedClosing"] = function() {
        if (context) {
          context.maybeInsertedBrackets = 0;
          context.maybeInsertedRow = -1;
        }
      };
      oop.inherits(CstyleBehaviour, Behaviour);
      exports2.CstyleBehaviour = CstyleBehaviour;
    });
    ace.define("ace/unicode", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      var wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];
      var code = 0;
      var str = [];
      for (var i = 0; i < wordChars.length; i += 2) {
        str.push(code += wordChars[i]);
        if (wordChars[i + 1])
          str.push(45, code += wordChars[i + 1]);
      }
      exports2.wordChars = String.fromCharCode.apply(null, str);
    });
    ace.define("ace/mode/text", ["require", "exports", "module", "ace/config", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var config2 = require2("../config");
      var Tokenizer = require2("../tokenizer").Tokenizer;
      var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
      var CstyleBehaviour = require2("./behaviour/cstyle").CstyleBehaviour;
      var unicode = require2("../unicode");
      var lang = require2("../lib/lang");
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var Range2 = require2("../range").Range;
      var Mode;
      Mode = function() {
        this.HighlightRules = TextHighlightRules;
      };
      (function() {
        this.$defaultBehaviour = new CstyleBehaviour();
        this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
        this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
        this.getTokenizer = function() {
          if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
          }
          return this.$tokenizer;
        };
        this.lineCommentStart = "";
        this.blockComment = "";
        this.toggleCommentLines = function(state, session, startRow, endRow) {
          var doc2 = session.doc;
          var ignoreBlankLines = true;
          var shouldRemove = true;
          var minIndent = Infinity;
          var tabSize = session.getTabSize();
          var insertAtTabStop = false;
          if (!this.lineCommentStart) {
            if (!this.blockComment)
              return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
            var comment = function(line, i) {
              if (testRemove(line, i))
                return;
              if (!ignoreBlankLines || /\S/.test(line)) {
                doc2.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                doc2.insertInLine({ row: i, column: minIndent }, lineCommentStart);
              }
            };
            var uncomment = function(line, i) {
              var m;
              if (m = line.match(regexpEnd))
                doc2.removeInLine(i, line.length - m[0].length, line.length);
              if (m = line.match(regexpStart))
                doc2.removeInLine(i, m[1].length, m[0].length);
            };
            var testRemove = function(line, row) {
              if (regexpStart.test(line))
                return true;
              var tokens2 = session.getTokens(row);
              for (var i = 0; i < tokens2.length; i++) {
                if (tokens2[i].type === "comment")
                  return true;
              }
            };
          } else {
            if (Array.isArray(this.lineCommentStart)) {
              var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
              var lineCommentStart = this.lineCommentStart[0];
            } else {
              var regexpStart = lang.escapeRegExp(this.lineCommentStart);
              var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            insertAtTabStop = session.getUseSoftTabs();
            var uncomment = function(line, i) {
              var m = line.match(regexpStart);
              if (!m)
                return;
              var start = m[1].length, end = m[0].length;
              if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                end--;
              doc2.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
              if (!ignoreBlankLines || /\S/.test(line)) {
                if (shouldInsertSpace(line, minIndent, minIndent))
                  doc2.insertInLine({ row: i, column: minIndent }, commentWithSpace);
                else
                  doc2.insertInLine({ row: i, column: minIndent }, lineCommentStart);
              }
            };
            var testRemove = function(line, i) {
              return regexpStart.test(line);
            };
            var shouldInsertSpace = function(line, before, after) {
              var spaces = 0;
              while (before-- && line.charAt(before) == " ")
                spaces++;
              if (spaces % tabSize != 0)
                return false;
              var spaces = 0;
              while (line.charAt(after++) == " ")
                spaces++;
              if (tabSize > 2)
                return spaces % tabSize != tabSize - 1;
              else
                return spaces % tabSize == 0;
            };
          }
          function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
              fun(doc2.getLine(i), i);
          }
          var minEmptyLength = Infinity;
          iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
              if (indent < minIndent)
                minIndent = indent;
              if (shouldRemove && !testRemove(line, i))
                shouldRemove = false;
            } else if (minEmptyLength > line.length) {
              minEmptyLength = line.length;
            }
          });
          if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
          }
          if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;
          iter(shouldRemove ? uncomment : comment);
        };
        this.toggleBlockComment = function(state, session, range, cursor) {
          var comment = this.blockComment;
          if (!comment)
            return;
          if (!comment.start && comment[0])
            comment = comment[0];
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          var sel = session.selection;
          var initialRange = session.selection.toOrientedRange();
          var startRow, colDiff;
          if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.start);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                startRange = new Range2(row, column, row, column + comment.start.length);
                break;
              }
              token = iterator.stepBackward();
            }
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.end);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                endRange = new Range2(row, column, row, column + comment.end.length);
                break;
              }
              token = iterator.stepForward();
            }
            if (endRange)
              session.remove(endRange);
            if (startRange) {
              session.remove(startRange);
              startRow = startRange.start.row;
              colDiff = -comment.start.length;
            }
          } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
          }
          if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
          if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
          session.selection.fromOrientedRange(initialRange);
        };
        this.getNextLineIndent = function(state, line, tab) {
          return this.$getIndent(line);
        };
        this.checkOutdent = function(state, line, input) {
          return false;
        };
        this.autoOutdent = function(state, doc2, row) {
        };
        this.$getIndent = function(line) {
          return line.match(/^\s*/)[0];
        };
        this.createWorker = function(session) {
          return null;
        };
        this.createModeDelegates = function(mapping2) {
          this.$embeds = [];
          this.$modes = {};
          for (var i in mapping2) {
            if (mapping2[i]) {
              var Mode2 = mapping2[i];
              var id = Mode2.prototype.$id;
              var mode = config2.$modes[id];
              if (!mode)
                config2.$modes[id] = mode = new Mode2();
              if (!config2.$modes[i])
                config2.$modes[i] = mode;
              this.$embeds.push(i);
              this.$modes[i] = mode;
            }
          }
          var delegations = [
            "toggleBlockComment",
            "toggleCommentLines",
            "getNextLineIndent",
            "checkOutdent",
            "autoOutdent",
            "transformAction",
            "getCompletions"
          ];
          var _loop_1 = function(i2) {
            (function(scope) {
              var functionName = delegations[i2];
              var defaultHandler = scope[functionName];
              scope[delegations[i2]] = function() {
                return this.$delegator(functionName, arguments, defaultHandler);
              };
            })(this_1);
          };
          var this_1 = this;
          for (var i = 0; i < delegations.length; i++) {
            _loop_1(i);
          }
        };
        this.$delegator = function(method, args, defaultHandler) {
          var state = args[0] || "start";
          if (typeof state != "string") {
            if (Array.isArray(state[2])) {
              var language = state[2][state[2].length - 1];
              var mode = this.$modes[language];
              if (mode)
                return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
            }
            state = state[0] || "start";
          }
          for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]])
              continue;
            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
              args[0] = split[1];
              var mode = this.$modes[this.$embeds[i]];
              return mode[method].apply(mode, args);
            }
          }
          var ret = defaultHandler.apply(this, args);
          return defaultHandler ? ret : void 0;
        };
        this.transformAction = function(state, action, editor2, session, param) {
          if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
              if (behaviours[key][action]) {
                var ret = behaviours[key][action].apply(this, arguments);
                if (ret) {
                  return ret;
                }
              }
            }
          }
        };
        this.getKeywords = function(append) {
          if (!this.completionKeywords) {
            var rules = this.$tokenizer["rules"];
            var completionKeywords = [];
            for (var rule in rules) {
              var ruleItr = rules[rule];
              for (var r = 0, l = ruleItr.length; r < l; r++) {
                if (typeof ruleItr[r].token === "string") {
                  if (/keyword|support|storage/.test(ruleItr[r].token))
                    completionKeywords.push(ruleItr[r].regex);
                } else if (typeof ruleItr[r].token === "object") {
                  for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                    if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                      var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                      completionKeywords.push(rule.substr(1, rule.length - 2));
                    }
                  }
                }
              }
            }
            this.completionKeywords = completionKeywords;
          }
          if (!append)
            return this.$keywordList;
          return completionKeywords.concat(this.$keywordList || []);
        };
        this.$createKeywordList = function() {
          if (!this.$highlightRules)
            this.getTokenizer();
          return this.$keywordList = this.$highlightRules.$keywordList || [];
        };
        this.getCompletions = function(state, session, pos, prefix) {
          var keywords = this.$keywordList || this.$createKeywordList();
          return keywords.map(function(word) {
            return {
              name: word,
              value: word,
              score: 0,
              meta: "keyword"
            };
          });
        };
        this.$id = "ace/mode/text";
      }).call(Mode.prototype);
      exports2.Mode = Mode;
    });
    ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("./lib/dom");
      var LineWidgets = (
        /** @class */
        function() {
          function LineWidgets2(session) {
            this.session = session;
            this.session.widgetManager = this;
            this.session.getRowLength = this.getRowLength;
            this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
            this.updateOnChange = this.updateOnChange.bind(this);
            this.renderWidgets = this.renderWidgets.bind(this);
            this.measureWidgets = this.measureWidgets.bind(this);
            this.session._changedWidgets = [];
            this.$onChangeEditor = this.$onChangeEditor.bind(this);
            this.session.on("change", this.updateOnChange);
            this.session.on("changeFold", this.updateOnFold);
            this.session.on("changeEditor", this.$onChangeEditor);
          }
          LineWidgets2.prototype.getRowLength = function(row) {
            var h;
            if (this.lineWidgets)
              h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            else
              h = 0;
            if (!this["$useWrapMode"] || !this["$wrapData"][row]) {
              return 1 + h;
            } else {
              return this["$wrapData"][row].length + 1 + h;
            }
          };
          LineWidgets2.prototype.$getWidgetScreenLength = function() {
            var screenRows = 0;
            this.lineWidgets.forEach(function(w) {
              if (w && w.rowCount && !w.hidden)
                screenRows += w.rowCount;
            });
            return screenRows;
          };
          LineWidgets2.prototype.$onChangeEditor = function(e75) {
            this.attach(e75.editor);
          };
          LineWidgets2.prototype.attach = function(editor2) {
            if (editor2 && editor2.widgetManager && editor2.widgetManager != this)
              editor2.widgetManager.detach();
            if (this.editor == editor2)
              return;
            this.detach();
            this.editor = editor2;
            if (editor2) {
              editor2.widgetManager = this;
              editor2.renderer.on("beforeRender", this.measureWidgets);
              editor2.renderer.on("afterRender", this.renderWidgets);
            }
          };
          LineWidgets2.prototype.detach = function(e75) {
            var editor2 = this.editor;
            if (!editor2)
              return;
            this.editor = null;
            editor2.widgetManager = null;
            editor2.renderer.off("beforeRender", this.measureWidgets);
            editor2.renderer.off("afterRender", this.renderWidgets);
            var lineWidgets = this.session.lineWidgets;
            lineWidgets && lineWidgets.forEach(function(w) {
              if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
              }
            });
          };
          LineWidgets2.prototype.updateOnFold = function(e75, session) {
            var lineWidgets = session.lineWidgets;
            if (!lineWidgets || !e75.action)
              return;
            var fold2 = e75.data;
            var start = fold2.start.row;
            var end = fold2.end.row;
            var hide = e75.action == "add";
            for (var i = start + 1; i < end; i++) {
              if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
            }
            if (lineWidgets[end]) {
              if (hide) {
                if (!lineWidgets[start])
                  lineWidgets[start] = lineWidgets[end];
                else
                  lineWidgets[end].hidden = hide;
              } else {
                if (lineWidgets[start] == lineWidgets[end])
                  lineWidgets[start] = void 0;
                lineWidgets[end].hidden = hide;
              }
            }
          };
          LineWidgets2.prototype.updateOnChange = function(delta) {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) {
            } else if (delta.action == "remove") {
              var removed = lineWidgets.splice(startRow + 1, len);
              if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                lineWidgets[startRow] = removed.pop();
              }
              removed.forEach(function(w) {
                w && this.removeLineWidget(w);
              }, this);
              this.$updateRows();
            } else {
              var args = new Array(len);
              if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                if (delta.start.column > lineWidgets[startRow].column)
                  startRow++;
              }
              args.unshift(startRow, 0);
              lineWidgets.splice.apply(lineWidgets, args);
              this.$updateRows();
            }
          };
          LineWidgets2.prototype.$updateRows = function() {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var noWidgets = true;
            lineWidgets.forEach(function(w, i) {
              if (w) {
                noWidgets = false;
                w.row = i;
                while (w.$oldWidget) {
                  w.$oldWidget.row = i;
                  w = w.$oldWidget;
                }
              }
            });
            if (noWidgets)
              this.session.lineWidgets = null;
          };
          LineWidgets2.prototype.$registerLineWidget = function(w) {
            if (!this.session.lineWidgets)
              this.session.lineWidgets = new Array(this.session.getLength());
            var old = this.session.lineWidgets[w.row];
            if (old) {
              w.$oldWidget = old;
              if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
              }
            }
            this.session.lineWidgets[w.row] = w;
            return w;
          };
          LineWidgets2.prototype.addLineWidget = function(w) {
            this.$registerLineWidget(w);
            w.session = this.session;
            if (!this.editor)
              return w;
            var renderer = this.editor.renderer;
            if (w.html && !w.el) {
              w.el = dom.createElement("div");
              w.el.innerHTML = w.html;
            }
            if (w.text && !w.el) {
              w.el = dom.createElement("div");
              w.el.textContent = w.text;
            }
            if (w.el) {
              dom.addCssClass(w.el, "ace_lineWidgetContainer");
              if (w.className) {
                dom.addCssClass(w.el, w.className);
              }
              w.el.style.position = "absolute";
              w.el.style.zIndex = "5";
              renderer.container.appendChild(w.el);
              w._inDocument = true;
              if (!w.coverGutter) {
                w.el.style.zIndex = "3";
              }
              if (w.pixelHeight == null) {
                w.pixelHeight = w.el.offsetHeight;
              }
            }
            if (w.rowCount == null) {
              w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
            }
            var fold2 = this.session.getFoldAt(w.row, 0);
            w.$fold = fold2;
            if (fold2) {
              var lineWidgets = this.session.lineWidgets;
              if (w.row == fold2.end.row && !lineWidgets[fold2.start.row])
                lineWidgets[fold2.start.row] = w;
              else
                w.hidden = true;
            }
            this.session._emit("changeFold", { data: { start: { row: w.row } } });
            this.$updateRows();
            this.renderWidgets(null, renderer);
            this.onWidgetChanged(w);
            return w;
          };
          LineWidgets2.prototype.removeLineWidget = function(w) {
            w._inDocument = false;
            w.session = null;
            if (w.el && w.el.parentNode)
              w.el.parentNode.removeChild(w.el);
            if (w.editor && w.editor.destroy)
              try {
                w.editor.destroy();
              } catch (e75) {
              }
            if (this.session.lineWidgets) {
              var w1 = this.session.lineWidgets[w.row];
              if (w1 == w) {
                this.session.lineWidgets[w.row] = w.$oldWidget;
                if (w.$oldWidget)
                  this.onWidgetChanged(w.$oldWidget);
              } else {
                while (w1) {
                  if (w1.$oldWidget == w) {
                    w1.$oldWidget = w.$oldWidget;
                    break;
                  }
                  w1 = w1.$oldWidget;
                }
              }
            }
            this.session._emit("changeFold", { data: { start: { row: w.row } } });
            this.$updateRows();
          };
          LineWidgets2.prototype.getWidgetsAtRow = function(row) {
            var lineWidgets = this.session.lineWidgets;
            var w = lineWidgets && lineWidgets[row];
            var list = [];
            while (w) {
              list.push(w);
              w = w.$oldWidget;
            }
            return list;
          };
          LineWidgets2.prototype.onWidgetChanged = function(w) {
            this.session._changedWidgets.push(w);
            this.editor && this.editor.renderer.updateFull();
          };
          LineWidgets2.prototype.measureWidgets = function(e75, renderer) {
            var changedWidgets = this.session._changedWidgets;
            var config2 = renderer.layerConfig;
            if (!changedWidgets || !changedWidgets.length)
              return;
            var min = Infinity;
            for (var i = 0; i < changedWidgets.length; i++) {
              var w = changedWidgets[i];
              if (!w || !w.el)
                continue;
              if (w.session != this.session)
                continue;
              if (!w._inDocument) {
                if (this.session.lineWidgets[w.row] != w)
                  continue;
                w._inDocument = true;
                renderer.container.appendChild(w.el);
              }
              w.h = w.el.offsetHeight;
              if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config2.characterWidth);
              }
              var rowCount = w.h / config2.lineHeight;
              if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                  rowCount = 0;
              }
              if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                  min = w.row;
              }
            }
            if (min != Infinity) {
              this.session._emit("changeFold", { data: { start: { row: min } } });
              this.session.lineWidgetWidth = null;
            }
            this.session._changedWidgets = [];
          };
          LineWidgets2.prototype.renderWidgets = function(e75, renderer) {
            var config2 = renderer.layerConfig;
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var first = Math.min(this.firstRow, config2.firstRow);
            var last = Math.max(this.lastRow, config2.lastRow, lineWidgets.length);
            while (first > 0 && !lineWidgets[first])
              first--;
            this.firstRow = config2.firstRow;
            this.lastRow = config2.lastRow;
            renderer.$cursorLayer.config = config2;
            for (var i = first; i <= last; i++) {
              var w = lineWidgets[i];
              if (!w || !w.el)
                continue;
              if (w.hidden) {
                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                continue;
              }
              if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
              }
              var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
              if (!w.coverLine)
                top += config2.lineHeight * this.session.getRowLineCount(w.row);
              w.el.style.top = top - config2.offset + "px";
              var left = w.coverGutter ? 0 : renderer.gutterWidth;
              if (!w.fixedWidth)
                left -= renderer.scrollLeft;
              w.el.style.left = left + "px";
              if (w.fullWidth && w.screenWidth) {
                w.el.style.minWidth = config2.width + 2 * config2.padding + "px";
              }
              if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
              } else {
                w.el.style.right = "";
              }
            }
          };
          return LineWidgets2;
        }()
      );
      exports2.LineWidgets = LineWidgets;
    });
    ace.define("ace/apply_delta", ["require", "exports", "module"], function(require2, exports2, module2) {
      "use strict";
      function throwDeltaError(delta, errorText) {
        console.log("Invalid Delta:", delta);
        throw "Invalid Delta: " + errorText;
      }
      function positionInDocument(docLines, position2) {
        return position2.row >= 0 && position2.row < docLines.length && position2.column >= 0 && position2.column <= docLines[position2.row].length;
      }
      function validateDelta(docLines, delta) {
        if (delta.action != "insert" && delta.action != "remove")
          throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
        if (!(delta.lines instanceof Array))
          throwDeltaError(delta, "delta.lines must be an Array");
        if (!delta.start || !delta.end)
          throwDeltaError(delta, "delta.start/end must be an present");
        var start = delta.start;
        if (!positionInDocument(docLines, delta.start))
          throwDeltaError(delta, "delta.start must be contained in document");
        var end = delta.end;
        if (delta.action == "remove" && !positionInDocument(docLines, end))
          throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
        var numRangeRows = end.row - start.row;
        var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
        if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
          throwDeltaError(delta, "delta.range must match delta lines");
      }
      exports2.applyDelta = function(docLines, delta, doNotValidate) {
        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch (delta.action) {
          case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
              docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
              var args = [row, 1].concat(delta.lines);
              docLines.splice.apply(docLines, args);
              docLines[row] = line.substring(0, startColumn) + docLines[row];
              docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
          case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
              docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
              docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
        }
      };
    });
    ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Anchor = (
        /** @class */
        function() {
          function Anchor2(doc2, row, column) {
            this.$onChange = this.onChange.bind(this);
            this.attach(doc2);
            if (typeof row != "number")
              this.setPosition(row.row, row.column);
            else
              this.setPosition(row, column);
          }
          Anchor2.prototype.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
          };
          Anchor2.prototype.getDocument = function() {
            return this.document;
          };
          Anchor2.prototype.onChange = function(delta) {
            if (delta.start.row == delta.end.row && delta.start.row != this.row)
              return;
            if (delta.start.row > this.row)
              return;
            var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
            this.setPosition(point.row, point.column, true);
          };
          Anchor2.prototype.setPosition = function(row, column, noClip) {
            var pos;
            if (noClip) {
              pos = {
                row,
                column
              };
            } else {
              pos = this.$clipPositionToDocument(row, column);
            }
            if (this.row == pos.row && this.column == pos.column)
              return;
            var old = {
              row: this.row,
              column: this.column
            };
            this.row = pos.row;
            this.column = pos.column;
            this._signal("change", {
              old,
              value: pos
            });
          };
          Anchor2.prototype.detach = function() {
            this.document.off("change", this.$onChange);
          };
          Anchor2.prototype.attach = function(doc2) {
            this.document = doc2 || this.document;
            this.document.on("change", this.$onChange);
          };
          Anchor2.prototype.$clipPositionToDocument = function(row, column) {
            var pos = {};
            if (row >= this.document.getLength()) {
              pos.row = Math.max(0, this.document.getLength() - 1);
              pos.column = this.document.getLine(pos.row).length;
            } else if (row < 0) {
              pos.row = 0;
              pos.column = 0;
            } else {
              pos.row = row;
              pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
            }
            if (column < 0)
              pos.column = 0;
            return pos;
          };
          return Anchor2;
        }()
      );
      Anchor.prototype.$insertRight = false;
      oop.implement(Anchor.prototype, EventEmitter);
      function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
      }
      function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end;
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
          return {
            row: point.row,
            column: point.column
          };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
          return {
            row: point.row + deltaRowShift,
            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
          };
        }
        return {
          row: deltaStart.row,
          column: deltaStart.column
        };
      }
      exports2.Anchor = Anchor;
    });
    ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var applyDelta = require2("./apply_delta").applyDelta;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Range2 = require2("./range").Range;
      var Anchor = require2("./anchor").Anchor;
      var Document = (
        /** @class */
        function() {
          function Document2(textOrLines) {
            this.$lines = [""];
            if (textOrLines.length === 0) {
              this.$lines = [""];
            } else if (Array.isArray(textOrLines)) {
              this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
            } else {
              this.insert({ row: 0, column: 0 }, textOrLines);
            }
          }
          Document2.prototype.setValue = function(text) {
            var len = this.getLength() - 1;
            this.remove(new Range2(0, 0, len, this.getLine(len).length));
            this.insert({ row: 0, column: 0 }, text || "");
          };
          Document2.prototype.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
          };
          Document2.prototype.createAnchor = function(row, column) {
            return new Anchor(this, row, column);
          };
          Document2.prototype.$detectNewLine = function(text) {
            var match2 = text.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = match2 ? match2[1] : "\n";
            this._signal("changeNewLineMode");
          };
          Document2.prototype.getNewLineCharacter = function() {
            switch (this.$newLineMode) {
              case "windows":
                return "\r\n";
              case "unix":
                return "\n";
              default:
                return this.$autoNewLine || "\n";
            }
          };
          Document2.prototype.setNewLineMode = function(newLineMode) {
            if (this.$newLineMode === newLineMode)
              return;
            this.$newLineMode = newLineMode;
            this._signal("changeNewLineMode");
          };
          Document2.prototype.getNewLineMode = function() {
            return this.$newLineMode;
          };
          Document2.prototype.isNewLine = function(text) {
            return text == "\r\n" || text == "\r" || text == "\n";
          };
          Document2.prototype.getLine = function(row) {
            return this.$lines[row] || "";
          };
          Document2.prototype.getLines = function(firstRow, lastRow) {
            return this.$lines.slice(firstRow, lastRow + 1);
          };
          Document2.prototype.getAllLines = function() {
            return this.getLines(0, this.getLength());
          };
          Document2.prototype.getLength = function() {
            return this.$lines.length;
          };
          Document2.prototype.getTextRange = function(range) {
            return this.getLinesForRange(range).join(this.getNewLineCharacter());
          };
          Document2.prototype.getLinesForRange = function(range) {
            var lines;
            if (range.start.row === range.end.row) {
              lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
            } else {
              lines = this.getLines(range.start.row, range.end.row);
              lines[0] = (lines[0] || "").substring(range.start.column);
              var l = lines.length - 1;
              if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
            }
            return lines;
          };
          Document2.prototype.insertLines = function(row, lines) {
            console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
            return this.insertFullLines(row, lines);
          };
          Document2.prototype.removeLines = function(firstRow, lastRow) {
            console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
            return this.removeFullLines(firstRow, lastRow);
          };
          Document2.prototype.insertNewLine = function(position2) {
            console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
            return this.insertMergedLines(position2, ["", ""]);
          };
          Document2.prototype.insert = function(position2, text) {
            if (this.getLength() <= 1)
              this.$detectNewLine(text);
            return this.insertMergedLines(position2, this.$split(text));
          };
          Document2.prototype.insertInLine = function(position2, text) {
            var start = this.clippedPos(position2.row, position2.column);
            var end = this.pos(position2.row, position2.column + text.length);
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines: [text]
            }, true);
            return this.clonePos(end);
          };
          Document2.prototype.clippedPos = function(row, column) {
            var length = this.getLength();
            if (row === void 0) {
              row = length;
            } else if (row < 0) {
              row = 0;
            } else if (row >= length) {
              row = length - 1;
              column = void 0;
            }
            var line = this.getLine(row);
            if (column == void 0)
              column = line.length;
            column = Math.min(Math.max(column, 0), line.length);
            return { row, column };
          };
          Document2.prototype.clonePos = function(pos) {
            return { row: pos.row, column: pos.column };
          };
          Document2.prototype.pos = function(row, column) {
            return { row, column };
          };
          Document2.prototype.$clipPosition = function(position2) {
            var length = this.getLength();
            if (position2.row >= length) {
              position2.row = Math.max(0, length - 1);
              position2.column = this.getLine(length - 1).length;
            } else {
              position2.row = Math.max(0, position2.row);
              position2.column = Math.min(Math.max(position2.column, 0), this.getLine(position2.row).length);
            }
            return position2;
          };
          Document2.prototype.insertFullLines = function(row, lines) {
            row = Math.min(Math.max(row, 0), this.getLength());
            var column = 0;
            if (row < this.getLength()) {
              lines = lines.concat([""]);
              column = 0;
            } else {
              lines = [""].concat(lines);
              row--;
              column = this.$lines[row].length;
            }
            this.insertMergedLines({ row, column }, lines);
          };
          Document2.prototype.insertMergedLines = function(position2, lines) {
            var start = this.clippedPos(position2.row, position2.column);
            var end = {
              row: start.row + lines.length - 1,
              column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
            };
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines
            });
            return this.clonePos(end);
          };
          Document2.prototype.remove = function(range) {
            var start = this.clippedPos(range.start.row, range.start.column);
            var end = this.clippedPos(range.end.row, range.end.column);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            });
            return this.clonePos(start);
          };
          Document2.prototype.removeInLine = function(row, startColumn, endColumn) {
            var start = this.clippedPos(row, startColumn);
            var end = this.clippedPos(row, endColumn);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            }, true);
            return this.clonePos(start);
          };
          Document2.prototype.removeFullLines = function(firstRow, lastRow) {
            firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
            lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
            var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
            var deleteLastNewLine = lastRow < this.getLength() - 1;
            var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
            var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
            var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
            var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
            var range = new Range2(startRow, startCol, endRow, endCol);
            var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
            this.applyDelta({
              start: range.start,
              end: range.end,
              action: "remove",
              lines: this.getLinesForRange(range)
            });
            return deletedLines;
          };
          Document2.prototype.removeNewLine = function(row) {
            if (row < this.getLength() - 1 && row >= 0) {
              this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
              });
            }
          };
          Document2.prototype.replace = function(range, text) {
            if (!(range instanceof Range2))
              range = Range2.fromPoints(range.start, range.end);
            if (text.length === 0 && range.isEmpty())
              return range.start;
            if (text == this.getTextRange(range))
              return range.end;
            this.remove(range);
            var end;
            if (text) {
              end = this.insert(range.start, text);
            } else {
              end = range.start;
            }
            return end;
          };
          Document2.prototype.applyDeltas = function(deltas) {
            for (var i = 0; i < deltas.length; i++) {
              this.applyDelta(deltas[i]);
            }
          };
          Document2.prototype.revertDeltas = function(deltas) {
            for (var i = deltas.length - 1; i >= 0; i--) {
              this.revertDelta(deltas[i]);
            }
          };
          Document2.prototype.applyDelta = function(delta, doNotValidate) {
            var isInsert = delta.action == "insert";
            if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range2.comparePoints(delta.start, delta.end)) {
              return;
            }
            if (isInsert && delta.lines.length > 2e4) {
              this.$splitAndapplyLargeDelta(delta, 2e4);
            } else {
              applyDelta(this.$lines, delta, doNotValidate);
              this._signal("change", delta);
            }
          };
          Document2.prototype.$safeApplyDelta = function(delta) {
            var docLength = this.$lines.length;
            if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength || delta.action == "insert" && delta.start.row <= docLength) {
              this.applyDelta(delta);
            }
          };
          Document2.prototype.$splitAndapplyLargeDelta = function(delta, MAX) {
            var lines = delta.lines;
            var l = lines.length - MAX + 1;
            var row = delta.start.row;
            var column = delta.start.column;
            for (var from = 0, to = 0; from < l; from = to) {
              to += MAX - 1;
              var chunk = lines.slice(from, to);
              chunk.push("");
              this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
              }, true);
            }
            delta.lines = lines.slice(from);
            delta.start.row = row + from;
            delta.start.column = column;
            this.applyDelta(delta, true);
          };
          Document2.prototype.revertDelta = function(delta) {
            this.$safeApplyDelta({
              start: this.clonePos(delta.start),
              end: this.clonePos(delta.end),
              action: delta.action == "insert" ? "remove" : "insert",
              lines: delta.lines.slice()
            });
          };
          Document2.prototype.indexToPosition = function(index, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            for (var i = startRow || 0, l = lines.length; i < l; i++) {
              index -= lines[i].length + newlineLength;
              if (index < 0)
                return { row: i, column: index + lines[i].length + newlineLength };
            }
            return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
          };
          Document2.prototype.positionToIndex = function(pos, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            var index = 0;
            var row = Math.min(pos.row, lines.length);
            for (var i = startRow || 0; i < row; ++i)
              index += lines[i].length + newlineLength;
            return index + pos.column;
          };
          Document2.prototype.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
          };
          return Document2;
        }()
      );
      Document.prototype.$autoNewLine = "";
      Document.prototype.$newLineMode = "auto";
      oop.implement(Document.prototype, EventEmitter);
      exports2.Document = Document;
    });
    ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var BackgroundTokenizer = (
        /** @class */
        function() {
          function BackgroundTokenizer2(tokenizer, session) {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.tokenizer = tokenizer;
            var self2 = this;
            this.$worker = function() {
              if (!self2.running) {
                return;
              }
              var workerStart = /* @__PURE__ */ new Date();
              var currentLine = self2.currentLine;
              var endLine = -1;
              var doc2 = self2.doc;
              var startLine = currentLine;
              while (self2.lines[currentLine])
                currentLine++;
              var len = doc2.getLength();
              var processedLines = 0;
              self2.running = false;
              while (currentLine < len) {
                self2.$tokenizeRow(currentLine);
                endLine = currentLine;
                do {
                  currentLine++;
                } while (self2.lines[currentLine]);
                processedLines++;
                if (processedLines % 5 === 0 && /* @__PURE__ */ new Date() - workerStart > 20) {
                  self2.running = setTimeout(self2.$worker, 20);
                  break;
                }
              }
              self2.currentLine = currentLine;
              if (endLine == -1)
                endLine = currentLine;
              if (startLine <= endLine)
                self2.fireUpdateEvent(startLine, endLine);
            };
          }
          BackgroundTokenizer2.prototype.setTokenizer = function(tokenizer) {
            this.tokenizer = tokenizer;
            this.lines = [];
            this.states = [];
            this.start(0);
          };
          BackgroundTokenizer2.prototype.setDocument = function(doc2) {
            this.doc = doc2;
            this.lines = [];
            this.states = [];
            this.stop();
          };
          BackgroundTokenizer2.prototype.fireUpdateEvent = function(firstRow, lastRow) {
            var data = {
              first: firstRow,
              last: lastRow
            };
            this._signal("update", { data });
          };
          BackgroundTokenizer2.prototype.start = function(startRow) {
            this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
            this.lines.splice(this.currentLine, this.lines.length);
            this.states.splice(this.currentLine, this.states.length);
            this.stop();
            this.running = setTimeout(this.$worker, 700);
          };
          BackgroundTokenizer2.prototype.scheduleStart = function() {
            if (!this.running)
              this.running = setTimeout(this.$worker, 700);
          };
          BackgroundTokenizer2.prototype.$updateOnChange = function(delta) {
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) {
              this.lines[startRow] = null;
            } else if (delta.action == "remove") {
              this.lines.splice(startRow, len + 1, null);
              this.states.splice(startRow, len + 1, null);
            } else {
              var args = Array(len + 1);
              args.unshift(startRow, 1);
              this.lines.splice.apply(this.lines, args);
              this.states.splice.apply(this.states, args);
            }
            this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
            this.stop();
          };
          BackgroundTokenizer2.prototype.stop = function() {
            if (this.running)
              clearTimeout(this.running);
            this.running = false;
          };
          BackgroundTokenizer2.prototype.getTokens = function(row) {
            return this.lines[row] || this.$tokenizeRow(row);
          };
          BackgroundTokenizer2.prototype.getState = function(row) {
            if (this.currentLine == row)
              this.$tokenizeRow(row);
            return this.states[row] || "start";
          };
          BackgroundTokenizer2.prototype.$tokenizeRow = function(row) {
            var line = this.doc.getLine(row);
            var state = this.states[row - 1];
            var data = this.tokenizer.getLineTokens(line, state, row);
            if (this.states[row] + "" !== data.state + "") {
              this.states[row] = data.state;
              this.lines[row + 1] = null;
              if (this.currentLine > row + 1)
                this.currentLine = row + 1;
            } else if (this.currentLine == row) {
              this.currentLine = row + 1;
            }
            return this.lines[row] = data.tokens;
          };
          BackgroundTokenizer2.prototype.cleanup = function() {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.removeAllListeners();
          };
          return BackgroundTokenizer2;
        }()
      );
      oop.implement(BackgroundTokenizer.prototype, EventEmitter);
      exports2.BackgroundTokenizer = BackgroundTokenizer;
    });
    ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var lang = require2("./lib/lang");
      var Range2 = require2("./range").Range;
      var SearchHighlight = (
        /** @class */
        function() {
          function SearchHighlight2(regExp, clazz, type2) {
            if (type2 === void 0) {
              type2 = "text";
            }
            this.setRegexp(regExp);
            this.clazz = clazz;
            this.type = type2;
            this.docLen = 0;
          }
          SearchHighlight2.prototype.setRegexp = function(regExp) {
            if (this.regExp + "" == regExp + "")
              return;
            this.regExp = regExp;
            this.cache = [];
          };
          SearchHighlight2.prototype.update = function(html, markerLayer, session, config2) {
            if (!this.regExp)
              return;
            var start = config2.firstRow;
            var end = config2.lastRow;
            var renderedMarkerRanges = {};
            var _search = session.$editor && session.$editor.$search;
            var mtSearch = _search && _search.$isMultilineSearch(session.$editor.getLastSearchOptions());
            for (var i = start; i <= end; i++) {
              var ranges = this.cache[i];
              if (ranges == null || session.getValue().length != this.docLen) {
                if (mtSearch) {
                  ranges = [];
                  var match2 = _search.$multiLineForward(session, this.regExp, i, end);
                  if (match2) {
                    var end_row = match2.endRow <= end ? match2.endRow - 1 : end;
                    if (end_row > i)
                      i = end_row;
                    ranges.push(new Range2(match2.startRow, match2.startCol, match2.endRow, match2.endCol));
                  }
                  if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                } else {
                  ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                  if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                  ranges = ranges.map(function(match3) {
                    return new Range2(i, match3.offset, i, match3.offset + match3.length);
                  });
                }
                this.cache[i] = ranges.length ? ranges : "";
              }
              if (ranges.length === 0)
                continue;
              for (var j = ranges.length; j--; ) {
                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
                var rangeAsString = rangeToAddMarkerTo.toString();
                if (renderedMarkerRanges[rangeAsString])
                  continue;
                renderedMarkerRanges[rangeAsString] = true;
                markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config2);
              }
            }
            this.docLen = session.getValue().length;
          };
          return SearchHighlight2;
        }()
      );
      SearchHighlight.prototype.MAX_RANGES = 500;
      exports2.SearchHighlight = SearchHighlight;
    });
    ace.define("ace/undomanager", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var UndoManager = (
        /** @class */
        function() {
          function UndoManager2() {
            this.$keepRedoStack;
            this.$maxRev = 0;
            this.$fromUndo = false;
            this.$undoDepth = Infinity;
            this.reset();
          }
          UndoManager2.prototype.addSession = function(session) {
            this.$session = session;
          };
          UndoManager2.prototype.add = function(delta, allowMerge, session) {
            if (this.$fromUndo)
              return;
            if (delta == this.$lastDelta)
              return;
            if (!this.$keepRedoStack)
              this.$redoStack.length = 0;
            if (allowMerge === false || !this.lastDeltas) {
              this.lastDeltas = [];
              var undoStackLength = this.$undoStack.length;
              if (undoStackLength > this.$undoDepth - 1) {
                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
              }
              this.$undoStack.push(this.lastDeltas);
              delta.id = this.$rev = ++this.$maxRev;
            }
            if (delta.action == "remove" || delta.action == "insert")
              this.$lastDelta = delta;
            this.lastDeltas.push(delta);
          };
          UndoManager2.prototype.addSelection = function(selection, rev) {
            this.selections.push({
              value: selection,
              rev: rev || this.$rev
            });
          };
          UndoManager2.prototype.startNewGroup = function() {
            this.lastDeltas = null;
            return this.$rev;
          };
          UndoManager2.prototype.markIgnored = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
            var stack = this.$undoStack;
            for (var i = stack.length; i--; ) {
              var delta = stack[i][0];
              if (delta.id <= from)
                break;
              if (delta.id < to)
                delta.ignore = true;
            }
            this.lastDeltas = null;
          };
          UndoManager2.prototype.getSelection = function(rev, after) {
            var stack = this.selections;
            for (var i = stack.length; i--; ) {
              var selection = stack[i];
              if (selection.rev < rev) {
                if (after)
                  selection = stack[i + 1];
                return selection;
              }
            }
          };
          UndoManager2.prototype.getRevision = function() {
            return this.$rev;
          };
          UndoManager2.prototype.getDeltas = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
            var stack = this.$undoStack;
            var end = null, start = 0;
            for (var i = stack.length; i--; ) {
              var delta = stack[i][0];
              if (delta.id < to && !end)
                end = i + 1;
              if (delta.id <= from) {
                start = i + 1;
                break;
              }
            }
            return stack.slice(start, end);
          };
          UndoManager2.prototype.getChangedRanges = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
          };
          UndoManager2.prototype.getChangedLines = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
          };
          UndoManager2.prototype.undo = function(session, dontSelect) {
            this.lastDeltas = null;
            var stack = this.$undoStack;
            if (!rearrangeUndoStack(stack, stack.length))
              return;
            if (!session)
              session = this.$session;
            if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
              this.$redoStack = [];
            this.$fromUndo = true;
            var deltaSet = stack.pop();
            var undoSelectionRange = null;
            if (deltaSet) {
              undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
              this.$redoStack.push(deltaSet);
              this.$syncRev();
            }
            this.$fromUndo = false;
            return undoSelectionRange;
          };
          UndoManager2.prototype.redo = function(session, dontSelect) {
            this.lastDeltas = null;
            if (!session)
              session = this.$session;
            this.$fromUndo = true;
            if (this.$redoStackBaseRev != this.$rev) {
              var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
              rebaseRedoStack(this.$redoStack, diff);
              this.$redoStackBaseRev = this.$rev;
              this.$redoStack.forEach(function(x) {
                x[0].id = ++this.$maxRev;
              }, this);
            }
            var deltaSet = this.$redoStack.pop();
            var redoSelectionRange = null;
            if (deltaSet) {
              redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
              this.$undoStack.push(deltaSet);
              this.$syncRev();
            }
            this.$fromUndo = false;
            return redoSelectionRange;
          };
          UndoManager2.prototype.$syncRev = function() {
            var stack = this.$undoStack;
            var nextDelta = stack[stack.length - 1];
            var id = nextDelta && nextDelta[0].id || 0;
            this.$redoStackBaseRev = id;
            this.$rev = id;
          };
          UndoManager2.prototype.reset = function() {
            this.lastDeltas = null;
            this.$lastDelta = null;
            this.$undoStack = [];
            this.$redoStack = [];
            this.$rev = 0;
            this.mark = 0;
            this.$redoStackBaseRev = this.$rev;
            this.selections = [];
          };
          UndoManager2.prototype.canUndo = function() {
            return this.$undoStack.length > 0;
          };
          UndoManager2.prototype.canRedo = function() {
            return this.$redoStack.length > 0;
          };
          UndoManager2.prototype.bookmark = function(rev) {
            if (rev == void 0)
              rev = this.$rev;
            this.mark = rev;
          };
          UndoManager2.prototype.isAtBookmark = function() {
            return this.$rev === this.mark;
          };
          UndoManager2.prototype.toJSON = function() {
            return {
              $redoStack: this.$redoStack,
              $undoStack: this.$undoStack
            };
          };
          UndoManager2.prototype.fromJSON = function(json) {
            this.reset();
            this.$undoStack = json.$undoStack;
            this.$redoStack = json.$redoStack;
          };
          UndoManager2.prototype.$prettyPrint = function(delta) {
            if (delta)
              return stringifyDelta(delta);
            return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
          };
          return UndoManager2;
        }()
      );
      UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
      UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
      UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
      UndoManager.prototype.markClean = UndoManager.prototype.bookmark;
      function rearrangeUndoStack(stack, pos) {
        for (var i = pos; i--; ) {
          var deltaSet = stack[i];
          if (deltaSet && !deltaSet[0].ignore) {
            while (i < pos - 1) {
              var swapped = swapGroups(stack[i], stack[i + 1]);
              stack[i] = swapped[0];
              stack[i + 1] = swapped[1];
              i++;
            }
            return true;
          }
        }
      }
      var Range2 = require2("./range").Range;
      var cmp = Range2.comparePoints;
      var comparePoints = Range2.comparePoints;
      function $updateMarkers(delta) {
        var isInsert = delta.action == "insert";
        var start = delta.start;
        var end = delta.end;
        var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
        var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
        if (isInsert)
          end = start;
        for (var i in this.marks) {
          var point = this.marks[i];
          var cmp2 = comparePoints(point, start);
          if (cmp2 < 0) {
            continue;
          }
          if (cmp2 === 0) {
            if (isInsert) {
              if (point.bias == 1) {
                cmp2 = 1;
              } else {
                point.bias == -1;
                continue;
              }
            }
          }
          var cmp22 = isInsert ? cmp2 : comparePoints(point, end);
          if (cmp22 > 0) {
            point.row += rowShift;
            point.column += point.row == end.row ? colShift : 0;
            continue;
          }
          if (!isInsert && cmp22 <= 0) {
            point.row = start.row;
            point.column = start.column;
            if (cmp22 === 0)
              point.bias = 1;
          }
        }
      }
      function clonePos(pos) {
        return { row: pos.row, column: pos.column };
      }
      function cloneDelta(d) {
        return {
          start: clonePos(d.start),
          end: clonePos(d.end),
          action: d.action,
          lines: d.lines.slice()
        };
      }
      function stringifyDelta(d) {
        d = d || this;
        if (Array.isArray(d)) {
          return d.map(stringifyDelta).join("\n");
        }
        var type2 = "";
        if (d.action) {
          type2 = d.action == "insert" ? "+" : "-";
          type2 += "[" + d.lines + "]";
        } else if (d.value) {
          if (Array.isArray(d.value)) {
            type2 = d.value.map(stringifyRange).join("\n");
          } else {
            type2 = stringifyRange(d.value);
          }
        }
        if (d.start) {
          type2 += stringifyRange(d);
        }
        if (d.id || d.rev) {
          type2 += "	(" + (d.id || d.rev) + ")";
        }
        return type2;
      }
      function stringifyRange(r) {
        return r.start.row + ":" + r.start.column + "=>" + r.end.row + ":" + r.end.column;
      }
      function swap(d1, d2) {
        var i1 = d1.action == "insert";
        var i2 = d2.action == "insert";
        if (i1 && i2) {
          if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
          } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, 1);
          } else {
            return null;
          }
        } else if (i1 && !i2) {
          if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
          } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
          } else {
            return null;
          }
        } else if (!i1 && i2) {
          if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, 1);
          } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, 1);
          } else {
            return null;
          }
        } else if (!i1 && !i2) {
          if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, 1);
          } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
          } else {
            return null;
          }
        }
        return [d2, d1];
      }
      function swapGroups(ds1, ds2) {
        for (var i = ds1.length; i--; ) {
          for (var j = 0; j < ds2.length; j++) {
            if (!swap(ds1[i], ds2[j])) {
              while (i < ds1.length) {
                while (j--) {
                  swap(ds2[j], ds1[i]);
                }
                j = ds2.length;
                i++;
              }
              return [ds1, ds2];
            }
          }
        }
        ds1.selectionBefore = ds2.selectionBefore = ds1.selectionAfter = ds2.selectionAfter = null;
        return [ds2, ds1];
      }
      function xform(d1, c1) {
        var i1 = d1.action == "insert";
        var i2 = c1.action == "insert";
        if (i1 && i2) {
          if (cmp(d1.start, c1.start) < 0) {
            shift(c1, d1, 1);
          } else {
            shift(d1, c1, 1);
          }
        } else if (i1 && !i2) {
          if (cmp(d1.start, c1.end) >= 0) {
            shift(d1, c1, -1);
          } else if (cmp(d1.start, c1.start) <= 0) {
            shift(c1, d1, 1);
          } else {
            shift(d1, Range2.fromPoints(c1.start, d1.start), -1);
            shift(c1, d1, 1);
          }
        } else if (!i1 && i2) {
          if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
          } else if (cmp(c1.start, d1.start) <= 0) {
            shift(d1, c1, 1);
          } else {
            shift(c1, Range2.fromPoints(d1.start, c1.start), -1);
            shift(d1, c1, 1);
          }
        } else if (!i1 && !i2) {
          if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
          } else if (cmp(c1.end, d1.start) <= 0) {
            shift(d1, c1, -1);
          } else {
            var before, after;
            if (cmp(d1.start, c1.start) < 0) {
              before = d1;
              d1 = splitDelta(d1, c1.start);
            }
            if (cmp(d1.end, c1.end) > 0) {
              after = splitDelta(d1, c1.end);
            }
            shiftPos(c1.end, d1.start, d1.end, -1);
            if (after && !before) {
              d1.lines = after.lines;
              d1.start = after.start;
              d1.end = after.end;
              after = d1;
            }
            return [c1, before, after].filter(Boolean);
          }
        }
        return [c1, d1];
      }
      function shift(d1, d2, dir) {
        shiftPos(d1.start, d2.start, d2.end, dir);
        shiftPos(d1.end, d2.start, d2.end, dir);
      }
      function shiftPos(pos, start, end, dir) {
        if (pos.row == (dir == 1 ? start : end).row) {
          pos.column += dir * (end.column - start.column);
        }
        pos.row += dir * (end.row - start.row);
      }
      function splitDelta(c, pos) {
        var lines = c.lines;
        var end = c.end;
        c.end = clonePos(pos);
        var rowsBefore = c.end.row - c.start.row;
        var otherLines = lines.splice(rowsBefore, lines.length);
        var col = rowsBefore ? pos.column : pos.column - c.start.column;
        lines.push(otherLines[0].substring(0, col));
        otherLines[0] = otherLines[0].substr(col);
        var rest = {
          start: clonePos(pos),
          end,
          lines: otherLines,
          action: c.action
        };
        return rest;
      }
      function moveDeltasByOne(redoStack, d) {
        d = cloneDelta(d);
        for (var j = redoStack.length; j--; ) {
          var deltaSet = redoStack[j];
          for (var i = 0; i < deltaSet.length; i++) {
            var x = deltaSet[i];
            var xformed = xform(x, d);
            d = xformed[0];
            if (xformed.length != 2) {
              if (xformed[2]) {
                deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                i++;
              } else if (!xformed[1]) {
                deltaSet.splice(i, 1);
                i--;
              }
            }
          }
          if (!deltaSet.length) {
            redoStack.splice(j, 1);
          }
        }
        return redoStack;
      }
      function rebaseRedoStack(redoStack, deltaSets) {
        for (var i = 0; i < deltaSets.length; i++) {
          var deltas = deltaSets[i];
          for (var j = 0; j < deltas.length; j++) {
            moveDeltasByOne(redoStack, deltas[j]);
          }
        }
      }
      exports2.UndoManager = UndoManager;
    });
    ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var Range2 = require2("../range").Range;
      var FoldLine = (
        /** @class */
        function() {
          function FoldLine2(foldData, folds) {
            this.foldData = foldData;
            if (Array.isArray(folds)) {
              this.folds = folds;
            } else {
              folds = this.folds = [folds];
            }
            var last = folds[folds.length - 1];
            this.range = new Range2(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
            this.start = this.range.start;
            this.end = this.range.end;
            this.folds.forEach(function(fold2) {
              fold2.setFoldLine(this);
            }, this);
          }
          FoldLine2.prototype.shiftRow = function(shift) {
            this.start.row += shift;
            this.end.row += shift;
            this.folds.forEach(function(fold2) {
              fold2.start.row += shift;
              fold2.end.row += shift;
            });
          };
          FoldLine2.prototype.addFold = function(fold2) {
            if (fold2.sameRow) {
              if (fold2.start.row < this.startRow || fold2.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
              }
              this.folds.push(fold2);
              this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
              });
              if (this.range.compareEnd(fold2.start.row, fold2.start.column) > 0) {
                this.end.row = fold2.end.row;
                this.end.column = fold2.end.column;
              } else if (this.range.compareStart(fold2.end.row, fold2.end.column) < 0) {
                this.start.row = fold2.start.row;
                this.start.column = fold2.start.column;
              }
            } else if (fold2.start.row == this.end.row) {
              this.folds.push(fold2);
              this.end.row = fold2.end.row;
              this.end.column = fold2.end.column;
            } else if (fold2.end.row == this.start.row) {
              this.folds.unshift(fold2);
              this.start.row = fold2.start.row;
              this.start.column = fold2.start.column;
            } else {
              throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
            }
            fold2.foldLine = this;
          };
          FoldLine2.prototype.containsRow = function(row) {
            return row >= this.start.row && row <= this.end.row;
          };
          FoldLine2.prototype.walk = function(callback, endRow, endColumn) {
            var lastEnd = 0, folds = this.folds, fold2, cmp, stop, isNewRow = true;
            if (endRow == null) {
              endRow = this.end.row;
              endColumn = this.end.column;
            }
            for (var i = 0; i < folds.length; i++) {
              fold2 = folds[i];
              cmp = fold2.range.compareStart(endRow, endColumn);
              if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
              }
              stop = callback(null, fold2.start.row, fold2.start.column, lastEnd, isNewRow);
              stop = !stop && callback(fold2.placeholder, fold2.start.row, fold2.start.column, lastEnd);
              if (stop || cmp === 0) {
                return;
              }
              isNewRow = !fold2.sameRow;
              lastEnd = fold2.end.column;
            }
            callback(null, endRow, endColumn, lastEnd, isNewRow);
          };
          FoldLine2.prototype.getNextFoldTo = function(row, column) {
            var fold2, cmp;
            for (var i = 0; i < this.folds.length; i++) {
              fold2 = this.folds[i];
              cmp = fold2.range.compareEnd(row, column);
              if (cmp == -1) {
                return {
                  fold: fold2,
                  kind: "after"
                };
              } else if (cmp === 0) {
                return {
                  fold: fold2,
                  kind: "inside"
                };
              }
            }
            return null;
          };
          FoldLine2.prototype.addRemoveChars = function(row, column, len) {
            var ret = this.getNextFoldTo(row, column), fold2, folds;
            if (ret) {
              fold2 = ret.fold;
              if (ret.kind == "inside" && fold2.start.column != column && fold2.start.row != row) {
                window.console && window.console.log(row, column, fold2);
              } else if (fold2.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold2);
                if (i === 0) {
                  this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                  fold2 = folds[i];
                  fold2.start.column += len;
                  if (!fold2.sameRow) {
                    return;
                  }
                  fold2.end.column += len;
                }
                this.end.column += len;
              }
            }
          };
          FoldLine2.prototype.split = function(row, column) {
            var pos = this.getNextFoldTo(row, column);
            if (!pos || pos.kind == "inside")
              return null;
            var fold2 = pos.fold;
            var folds = this.folds;
            var foldData = this.foldData;
            var i = folds.indexOf(fold2);
            var foldBefore = folds[i - 1];
            this.end.row = foldBefore.end.row;
            this.end.column = foldBefore.end.column;
            folds = folds.splice(i, folds.length - i);
            var newFoldLine = new FoldLine2(foldData, folds);
            foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
            return newFoldLine;
          };
          FoldLine2.prototype.merge = function(foldLineNext) {
            var folds = foldLineNext.folds;
            for (var i = 0; i < folds.length; i++) {
              this.addFold(folds[i]);
            }
            var foldData = this.foldData;
            foldData.splice(foldData.indexOf(foldLineNext), 1);
          };
          FoldLine2.prototype.toString = function() {
            var ret = [this.range.toString() + ": ["];
            this.folds.forEach(function(fold2) {
              ret.push("  " + fold2.toString());
            });
            ret.push("]");
            return ret.join("\n");
          };
          FoldLine2.prototype.idxToPosition = function(idx) {
            var lastFoldEndColumn = 0;
            for (var i = 0; i < this.folds.length; i++) {
              var fold2 = this.folds[i];
              idx -= fold2.start.column - lastFoldEndColumn;
              if (idx < 0) {
                return {
                  row: fold2.start.row,
                  column: fold2.start.column + idx
                };
              }
              idx -= fold2.placeholder.length;
              if (idx < 0) {
                return fold2.start;
              }
              lastFoldEndColumn = fold2.end.column;
            }
            return {
              row: this.end.row,
              column: this.end.column + idx
            };
          };
          return FoldLine2;
        }()
      );
      exports2.FoldLine = FoldLine;
    });
    ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var Range2 = require2("./range").Range;
      var comparePoints = Range2.comparePoints;
      var RangeList = (
        /** @class */
        function() {
          function RangeList2() {
            this.ranges = [];
            this.$bias = 1;
          }
          RangeList2.prototype.pointIndex = function(pos, excludeEdges, startIndex) {
            var list = this.ranges;
            for (var i = startIndex || 0; i < list.length; i++) {
              var range = list[i];
              var cmpEnd = comparePoints(pos, range.end);
              if (cmpEnd > 0)
                continue;
              var cmpStart = comparePoints(pos, range.start);
              if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
              if (cmpStart > 0 || cmpStart === 0 && !excludeEdges)
                return i;
              return -i - 1;
            }
            return -i - 1;
          };
          RangeList2.prototype.add = function(range) {
            var excludeEdges = !range.isEmpty();
            var startIndex = this.pointIndex(range.start, excludeEdges);
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            else
              endIndex++;
            return this.ranges.splice(startIndex, endIndex - startIndex, range);
          };
          RangeList2.prototype.addList = function(list) {
            var removed = [];
            for (var i = list.length; i--; ) {
              removed.push.apply(removed, this.add(list[i]));
            }
            return removed;
          };
          RangeList2.prototype.substractPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0)
              return this.ranges.splice(i, 1);
          };
          RangeList2.prototype.merge = function() {
            var removed = [];
            var list = this.ranges;
            list = list.sort(function(a, b) {
              return comparePoints(a.start, b.start);
            });
            var next = list[0], range;
            for (var i = 1; i < list.length; i++) {
              range = next;
              next = list[i];
              var cmp = comparePoints(range.end, next.start);
              if (cmp < 0)
                continue;
              if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;
              if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
              }
              list.splice(i, 1);
              removed.push(next);
              next = range;
              i--;
            }
            this.ranges = list;
            return removed;
          };
          RangeList2.prototype.contains = function(row, column) {
            return this.pointIndex({ row, column }) >= 0;
          };
          RangeList2.prototype.containsPoint = function(pos) {
            return this.pointIndex(pos) >= 0;
          };
          RangeList2.prototype.rangeAtPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0)
              return this.ranges[i];
          };
          RangeList2.prototype.clipRows = function(startRow, endRow) {
            var list = this.ranges;
            if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
              return [];
            var startIndex = this.pointIndex({ row: startRow, column: 0 });
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            var clipped = [];
            for (var i = startIndex; i < endIndex; i++) {
              clipped.push(list[i]);
            }
            return clipped;
          };
          RangeList2.prototype.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
          };
          RangeList2.prototype.attach = function(session) {
            if (this.session)
              this.detach();
            this.session = session;
            this.onChange = this.$onChange.bind(this);
            this.session.on("change", this.onChange);
          };
          RangeList2.prototype.detach = function() {
            if (!this.session)
              return;
            this.session.removeListener("change", this.onChange);
            this.session = null;
          };
          RangeList2.prototype.$onChange = function(delta) {
            var start = delta.start;
            var end = delta.end;
            var startRow = start.row;
            var endRow = end.row;
            var ranges = this.ranges;
            for (var i = 0, n = ranges.length; i < n; i++) {
              var r = ranges[i];
              if (r.end.row >= startRow)
                break;
            }
            if (delta.action == "insert") {
              var lineDif = endRow - startRow;
              var colDiff = -start.column + end.column;
              for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > startRow)
                  break;
                if (r.start.row == startRow && r.start.column >= start.column) {
                  if (r.start.column == start.column && this.$bias <= 0) {
                  } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                  }
                }
                if (r.end.row == startRow && r.end.column >= start.column) {
                  if (r.end.column == start.column && this.$bias < 0) {
                    continue;
                  }
                  if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                    if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
                      r.end.column -= colDiff;
                  }
                  r.end.column += colDiff;
                  r.end.row += lineDif;
                }
              }
            } else {
              var lineDif = startRow - endRow;
              var colDiff = start.column - end.column;
              for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > endRow)
                  break;
                if (r.end.row < endRow && (startRow < r.end.row || startRow == r.end.row && start.column < r.end.column)) {
                  r.end.row = startRow;
                  r.end.column = start.column;
                } else if (r.end.row == endRow) {
                  if (r.end.column <= end.column) {
                    if (lineDif || r.end.column > start.column) {
                      r.end.column = start.column;
                      r.end.row = start.row;
                    }
                  } else {
                    r.end.column += colDiff;
                    r.end.row += lineDif;
                  }
                } else if (r.end.row > endRow) {
                  r.end.row += lineDif;
                }
                if (r.start.row < endRow && (startRow < r.start.row || startRow == r.start.row && start.column < r.start.column)) {
                  r.start.row = startRow;
                  r.start.column = start.column;
                } else if (r.start.row == endRow) {
                  if (r.start.column <= end.column) {
                    if (lineDif || r.start.column > start.column) {
                      r.start.column = start.column;
                      r.start.row = start.row;
                    }
                  } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                  }
                } else if (r.start.row > endRow) {
                  r.start.row += lineDif;
                }
              }
            }
            if (lineDif != 0 && i < n) {
              for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
              }
            }
          };
          return RangeList2;
        }()
      );
      RangeList.prototype.comparePoints = comparePoints;
      exports2.RangeList = RangeList;
    });
    ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range_list"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var RangeList = require2("../range_list").RangeList;
      var Fold = (
        /** @class */
        function(_super) {
          __extends(Fold2, _super);
          function Fold2(range, placeholder) {
            var _this = _super.call(this) || this;
            _this.foldLine = null;
            _this.placeholder = placeholder;
            _this.range = range;
            _this.start = range.start;
            _this.end = range.end;
            _this.sameRow = range.start.row == range.end.row;
            _this.subFolds = _this.ranges = [];
            return _this;
          }
          Fold2.prototype.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
          };
          Fold2.prototype.setFoldLine = function(foldLine) {
            this.foldLine = foldLine;
            this.subFolds.forEach(function(fold2) {
              fold2.setFoldLine(foldLine);
            });
          };
          Fold2.prototype.clone = function() {
            var range = this.range.clone();
            var fold2 = new Fold2(range, this.placeholder);
            this.subFolds.forEach(function(subFold) {
              fold2.subFolds.push(subFold.clone());
            });
            fold2.collapseChildren = this.collapseChildren;
            return fold2;
          };
          Fold2.prototype.addSubFold = function(fold2) {
            if (this.range.isEqual(fold2))
              return;
            consumeRange(fold2, this.start);
            var row = fold2.start.row, column = fold2.start.column;
            for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
              cmp = this.subFolds[i].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            var afterStart = this.subFolds[i];
            var firstConsumed = 0;
            if (cmp == 0) {
              if (afterStart.range.containsRange(fold2))
                return afterStart.addSubFold(fold2);
              else
                firstConsumed = 1;
            }
            var row = fold2.range.end.row, column = fold2.range.end.column;
            for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
              cmp = this.subFolds[j].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            if (cmp == 0)
              j++;
            var consumedFolds = this.subFolds.splice(i, j - i, fold2);
            var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
            for (var k = firstConsumed; k < last; k++) {
              fold2.addSubFold(consumedFolds[k]);
            }
            fold2.setFoldLine(this.foldLine);
            return fold2;
          };
          Fold2.prototype.restoreRange = function(range) {
            return restoreRange(range, this.start);
          };
          return Fold2;
        }(RangeList)
      );
      function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0)
          point.column -= anchor.column;
      }
      function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
      }
      function restorePoint(point, anchor) {
        if (point.row == 0)
          point.column += anchor.column;
        point.row += anchor.row;
      }
      function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
      }
      exports2.Fold = Fold;
    });
    ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator", "ace/mouse/mouse_event"], function(require2, exports2, module2) {
      "use strict";
      var Range2 = require2("../range").Range;
      var FoldLine = require2("./fold_line").FoldLine;
      var Fold = require2("./fold").Fold;
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var MouseEvent = require2("../mouse/mouse_event").MouseEvent;
      function Folding() {
        this.getFoldAt = function(row, column, side) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine)
            return null;
          var folds = foldLine.folds;
          for (var i = 0; i < folds.length; i++) {
            var range = folds[i].range;
            if (range.contains(row, column)) {
              if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                continue;
              } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                continue;
              }
              return folds[i];
            }
          }
        };
        this.getFoldsInRange = function(range) {
          var start = range.start;
          var end = range.end;
          var foldLines = this.$foldData;
          var foundFolds = [];
          start.column += 1;
          end.column -= 1;
          for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
              continue;
            } else if (cmp == -2) {
              break;
            }
            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
              var fold2 = folds[j];
              cmp = fold2.range.compareRange(range);
              if (cmp == -2) {
                break;
              } else if (cmp == 2) {
                continue;
              } else if (cmp == 42) {
                break;
              }
              foundFolds.push(fold2);
            }
          }
          start.column -= 1;
          end.column += 1;
          return foundFolds;
        };
        this.getFoldsInRangeList = function(ranges) {
          if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
              folds = folds.concat(this.getFoldsInRange(range));
            }, this);
          } else {
            var folds = this.getFoldsInRange(ranges);
          }
          return folds;
        };
        this.getAllFolds = function() {
          var folds = [];
          var foldLines = this.$foldData;
          for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
              folds.push(foldLines[i].folds[j]);
          return folds;
        };
        this.getFoldStringAt = function(row, column, trim, foldLine) {
          foldLine = foldLine || this.getFoldLine(row);
          if (!foldLine)
            return null;
          var lastFold = {
            end: { column: 0 }
          };
          var str, fold2;
          for (var i = 0; i < foldLine.folds.length; i++) {
            fold2 = foldLine.folds[i];
            var cmp = fold2.range.compareEnd(row, column);
            if (cmp == -1) {
              str = this.getLine(fold2.start.row).substring(lastFold.end.column, fold2.start.column);
              break;
            } else if (cmp === 0) {
              return null;
            }
            lastFold = fold2;
          }
          if (!str)
            str = this.getLine(fold2.start.row).substring(lastFold.end.column);
          if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
          else if (trim == 1)
            return str.substring(column - lastFold.end.column);
          else
            return str;
        };
        this.getFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
          if (i == -1)
            i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
              return foldLine;
            } else if (foldLine.end.row > docRow) {
              return null;
            }
          }
          return null;
        };
        this.getNextFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
          if (i == -1)
            i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
              return foldLine;
            }
          }
          return null;
        };
        this.getFoldedRowCount = function(first, last) {
          var foldData = this.$foldData, rowCount = last - first + 1;
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
            if (end >= last) {
              if (start < last) {
                if (start >= first)
                  rowCount -= last - start;
                else
                  rowCount = 0;
              }
              break;
            } else if (end >= first) {
              if (start >= first)
                rowCount -= end - start;
              else
                rowCount -= end - first + 1;
            }
          }
          return rowCount;
        };
        this.$addFoldLine = function(foldLine) {
          this.$foldData.push(foldLine);
          this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
          });
          return foldLine;
        };
        this.addFold = function(placeholder, range) {
          var foldData = this.$foldData;
          var added = false;
          var fold2;
          if (placeholder instanceof Fold)
            fold2 = placeholder;
          else {
            fold2 = new Fold(range, placeholder);
            fold2.collapseChildren = range.collapseChildren;
          }
          this.$clipRangeToDocument(fold2.range);
          var startRow = fold2.start.row;
          var startColumn = fold2.start.column;
          var endRow = fold2.end.row;
          var endColumn = fold2.end.column;
          var startFold = this.getFoldAt(startRow, startColumn, 1);
          var endFold = this.getFoldAt(endRow, endColumn, -1);
          if (startFold && endFold == startFold)
            return startFold.addSubFold(fold2);
          if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
          if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
          var folds = this.getFoldsInRange(fold2.range);
          if (folds.length > 0) {
            this.removeFolds(folds);
            if (!fold2.collapseChildren) {
              folds.forEach(function(subFold) {
                fold2.addSubFold(subFold);
              });
            }
          }
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
              foldLine.addFold(fold2);
              added = true;
              break;
            } else if (startRow == foldLine.end.row) {
              foldLine.addFold(fold2);
              added = true;
              if (!fold2.sameRow) {
                var foldLineNext = foldData[i + 1];
                if (foldLineNext && foldLineNext.start.row == endRow) {
                  foldLine.merge(foldLineNext);
                  break;
                }
              }
              break;
            } else if (endRow <= foldLine.start.row) {
              break;
            }
          }
          if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold2));
          if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
          else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
          this.$modified = true;
          this._signal("changeFold", { data: fold2, action: "add" });
          return fold2;
        };
        this.addFolds = function(folds) {
          folds.forEach(function(fold2) {
            this.addFold(fold2);
          }, this);
        };
        this.removeFold = function(fold2) {
          var foldLine = fold2.foldLine;
          var startRow = foldLine.start.row;
          var endRow = foldLine.end.row;
          var foldLines = this.$foldData;
          var folds = foldLine.folds;
          if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
          } else if (foldLine.range.isEnd(fold2.end.row, fold2.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
          } else if (foldLine.range.isStart(fold2.start.row, fold2.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
          } else if (fold2.sameRow) {
            folds.splice(folds.indexOf(fold2), 1);
          } else {
            var newFoldLine = foldLine.split(fold2.start.row, fold2.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
          }
          if (!this.$updating) {
            if (this.$useWrapMode)
              this.$updateWrapData(startRow, endRow);
            else
              this.$updateRowLengthCache(startRow, endRow);
          }
          this.$modified = true;
          this._signal("changeFold", { data: fold2, action: "remove" });
        };
        this.removeFolds = function(folds) {
          var cloneFolds = [];
          for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
          }
          cloneFolds.forEach(function(fold2) {
            this.removeFold(fold2);
          }, this);
          this.$modified = true;
        };
        this.expandFold = function(fold2) {
          this.removeFold(fold2);
          fold2.subFolds.forEach(function(subFold) {
            fold2.restoreRange(subFold);
            this.addFold(subFold);
          }, this);
          if (fold2.collapseChildren > 0) {
            this.foldAll(fold2.start.row + 1, fold2.end.row, fold2.collapseChildren - 1);
          }
          fold2.subFolds = [];
        };
        this.expandFolds = function(folds) {
          folds.forEach(function(fold2) {
            this.expandFold(fold2);
          }, this);
        };
        this.unfold = function(location2, expandInner) {
          var range, folds;
          if (location2 == null) {
            range = new Range2(0, 0, this.getLength(), 0);
            if (expandInner == null)
              expandInner = true;
          } else if (typeof location2 == "number") {
            range = new Range2(location2, 0, location2, this.getLine(location2).length);
          } else if ("row" in location2) {
            range = Range2.fromPoints(location2, location2);
          } else if (Array.isArray(location2)) {
            folds = [];
            location2.forEach(function(range2) {
              folds = folds.concat(this.unfold(range2));
            }, this);
            return folds;
          } else {
            range = location2;
          }
          folds = this.getFoldsInRangeList(range);
          var outermostFolds = folds;
          while (folds.length == 1 && Range2.comparePoints(folds[0].start, range.start) < 0 && Range2.comparePoints(folds[0].end, range.end) > 0) {
            this.expandFolds(folds);
            folds = this.getFoldsInRangeList(range);
          }
          if (expandInner != false) {
            this.removeFolds(folds);
          } else {
            this.expandFolds(folds);
          }
          if (outermostFolds.length)
            return outermostFolds;
        };
        this.isRowFolded = function(docRow, startFoldRow) {
          return !!this.getFoldLine(docRow, startFoldRow);
        };
        this.getRowFoldEnd = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.end.row : docRow;
        };
        this.getRowFoldStart = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.start.row : docRow;
        };
        this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
          if (startRow == null)
            startRow = foldLine.start.row;
          if (startColumn == null)
            startColumn = 0;
          if (endRow == null)
            endRow = foldLine.end.row;
          if (endColumn == null)
            endColumn = this.getLine(endRow).length;
          var doc2 = this.doc;
          var textLine = "";
          foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
              return;
            if (row == startRow) {
              if (column < startColumn)
                return;
              lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder != null) {
              textLine += placeholder;
            } else {
              textLine += doc2.getLine(row).substring(lastColumn, column);
            }
          }, endRow, endColumn);
          return textLine;
        };
        this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
          } else {
            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
          }
        };
        this.$cloneFoldData = function() {
          var fd = [];
          fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold2) {
              return fold2.clone();
            });
            return new FoldLine(fd, folds);
          });
          return fd;
        };
        this.toggleFold = function(tryToUnfold) {
          var selection = this.selection;
          var range = selection.getRange();
          var fold2;
          var bracketPos;
          if (range.isEmpty()) {
            var cursor = range.start;
            fold2 = this.getFoldAt(cursor.row, cursor.column);
            if (fold2) {
              this.expandFold(fold2);
              return;
            } else if (tryToUnfold) {
              var foldLine = this.getFoldLine(cursor.row);
              if (foldLine)
                this.expandFolds(foldLine.folds);
              return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
              if (range.comparePoint(bracketPos) == 1) {
                range.end = bracketPos;
              } else {
                range.start = bracketPos;
                range.start.column++;
                range.end.column--;
              }
            } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
              if (range.comparePoint(bracketPos) == 1)
                range.end = bracketPos;
              else
                range.start = bracketPos;
              range.start.column++;
            } else {
              range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
          } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
              this.expandFolds(folds);
              return;
            } else if (folds.length == 1) {
              fold2 = folds[0];
            }
          }
          if (!fold2)
            fold2 = this.getFoldAt(range.start.row, range.start.column);
          if (fold2 && fold2.range.toString() == range.toString()) {
            this.expandFold(fold2);
            return;
          }
          var placeholder = "...";
          if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
              return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
          }
          this.addFold(placeholder, range);
        };
        this.getCommentFoldRange = function(row, column, dir) {
          var iterator = new TokenIterator(this, row, column);
          var token = iterator.getCurrentToken();
          var type2 = token && token.type;
          if (token && /^comment|string/.test(type2)) {
            type2 = type2.match(/comment|string/)[0];
            if (type2 == "comment")
              type2 += "|doc-start|\\.doc";
            var re = new RegExp(type2);
            var range = new Range2();
            if (dir != 1) {
              do {
                token = iterator.stepBackward();
              } while (token && re.test(token.type));
              token = iterator.stepForward();
            }
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + token.value.length;
            iterator = new TokenIterator(this, row, column);
            var initState = this.getState(iterator.$row);
            if (dir != -1) {
              var lastRow = -1;
              do {
                token = iterator.stepForward();
                if (lastRow == -1) {
                  var state = this.getState(iterator.$row);
                  if (initState.toString() !== state.toString())
                    lastRow = iterator.$row;
                } else if (iterator.$row > lastRow) {
                  break;
                }
              } while (token && re.test(token.type));
              token = iterator.stepBackward();
            } else
              token = iterator.getCurrentToken();
            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn();
            if (range.start.row == range.end.row && range.start.column > range.end.column)
              return;
            return range;
          }
        };
        this.foldAll = function(startRow, endRow, depth, test) {
          if (depth == void 0)
            depth = 1e5;
          var foldWidgets = this.foldWidgets;
          if (!foldWidgets)
            return;
          endRow = endRow || this.getLength();
          startRow = startRow || 0;
          for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
              foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
              continue;
            if (test && !test(row))
              continue;
            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
              row = range.end.row;
              range.collapseChildren = depth;
              this.addFold("...", range);
            }
          }
        };
        this.foldToLevel = function(level) {
          this.foldAll();
          while (level-- > 0)
            this.unfold(null, false);
        };
        this.foldAllComments = function() {
          var session = this;
          this.foldAll(null, null, null, function(row) {
            var tokens2 = session.getTokens(row);
            for (var i = 0; i < tokens2.length; i++) {
              var token = tokens2[i];
              if (token.type == "text" && /^\s+$/.test(token.value))
                continue;
              if (/comment/.test(token.type))
                return true;
              return false;
            }
          });
        };
        this.$foldStyles = {
          "manual": 1,
          "markbegin": 1,
          "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function(style) {
          if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
          if (this.$foldStyle == style)
            return;
          this.$foldStyle = style;
          if (style == "manual")
            this.unfold();
          var mode = this.$foldMode;
          this.$setFolding(null);
          this.$setFolding(mode);
        };
        this.$setFolding = function(foldMode) {
          if (this.$foldMode == foldMode)
            return;
          this.$foldMode = foldMode;
          this.off("change", this.$updateFoldWidgets);
          this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
          this._signal("changeAnnotation");
          if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
          }
          this.foldWidgets = [];
          this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
          this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
          this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
          this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
          this.on("change", this.$updateFoldWidgets);
          this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
        };
        this.getParentFoldRangeData = function(row, ignoreCurrent) {
          var fw = this.foldWidgets;
          if (!fw || ignoreCurrent && fw[row])
            return {};
          var i = row - 1, firstRange;
          while (i >= 0) {
            var c = fw[i];
            if (c == null)
              c = fw[i] = this.getFoldWidget(i);
            if (c == "start") {
              var range = this.getFoldWidgetRange(i);
              if (!firstRange)
                firstRange = range;
              if (range && range.end.row >= row)
                break;
            }
            i--;
          }
          return {
            range: i !== -1 && range,
            firstRange
          };
        };
        this.onFoldWidgetClick = function(row, e75) {
          if (e75 instanceof MouseEvent)
            e75 = e75.domEvent;
          var options = {
            children: e75.shiftKey,
            all: e75.ctrlKey || e75.metaKey,
            siblings: e75.altKey
          };
          var range = this.$toggleFoldWidget(row, options);
          if (!range) {
            var el = e75.target || e75.srcElement;
            if (el && /ace_fold-widget/.test(el.className))
              el.className += " ace_invalid";
          }
        };
        this.$toggleFoldWidget = function(row, options) {
          if (!this.getFoldWidget)
            return;
          var type2 = this.getFoldWidget(row);
          var line = this.getLine(row);
          var dir = type2 === "end" ? -1 : 1;
          var fold2 = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
          if (fold2) {
            if (options.children || options.all)
              this.removeFold(fold2);
            else
              this.expandFold(fold2);
            return fold2;
          }
          var range = this.getFoldWidgetRange(row, true);
          if (range && !range.isMultiLine()) {
            fold2 = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold2 && range.isEqual(fold2.range)) {
              this.removeFold(fold2);
              return fold2;
            }
          }
          if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
              var startRow = data.range.start.row + 1;
              var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 1e4 : 0);
          } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 1e4 : 0);
          } else if (range) {
            if (options.all)
              range.collapseChildren = 1e4;
            this.addFold("...", range);
          }
          return range;
        };
        this.toggleFoldWidget = function(toggleParent) {
          var row = this.selection.getCursor().row;
          row = this.getRowFoldStart(row);
          var range = this.$toggleFoldWidget(row, {});
          if (range)
            return;
          var data = this.getParentFoldRangeData(row, true);
          range = data.range || data.firstRange;
          if (range) {
            row = range.start.row;
            var fold2 = this.getFoldAt(row, this.getLine(row).length, 1);
            if (fold2) {
              this.removeFold(fold2);
            } else {
              this.addFold("...", range);
            }
          }
        };
        this.updateFoldWidgets = function(delta) {
          var firstRow = delta.start.row;
          var len = delta.end.row - firstRow;
          if (len === 0) {
            this.foldWidgets[firstRow] = null;
          } else if (delta.action == "remove") {
            this.foldWidgets.splice(firstRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
          }
        };
        this.tokenizerUpdateFoldWidgets = function(e75) {
          var rows = e75.data;
          if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
              this.foldWidgets.splice(rows.first, this.foldWidgets.length);
          }
        };
      }
      exports2.Folding = Folding;
    });
    ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var Range2 = require2("../range").Range;
      function BracketMatch() {
        this.findMatchingBracket = function(position2, chr) {
          if (position2.column == 0)
            return null;
          var charBeforeCursor = chr || this.getLine(position2.row).charAt(position2.column - 1);
          if (charBeforeCursor == "")
            return null;
          var match2 = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
          if (!match2)
            return null;
          if (match2[1])
            return this.$findClosingBracket(match2[1], position2);
          else
            return this.$findOpeningBracket(match2[2], position2);
        };
        this.getBracketRange = function(pos) {
          var line = this.getLine(pos.row);
          var before = true, range;
          var chr = line.charAt(pos.column - 1);
          var match2 = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          if (!match2) {
            chr = line.charAt(pos.column);
            pos = { row: pos.row, column: pos.column + 1 };
            match2 = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
          }
          if (!match2)
            return null;
          if (match2[1]) {
            var bracketPos = this.$findClosingBracket(match2[1], pos);
            if (!bracketPos)
              return null;
            range = Range2.fromPoints(pos, bracketPos);
            if (!before) {
              range.end.column++;
              range.start.column--;
            }
            range.cursor = range.end;
          } else {
            var bracketPos = this.$findOpeningBracket(match2[2], pos);
            if (!bracketPos)
              return null;
            range = Range2.fromPoints(bracketPos, pos);
            if (!before) {
              range.start.column++;
              range.end.column--;
            }
            range.cursor = range.start;
          }
          return range;
        };
        this.getMatchingBracketRanges = function(pos, isBackwards) {
          var line = this.getLine(pos.row);
          var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
          var chr = !isBackwards && line.charAt(pos.column - 1);
          var match2 = chr && chr.match(bracketsRegExp);
          if (!match2) {
            chr = (isBackwards === void 0 || isBackwards) && line.charAt(pos.column);
            pos = {
              row: pos.row,
              column: pos.column + 1
            };
            match2 = chr && chr.match(bracketsRegExp);
          }
          if (!match2)
            return null;
          var startRange = new Range2(pos.row, pos.column - 1, pos.row, pos.column);
          var bracketPos = match2[1] ? this.$findClosingBracket(match2[1], pos) : this.$findOpeningBracket(match2[2], pos);
          if (!bracketPos)
            return [startRange];
          var endRange = new Range2(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
          return [startRange, endRange];
        };
        this.$brackets = {
          ")": "(",
          "(": ")",
          "]": "[",
          "[": "]",
          "{": "}",
          "}": "{",
          "<": ">",
          ">": "<"
        };
        this.$findOpeningBracket = function(bracket, position2, typeRe) {
          var openBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position2.row, position2.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)").replace(/-close\b/, "-(close|open)") + ")+");
          }
          var valueIndex = position2.column - iterator.getCurrentTokenColumn() - 2;
          var value = token.value;
          while (true) {
            while (valueIndex >= 0) {
              var chr = value.charAt(valueIndex);
              if (chr == openBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex -= 1;
            }
            do {
              token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            value = token.value;
            valueIndex = value.length - 1;
          }
          return null;
        };
        this.$findClosingBracket = function(bracket, position2, typeRe) {
          var closingBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position2.row, position2.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)").replace(/-open\b/, "-(close|open)") + ")+");
          }
          var valueIndex = position2.column - iterator.getCurrentTokenColumn();
          while (true) {
            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
              var chr = value.charAt(valueIndex);
              if (chr == closingBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex += 1;
            }
            do {
              token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            valueIndex = 0;
          }
          return null;
        };
        this.getMatchingTags = function(pos) {
          var iterator = new TokenIterator(this, pos.row, pos.column);
          var token = this.$findTagName(iterator);
          if (!token)
            return;
          var prevToken = iterator.stepBackward();
          if (prevToken.value === "<") {
            return this.$findClosingTag(iterator, token);
          } else {
            return this.$findOpeningTag(iterator, token);
          }
        };
        this.$findTagName = function(iterator) {
          var token = iterator.getCurrentToken();
          var found = false;
          var backward = false;
          if (token && token.type.indexOf("tag-name") === -1) {
            do {
              if (backward)
                token = iterator.stepBackward();
              else
                token = iterator.stepForward();
              if (token) {
                if (token.value === "/>") {
                  backward = true;
                } else if (token.type.indexOf("tag-name") !== -1) {
                  found = true;
                }
              }
            } while (token && !found);
          }
          return token;
        };
        this.$findClosingTag = function(iterator, token) {
          var prevToken;
          var currentTag = token.value;
          var tag = token.value;
          var depth = 0;
          var openTagStart = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
          token = iterator.stepForward();
          var openTagName = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
          var foundOpenTagEnd = false;
          do {
            prevToken = token;
            if (prevToken.type.indexOf("tag-close") !== -1 && !foundOpenTagEnd) {
              var openTagEnd = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
              foundOpenTagEnd = true;
            }
            token = iterator.stepForward();
            if (token) {
              if (token.value === ">" && !foundOpenTagEnd) {
                var openTagEnd = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                foundOpenTagEnd = true;
              }
              if (token.type.indexOf("tag-name") !== -1) {
                currentTag = token.value;
                if (tag === currentTag) {
                  if (prevToken.value === "<") {
                    depth++;
                  } else if (prevToken.value === "</") {
                    depth--;
                    if (depth < 0) {
                      iterator.stepBackward();
                      var closeTagStart = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                      token = iterator.stepForward();
                      var closeTagName = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                      if (token.type.indexOf("tag-close") === -1) {
                        token = iterator.stepForward();
                      }
                      if (token && token.value === ">") {
                        var closeTagEnd = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                      } else {
                        return;
                      }
                    }
                  }
                }
              } else if (tag === currentTag && token.value === "/>") {
                depth--;
                if (depth < 0) {
                  var closeTagStart = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                  var closeTagName = closeTagStart;
                  var closeTagEnd = closeTagName;
                  var openTagEnd = new Range2(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
                }
              }
            }
          } while (token && depth >= 0);
          if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
              openTag: new Range2(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
              closeTag: new Range2(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
              openTagName,
              closeTagName
            };
          }
        };
        this.$findOpeningTag = function(iterator, token) {
          var prevToken = iterator.getCurrentToken();
          var tag = token.value;
          var depth = 0;
          var startRow = iterator.getCurrentTokenRow();
          var startColumn = iterator.getCurrentTokenColumn();
          var endColumn = startColumn + 2;
          var closeTagStart = new Range2(startRow, startColumn, startRow, endColumn);
          iterator.stepForward();
          var closeTagName = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
          if (token.type.indexOf("tag-close") === -1) {
            token = iterator.stepForward();
          }
          if (!token || token.value !== ">")
            return;
          var closeTagEnd = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
          iterator.stepBackward();
          iterator.stepBackward();
          do {
            token = prevToken;
            startRow = iterator.getCurrentTokenRow();
            startColumn = iterator.getCurrentTokenColumn();
            endColumn = startColumn + token.value.length;
            prevToken = iterator.stepBackward();
            if (token) {
              if (token.type.indexOf("tag-name") !== -1) {
                if (tag === token.value) {
                  if (prevToken.value === "<") {
                    depth++;
                    if (depth > 0) {
                      var openTagName = new Range2(startRow, startColumn, startRow, endColumn);
                      var openTagStart = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                      do {
                        token = iterator.stepForward();
                      } while (token && token.value !== ">");
                      var openTagEnd = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                    }
                  } else if (prevToken.value === "</") {
                    depth--;
                  }
                }
              } else if (token.value === "/>") {
                var stepCount = 0;
                var tmpToken = prevToken;
                while (tmpToken) {
                  if (tmpToken.type.indexOf("tag-name") !== -1 && tmpToken.value === tag) {
                    depth--;
                    break;
                  } else if (tmpToken.value === "<") {
                    break;
                  }
                  tmpToken = iterator.stepBackward();
                  stepCount++;
                }
                for (var i = 0; i < stepCount; i++) {
                  iterator.stepForward();
                }
              }
            }
          } while (prevToken && depth <= 0);
          if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
              openTag: new Range2(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
              closeTag: new Range2(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
              openTagName,
              closeTagName
            };
          }
        };
      }
      exports2.BracketMatch = BracketMatch;
    });
    ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/line_widgets", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/undomanager", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var lang = require2("./lib/lang");
      var BidiHandler = require2("./bidihandler").BidiHandler;
      var config2 = require2("./config");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Selection = require2("./selection").Selection;
      var TextMode = require2("./mode/text").Mode;
      var Range2 = require2("./range").Range;
      var LineWidgets = require2("./line_widgets").LineWidgets;
      var Document = require2("./document").Document;
      var BackgroundTokenizer = require2("./background_tokenizer").BackgroundTokenizer;
      var SearchHighlight = require2("./search_highlight").SearchHighlight;
      var UndoManager = require2("./undomanager").UndoManager;
      var EditSession = (
        /** @class */
        function() {
          function EditSession2(text, mode) {
            this.doc;
            this.$breakpoints = [];
            this.$decorations = [];
            this.$frontMarkers = {};
            this.$backMarkers = {};
            this.$markerId = 1;
            this.$undoSelect = true;
            this.$editor = null;
            this.prevOp = {};
            this.$foldData = [];
            this.id = "session" + ++EditSession2.$uid;
            this.$foldData.toString = function() {
              return this.join("\n");
            };
            this.$gutterCustomWidgets = {};
            this.bgTokenizer = new BackgroundTokenizer(new TextMode().getTokenizer(), this);
            var _self = this;
            this.bgTokenizer.on("update", function(e75) {
              _self._signal("tokenizerUpdate", e75);
            });
            this.on("changeFold", this.onChangeFold.bind(this));
            this.$onChange = this.onChange.bind(this);
            if (typeof text != "object" || !text.getLine)
              text = new Document(
                /**@type{string}*/
                text
              );
            this.setDocument(text);
            this.selection = new Selection(this);
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
            this.selection.on("changeCursor", this.$onSelectionChange);
            this.$bidiHandler = new BidiHandler(this);
            config2.resetOptions(this);
            this.setMode(mode);
            config2._signal("session", this);
            this.destroyed = false;
            this.$initOperationListeners();
          }
          EditSession2.prototype.$initOperationListeners = function() {
            var _this = this;
            this.curOp = null;
            this.on("change", function() {
              if (!_this.curOp) {
                _this.startOperation();
                _this.curOp.selectionBefore = _this.$lastSel;
              }
              _this.curOp.docChanged = true;
            }, true);
            this.on("changeSelection", function() {
              if (!_this.curOp) {
                _this.startOperation();
                _this.curOp.selectionBefore = _this.$lastSel;
              }
              _this.curOp.selectionChanged = true;
            }, true);
            this.$operationResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
          };
          EditSession2.prototype.startOperation = function(commandEvent) {
            if (this.curOp) {
              if (!commandEvent || this.curOp.command) {
                return;
              }
              this.prevOp = this.curOp;
            }
            if (!commandEvent) {
              commandEvent = {};
            }
            this.$operationResetTimer.schedule();
            this.curOp = {
              command: commandEvent.command || {},
              args: commandEvent.args
            };
            this.curOp.selectionBefore = this.selection.toJSON();
            this._signal("startOperation", commandEvent);
          };
          EditSession2.prototype.endOperation = function(e75) {
            if (this.curOp) {
              if (e75 && e75.returnValue === false) {
                this.curOp = null;
                this._signal("endOperation", e75);
                return;
              }
              if (e75 == true && this.curOp.command && this.curOp.command.name == "mouse") {
                return;
              }
              var currentSelection = this.selection.toJSON();
              this.curOp.selectionAfter = currentSelection;
              this.$lastSel = this.selection.toJSON();
              this.getUndoManager().addSelection(currentSelection);
              this._signal("beforeEndOperation");
              this.prevOp = this.curOp;
              this.curOp = null;
              this._signal("endOperation", e75);
            }
          };
          EditSession2.prototype.setDocument = function(doc2) {
            if (this.doc)
              this.doc.off("change", this.$onChange);
            this.doc = doc2;
            doc2.on("change", this.$onChange, true);
            this.bgTokenizer.setDocument(this.getDocument());
            this.resetCaches();
          };
          EditSession2.prototype.getDocument = function() {
            return this.doc;
          };
          Object.defineProperty(EditSession2.prototype, "widgetManager", {
            get: function() {
              var widgetManager = new LineWidgets(this);
              this.widgetManager = widgetManager;
              if (this.$editor)
                widgetManager.attach(this.$editor);
              return widgetManager;
            },
            set: function(value) {
              Object.defineProperty(this, "widgetManager", {
                writable: true,
                enumerable: true,
                configurable: true,
                value
              });
            },
            enumerable: false,
            configurable: true
          });
          EditSession2.prototype.$resetRowCache = function(docRow) {
            if (!docRow) {
              this.$docRowCache = [];
              this.$screenRowCache = [];
              return;
            }
            var l = this.$docRowCache.length;
            var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
            if (l > i) {
              this.$docRowCache.splice(i, l);
              this.$screenRowCache.splice(i, l);
            }
          };
          EditSession2.prototype.$getRowCacheIndex = function(cacheArray, val) {
            var low = 0;
            var hi = cacheArray.length - 1;
            while (low <= hi) {
              var mid = low + hi >> 1;
              var c = cacheArray[mid];
              if (val > c)
                low = mid + 1;
              else if (val < c)
                hi = mid - 1;
              else
                return mid;
            }
            return low - 1;
          };
          EditSession2.prototype.resetCaches = function() {
            this.$modified = true;
            this.$wrapData = [];
            this.$rowLengthCache = [];
            this.$resetRowCache(0);
            if (!this.destroyed)
              this.bgTokenizer.start(0);
          };
          EditSession2.prototype.onChangeFold = function(e75) {
            var fold2 = e75.data;
            this.$resetRowCache(fold2.start.row);
          };
          EditSession2.prototype.onChange = function(delta) {
            this.$modified = true;
            this.$bidiHandler.onChange(delta);
            this.$resetRowCache(delta.start.row);
            var removedFolds = this.$updateInternalDataOnChange(delta);
            if (!this.$fromUndo && this.$undoManager) {
              if (removedFolds && removedFolds.length) {
                this.$undoManager.add({
                  action: "removeFolds",
                  folds: removedFolds
                }, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
              }
              this.$undoManager.add(delta, this.mergeUndoDeltas);
              this.mergeUndoDeltas = true;
              this.$informUndoManager.schedule();
            }
            this.bgTokenizer.$updateOnChange(delta);
            this._signal("change", delta);
          };
          EditSession2.prototype.onSelectionChange = function() {
            this._signal("changeSelection");
          };
          EditSession2.prototype.setValue = function(text) {
            this.doc.setValue(text);
            this.selection.moveTo(0, 0);
            this.$resetRowCache(0);
            this.setUndoManager(this.$undoManager);
            this.getUndoManager().reset();
          };
          EditSession2.fromJSON = function(session) {
            if (typeof session == "string")
              session = JSON.parse(session);
            var undoManager = new UndoManager();
            undoManager.$undoStack = session.history.undo;
            undoManager.$redoStack = session.history.redo;
            undoManager.mark = session.history.mark;
            undoManager.$rev = session.history.rev;
            var editSession = new EditSession2(session.value);
            session.folds.forEach(function(fold2) {
              editSession.addFold("...", Range2.fromPoints(fold2.start, fold2.end));
            });
            editSession.setAnnotations(session.annotations);
            editSession.setBreakpoints(session.breakpoints);
            editSession.setMode(session.mode);
            editSession.setScrollLeft(session.scrollLeft);
            editSession.setScrollTop(session.scrollTop);
            editSession.setUndoManager(undoManager);
            editSession.selection.fromJSON(session.selection);
            return editSession;
          };
          EditSession2.prototype.toJSON = function() {
            return {
              annotations: this.$annotations,
              breakpoints: this.$breakpoints,
              folds: this.getAllFolds().map(function(fold2) {
                return fold2.range;
              }),
              history: this.getUndoManager(),
              mode: this.$mode.$id,
              scrollLeft: this.$scrollLeft,
              scrollTop: this.$scrollTop,
              selection: this.selection.toJSON(),
              value: this.doc.getValue()
            };
          };
          EditSession2.prototype.toString = function() {
            return this.doc.getValue();
          };
          EditSession2.prototype.getSelection = function() {
            return this.selection;
          };
          EditSession2.prototype.getState = function(row) {
            return this.bgTokenizer.getState(row);
          };
          EditSession2.prototype.getTokens = function(row) {
            return this.bgTokenizer.getTokens(row);
          };
          EditSession2.prototype.getTokenAt = function(row, column) {
            var tokens2 = this.bgTokenizer.getTokens(row);
            var token, c = 0;
            if (column == null) {
              var i = tokens2.length - 1;
              c = this.getLine(row).length;
            } else {
              for (var i = 0; i < tokens2.length; i++) {
                c += tokens2[i].value.length;
                if (c >= column)
                  break;
              }
            }
            token = tokens2[i];
            if (!token)
              return null;
            token.index = i;
            token.start = c - token.value.length;
            return token;
          };
          EditSession2.prototype.setUndoManager = function(undoManager) {
            this.$undoManager = undoManager;
            if (this.$informUndoManager)
              this.$informUndoManager.cancel();
            if (undoManager) {
              var self2 = this;
              undoManager.addSession(this);
              this.$syncInformUndoManager = function() {
                self2.$informUndoManager.cancel();
                self2.mergeUndoDeltas = false;
              };
              this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
            } else {
              this.$syncInformUndoManager = function() {
              };
            }
          };
          EditSession2.prototype.markUndoGroup = function() {
            if (this.$syncInformUndoManager)
              this.$syncInformUndoManager();
          };
          EditSession2.prototype.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
          };
          EditSession2.prototype.getTabString = function() {
            if (this.getUseSoftTabs()) {
              return lang.stringRepeat(" ", this.getTabSize());
            } else {
              return "	";
            }
          };
          EditSession2.prototype.setUseSoftTabs = function(val) {
            this.setOption("useSoftTabs", val);
          };
          EditSession2.prototype.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
          };
          EditSession2.prototype.setTabSize = function(tabSize) {
            this.setOption("tabSize", tabSize);
          };
          EditSession2.prototype.getTabSize = function() {
            return this.$tabSize;
          };
          EditSession2.prototype.isTabStop = function(position2) {
            return this.$useSoftTabs && position2.column % this.$tabSize === 0;
          };
          EditSession2.prototype.setNavigateWithinSoftTabs = function(navigateWithinSoftTabs) {
            this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
          };
          EditSession2.prototype.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
          };
          EditSession2.prototype.setOverwrite = function(overwrite) {
            this.setOption("overwrite", overwrite);
          };
          EditSession2.prototype.getOverwrite = function() {
            return this.$overwrite;
          };
          EditSession2.prototype.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
          };
          EditSession2.prototype.addGutterDecoration = function(row, className) {
            if (!this.$decorations[row])
              this.$decorations[row] = "";
            this.$decorations[row] += " " + className;
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.removeGutterCustomWidget = function(row) {
            if (this.$editor) {
              this.$editor.renderer.$gutterLayer.$removeCustomWidget(row);
            }
          };
          EditSession2.prototype.addGutterCustomWidget = function(row, attributes) {
            if (this.$editor) {
              this.$editor.renderer.$gutterLayer.$addCustomWidget(row, attributes);
            }
          };
          EditSession2.prototype.removeGutterDecoration = function(row, className) {
            this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.getBreakpoints = function() {
            return this.$breakpoints;
          };
          EditSession2.prototype.setBreakpoints = function(rows) {
            this.$breakpoints = [];
            for (var i = 0; i < rows.length; i++) {
              this.$breakpoints[rows[i]] = "ace_breakpoint";
            }
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.clearBreakpoints = function() {
            this.$breakpoints = [];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.setBreakpoint = function(row, className) {
            if (className === void 0)
              className = "ace_breakpoint";
            if (className)
              this.$breakpoints[row] = className;
            else
              delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.clearBreakpoint = function(row) {
            delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.addMarker = function(range, clazz, type2, inFront) {
            var id = this.$markerId++;
            var marker = {
              range,
              type: type2 || "line",
              renderer: typeof type2 == "function" ? type2 : null,
              clazz,
              inFront: !!inFront,
              id
            };
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return id;
          };
          EditSession2.prototype.addDynamicMarker = function(marker, inFront) {
            if (!marker.update)
              return;
            var id = this.$markerId++;
            marker.id = id;
            marker.inFront = !!inFront;
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return marker;
          };
          EditSession2.prototype.removeMarker = function(markerId) {
            var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
            if (!marker)
              return;
            var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
            delete markers[markerId];
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
          };
          EditSession2.prototype.getMarkers = function(inFront) {
            return inFront ? this.$frontMarkers : this.$backMarkers;
          };
          EditSession2.prototype.highlight = function(re) {
            if (!this.$searchHighlight) {
              var highlight = new SearchHighlight(null, "ace_selected-word", "text");
              this.$searchHighlight = this.addDynamicMarker(highlight);
            }
            this.$searchHighlight.setRegexp(re);
          };
          EditSession2.prototype.highlightLines = function(startRow, endRow, clazz, inFront) {
            if (typeof endRow != "number") {
              clazz = endRow;
              endRow = startRow;
            }
            if (!clazz)
              clazz = "ace_step";
            var range = new Range2(startRow, 0, endRow, Infinity);
            range.id = this.addMarker(range, clazz, "fullLine", inFront);
            return range;
          };
          EditSession2.prototype.setAnnotations = function(annotations) {
            this.$annotations = annotations;
            this._signal("changeAnnotation", {});
          };
          EditSession2.prototype.getAnnotations = function() {
            return this.$annotations || [];
          };
          EditSession2.prototype.clearAnnotations = function() {
            this.setAnnotations([]);
          };
          EditSession2.prototype.$detectNewLine = function(text) {
            var match2 = text.match(/^.*?(\r?\n)/m);
            if (match2) {
              this.$autoNewLine = match2[1];
            } else {
              this.$autoNewLine = "\n";
            }
          };
          EditSession2.prototype.getWordRange = function(row, column) {
            var line = this.getLine(row);
            var inToken = false;
            if (column > 0)
              inToken = !!line.charAt(column - 1).match(this.tokenRe);
            if (!inToken)
              inToken = !!line.charAt(column).match(this.tokenRe);
            if (inToken)
              var re = this.tokenRe;
            else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
              var re = /\s/;
            else
              var re = this.nonTokenRe;
            var start = column;
            if (start > 0) {
              do {
                start--;
              } while (start >= 0 && line.charAt(start).match(re));
              start++;
            }
            var end = column;
            while (end < line.length && line.charAt(end).match(re)) {
              end++;
            }
            return new Range2(row, start, row, end);
          };
          EditSession2.prototype.getAWordRange = function(row, column) {
            var wordRange = this.getWordRange(row, column);
            var line = this.getLine(wordRange.end.row);
            while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
              wordRange.end.column += 1;
            }
            return wordRange;
          };
          EditSession2.prototype.setNewLineMode = function(newLineMode) {
            this.doc.setNewLineMode(newLineMode);
          };
          EditSession2.prototype.getNewLineMode = function() {
            return this.doc.getNewLineMode();
          };
          EditSession2.prototype.setUseWorker = function(useWorker) {
            this.setOption("useWorker", useWorker);
          };
          EditSession2.prototype.getUseWorker = function() {
            return this.$useWorker;
          };
          EditSession2.prototype.onReloadTokenizer = function(e75) {
            var rows = e75.data;
            this.bgTokenizer.start(rows.first);
            this._signal("tokenizerUpdate", e75);
          };
          EditSession2.prototype.setMode = function(mode, cb) {
            if (mode && typeof mode === "object") {
              if (mode.getTokenizer)
                return this.$onChangeMode(mode);
              var options = mode;
              var path2 = options.path;
            } else {
              path2 = /**@type{string}*/
              mode || "ace/mode/text";
            }
            if (!this.$modes["ace/mode/text"])
              this.$modes["ace/mode/text"] = new TextMode();
            if (this.$modes[path2] && !options) {
              this.$onChangeMode(this.$modes[path2]);
              cb && cb();
              return;
            }
            this.$modeId = path2;
            config2.loadModule(["mode", path2], function(m) {
              if (this.destroyed) {
                return;
              }
              if (this.$modeId !== path2)
                return cb && cb();
              if (this.$modes[path2] && !options) {
                this.$onChangeMode(this.$modes[path2]);
              } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                  this.$modes[path2] = m;
                  m.$id = path2;
                }
                this.$onChangeMode(m);
              }
              cb && cb();
            }.bind(this));
            if (!this.$mode)
              this.$onChangeMode(this.$modes["ace/mode/text"], true);
          };
          EditSession2.prototype.$onChangeMode = function(mode, $isPlaceholder) {
            if (!$isPlaceholder)
              this.$modeId = mode.$id;
            if (this.$mode === mode)
              return;
            var oldMode = this.$mode;
            this.$mode = mode;
            this.$stopWorker();
            if (this.$useWorker)
              this.$startWorker();
            var tokenizer = mode.getTokenizer();
            if (tokenizer.on !== void 0) {
              var onReloadTokenizer = this.onReloadTokenizer.bind(this);
              tokenizer.on("update", onReloadTokenizer);
            }
            this.bgTokenizer.setTokenizer(tokenizer);
            this.bgTokenizer.setDocument(this.getDocument());
            this.tokenRe = mode.tokenRe;
            this.nonTokenRe = mode.nonTokenRe;
            if (!$isPlaceholder) {
              if (mode.attachToSession)
                mode.attachToSession(this);
              this.$options.wrapMethod.set.call(this, this.$wrapMethod);
              this.$setFolding(mode.foldingRules);
              this.bgTokenizer.start(0);
              this._emit("changeMode", { oldMode, mode });
            }
          };
          EditSession2.prototype.$stopWorker = function() {
            if (this.$worker) {
              this.$worker.terminate();
              this.$worker = null;
            }
          };
          EditSession2.prototype.$startWorker = function() {
            try {
              this.$worker = this.$mode.createWorker(this);
            } catch (e75) {
              config2.warn("Could not load worker", e75);
              this.$worker = null;
            }
          };
          EditSession2.prototype.getMode = function() {
            return this.$mode;
          };
          EditSession2.prototype.setScrollTop = function(scrollTop) {
            if (this.$scrollTop === scrollTop || isNaN(scrollTop))
              return;
            this.$scrollTop = scrollTop;
            this._signal("changeScrollTop", scrollTop);
          };
          EditSession2.prototype.getScrollTop = function() {
            return this.$scrollTop;
          };
          EditSession2.prototype.setScrollLeft = function(scrollLeft) {
            if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
              return;
            this.$scrollLeft = scrollLeft;
            this._signal("changeScrollLeft", scrollLeft);
          };
          EditSession2.prototype.getScrollLeft = function() {
            return this.$scrollLeft;
          };
          EditSession2.prototype.getScreenWidth = function() {
            this.$computeWidth();
            if (this.lineWidgets)
              return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
            return this.screenWidth;
          };
          EditSession2.prototype.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null)
              return this.lineWidgetsWidth;
            var width = 0;
            this.lineWidgets.forEach(function(w) {
              if (w && w.screenWidth > width)
                width = w.screenWidth;
            });
            return this.lineWidgetWidth = width;
          };
          EditSession2.prototype.$computeWidth = function(force) {
            if (this.$modified || force) {
              this.$modified = false;
              if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;
              var lines = this.doc.getAllLines();
              var cache = this.$rowLengthCache;
              var longestScreenLine = 0;
              var foldIndex = 0;
              var foldLine = this.$foldData[foldIndex];
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              var len = lines.length;
              for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                  i = foldLine.end.row + 1;
                  if (i >= len)
                    break;
                  foldLine = this.$foldData[foldIndex++];
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (cache[i] == null)
                  cache[i] = this.$getStringScreenWidth(lines[i])[0];
                if (cache[i] > longestScreenLine)
                  longestScreenLine = cache[i];
              }
              this.screenWidth = longestScreenLine;
            }
          };
          EditSession2.prototype.getLine = function(row) {
            return this.doc.getLine(row);
          };
          EditSession2.prototype.getLines = function(firstRow, lastRow) {
            return this.doc.getLines(firstRow, lastRow);
          };
          EditSession2.prototype.getLength = function() {
            return this.doc.getLength();
          };
          EditSession2.prototype.getTextRange = function(range) {
            return this.doc.getTextRange(range || this.selection.getRange());
          };
          EditSession2.prototype.insert = function(position2, text) {
            return this.doc.insert(position2, text);
          };
          EditSession2.prototype.remove = function(range) {
            return this.doc.remove(range);
          };
          EditSession2.prototype.removeFullLines = function(firstRow, lastRow) {
            return this.doc.removeFullLines(firstRow, lastRow);
          };
          EditSession2.prototype.undoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            for (var i = deltas.length - 1; i != -1; i--) {
              var delta = deltas[i];
              if (delta.action == "insert" || delta.action == "remove") {
                this.doc.revertDelta(delta);
              } else if (delta.folds) {
                this.addFolds(delta.folds);
              }
            }
            if (!dontSelect && this.$undoSelect) {
              if (deltas.selectionBefore)
                this.selection.fromJSON(deltas.selectionBefore);
              else
                this.selection.setRange(this.$getUndoSelection(deltas, true));
            }
            this.$fromUndo = false;
          };
          EditSession2.prototype.redoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            for (var i = 0; i < deltas.length; i++) {
              var delta = deltas[i];
              if (delta.action == "insert" || delta.action == "remove") {
                this.doc.$safeApplyDelta(delta);
              }
            }
            if (!dontSelect && this.$undoSelect) {
              if (deltas.selectionAfter)
                this.selection.fromJSON(deltas.selectionAfter);
              else
                this.selection.setRange(this.$getUndoSelection(deltas, false));
            }
            this.$fromUndo = false;
          };
          EditSession2.prototype.setUndoSelect = function(enable) {
            this.$undoSelect = enable;
          };
          EditSession2.prototype.$getUndoSelection = function(deltas, isUndo) {
            function isInsert(delta2) {
              return isUndo ? delta2.action !== "insert" : delta2.action === "insert";
            }
            var range, point;
            for (var i = 0; i < deltas.length; i++) {
              var delta = deltas[i];
              if (!delta.start)
                continue;
              if (!range) {
                if (isInsert(delta)) {
                  range = Range2.fromPoints(delta.start, delta.end);
                } else {
                  range = Range2.fromPoints(delta.start, delta.start);
                }
                continue;
              }
              if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                  range.setEnd(point);
                }
              } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range = Range2.fromPoints(delta.start, delta.start);
                }
              }
            }
            return range;
          };
          EditSession2.prototype.replace = function(range, text) {
            return this.doc.replace(range, text);
          };
          EditSession2.prototype.moveText = function(fromRange, toPosition, copy) {
            var text = this.getTextRange(fromRange);
            var folds = this.getFoldsInRange(fromRange);
            var toRange = Range2.fromPoints(toPosition, toPosition);
            if (!copy) {
              this.remove(fromRange);
              var rowDiff = fromRange.start.row - fromRange.end.row;
              var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
              if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                  toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                  toRange.end.column += collDiff;
              }
              if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
              }
            }
            toRange.end = this.insert(toRange.start, text);
            if (folds.length) {
              var oldStart = fromRange.start;
              var newStart = toRange.start;
              var rowDiff = newStart.row - oldStart.row;
              var collDiff = newStart.column - oldStart.column;
              this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                  x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                  x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
              }));
            }
            return toRange;
          };
          EditSession2.prototype.indentRows = function(startRow, endRow, indentString) {
            indentString = indentString.replace(/\t/g, this.getTabString());
            for (var row = startRow; row <= endRow; row++)
              this.doc.insertInLine({ row, column: 0 }, indentString);
          };
          EditSession2.prototype.outdentRows = function(range) {
            var rowRange = range.collapseRows();
            var deleteRange = new Range2(0, 0, 0, 0);
            var size = this.getTabSize();
            for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
              var line = this.getLine(i);
              deleteRange.start.row = i;
              deleteRange.end.row = i;
              for (var j = 0; j < size; ++j)
                if (line.charAt(j) != " ")
                  break;
              if (j < size && line.charAt(j) == "	") {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
              } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
              }
              this.remove(deleteRange);
            }
          };
          EditSession2.prototype.$moveLines = function(firstRow, lastRow, dir) {
            firstRow = this.getRowFoldStart(firstRow);
            lastRow = this.getRowFoldEnd(lastRow);
            if (dir < 0) {
              var row = this.getRowFoldStart(firstRow + dir);
              if (row < 0)
                return 0;
              var diff = row - firstRow;
            } else if (dir > 0) {
              var row = this.getRowFoldEnd(lastRow + dir);
              if (row > this.doc.getLength() - 1)
                return 0;
              var diff = row - lastRow;
            } else {
              firstRow = this.$clipRowToDocument(firstRow);
              lastRow = this.$clipRowToDocument(lastRow);
              var diff = lastRow - firstRow + 1;
            }
            var range = new Range2(firstRow, 0, lastRow, Number.MAX_VALUE);
            var folds = this.getFoldsInRange(range).map(function(x) {
              x = x.clone();
              x.start.row += diff;
              x.end.row += diff;
              return x;
            });
            var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
            this.doc.insertFullLines(firstRow + diff, lines);
            folds.length && this.addFolds(folds);
            return diff;
          };
          EditSession2.prototype.moveLinesUp = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, -1);
          };
          EditSession2.prototype.moveLinesDown = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 1);
          };
          EditSession2.prototype.duplicateLines = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 0);
          };
          EditSession2.prototype.$clipRowToDocument = function(row) {
            return Math.max(0, Math.min(row, this.doc.getLength() - 1));
          };
          EditSession2.prototype.$clipColumnToRow = function(row, column) {
            if (column < 0)
              return 0;
            return Math.min(this.doc.getLine(row).length, column);
          };
          EditSession2.prototype.$clipPositionToDocument = function(row, column) {
            column = Math.max(0, column);
            if (row < 0) {
              row = 0;
              column = 0;
            } else {
              var len = this.doc.getLength();
              if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len - 1).length;
              } else {
                column = Math.min(this.doc.getLine(row).length, column);
              }
            }
            return {
              row,
              column
            };
          };
          EditSession2.prototype.$clipRangeToDocument = function(range) {
            if (range.start.row < 0) {
              range.start.row = 0;
              range.start.column = 0;
            } else {
              range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
            }
            var len = this.doc.getLength() - 1;
            if (range.end.row > len) {
              range.end.row = len;
              range.end.column = this.doc.getLine(len).length;
            } else {
              range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
            }
            return range;
          };
          EditSession2.prototype.setUseWrapMode = function(useWrapMode) {
            if (useWrapMode != this.$useWrapMode) {
              this.$useWrapMode = useWrapMode;
              this.$modified = true;
              this.$resetRowCache(0);
              if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
              }
              this._signal("changeWrapMode");
            }
          };
          EditSession2.prototype.getUseWrapMode = function() {
            return this.$useWrapMode;
          };
          EditSession2.prototype.setWrapLimitRange = function(min, max) {
            if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
              this.$wrapLimitRange = { min, max };
              this.$modified = true;
              this.$bidiHandler.markAsDirty();
              if (this.$useWrapMode)
                this._signal("changeWrapMode");
            }
          };
          EditSession2.prototype.adjustWrapLimit = function(desiredLimit, $printMargin) {
            var limits = this.$wrapLimitRange;
            if (limits.max < 0)
              limits = { min: $printMargin, max: $printMargin };
            var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
            if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
              this.$wrapLimit = wrapLimit;
              this.$modified = true;
              if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
              }
              return true;
            }
            return false;
          };
          EditSession2.prototype.$constrainWrapLimit = function(wrapLimit, min, max) {
            if (min)
              wrapLimit = Math.max(min, wrapLimit);
            if (max)
              wrapLimit = Math.min(max, wrapLimit);
            return wrapLimit;
          };
          EditSession2.prototype.getWrapLimit = function() {
            return this.$wrapLimit;
          };
          EditSession2.prototype.setWrapLimit = function(limit2) {
            this.setWrapLimitRange(limit2, limit2);
          };
          EditSession2.prototype.getWrapLimitRange = function() {
            return {
              min: this.$wrapLimitRange.min,
              max: this.$wrapLimitRange.max
            };
          };
          EditSession2.prototype.$updateInternalDataOnChange = function(delta) {
            var useWrapMode = this.$useWrapMode;
            var action = delta.action;
            var start = delta.start;
            var end = delta.end;
            var firstRow = start.row;
            var lastRow = end.row;
            var len = lastRow - firstRow;
            var removedFolds = null;
            this.$updating = true;
            if (len != 0) {
              if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                  foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                  foldLine.shiftRow(-len);
                  var foldLineBefore = this.getFoldLine(firstRow);
                  if (foldLineBefore && foldLineBefore !== foldLine) {
                    foldLineBefore.merge(foldLine);
                    foldLine = foldLineBefore;
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= end.row) {
                    foldLine.shiftRow(-len);
                  }
                }
                lastRow = firstRow;
              } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                  var cmp = foldLine.range.compareInside(start.row, start.column);
                  if (cmp == 0) {
                    foldLine = foldLine.split(start.row, start.column);
                    if (foldLine) {
                      foldLine.shiftRow(len);
                      foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                    }
                  } else if (cmp == -1) {
                    foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                    foldLine.shiftRow(len);
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= firstRow) {
                    foldLine.shiftRow(len);
                  }
                }
              }
            } else {
              len = Math.abs(delta.start.column - delta.end.column);
              if (action === "remove") {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                len = -len;
              }
              var foldLine = this.getFoldLine(firstRow);
              if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
              }
            }
            if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
              console.error("doc.getLength() and $wrapData.length have to be the same!");
            }
            this.$updating = false;
            if (useWrapMode)
              this.$updateWrapData(firstRow, lastRow);
            else
              this.$updateRowLengthCache(firstRow, lastRow);
            return removedFolds;
          };
          EditSession2.prototype.$updateRowLengthCache = function(firstRow, lastRow) {
            this.$rowLengthCache[firstRow] = null;
            this.$rowLengthCache[lastRow] = null;
          };
          EditSession2.prototype.$updateWrapData = function(firstRow, lastRow) {
            var lines = this.doc.getAllLines();
            var tabSize = this.getTabSize();
            var wrapData = this.$wrapData;
            var wrapLimit = this.$wrapLimit;
            var tokens2;
            var foldLine;
            var row = firstRow;
            lastRow = Math.min(lastRow, lines.length - 1);
            while (row <= lastRow) {
              foldLine = this.getFoldLine(row, foldLine);
              if (!foldLine) {
                tokens2 = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens2, wrapLimit, tabSize);
                row++;
              } else {
                tokens2 = [];
                foldLine.walk(function(placeholder, row2, column, lastColumn) {
                  var walkTokens;
                  if (placeholder != null) {
                    walkTokens = this.$getDisplayTokens(placeholder, tokens2.length);
                    walkTokens[0] = PLACEHOLDER_START;
                    for (var i = 1; i < walkTokens.length; i++) {
                      walkTokens[i] = PLACEHOLDER_BODY;
                    }
                  } else {
                    walkTokens = this.$getDisplayTokens(lines[row2].substring(lastColumn, column), tokens2.length);
                  }
                  tokens2 = tokens2.concat(walkTokens);
                }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens2, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
              }
            }
          };
          EditSession2.prototype.$computeWrapSplits = function(tokens2, wrapLimit, tabSize) {
            if (tokens2.length == 0) {
              return [];
            }
            var splits = [];
            var displayLength = tokens2.length;
            var lastSplit = 0, lastDocSplit = 0;
            var isCode = this.$wrapAsCode;
            var indentedSoftWrap = this.$indentedSoftWrap;
            var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
            function getWrapIndent() {
              var indentation = 0;
              if (maxIndent === 0)
                return indentation;
              if (indentedSoftWrap) {
                for (var i = 0; i < tokens2.length; i++) {
                  var token = tokens2[i];
                  if (token == SPACE)
                    indentation += 1;
                  else if (token == TAB)
                    indentation += tabSize;
                  else if (token == TAB_SPACE)
                    continue;
                  else
                    break;
                }
              }
              if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
              return Math.min(indentation, maxIndent);
            }
            function addSplit(screenPos) {
              var len = screenPos - lastSplit;
              for (var i = lastSplit; i < screenPos; i++) {
                var ch = tokens2[i];
                if (ch === 12 || ch === 2)
                  len -= 1;
              }
              if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
              }
              lastDocSplit += len;
              splits.push(lastDocSplit);
              lastSplit = screenPos;
            }
            var indent = 0;
            while (displayLength - lastSplit > wrapLimit - indent) {
              var split = lastSplit + wrapLimit - indent;
              if (tokens2[split - 1] >= SPACE && tokens2[split] >= SPACE) {
                addSplit(split);
                continue;
              }
              if (tokens2[split] == PLACEHOLDER_START || tokens2[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                  if (tokens2[split] == PLACEHOLDER_START) {
                    break;
                  }
                }
                if (split > lastSplit) {
                  addSplit(split);
                  continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split < tokens2.length; split++) {
                  if (tokens2[split] != PLACEHOLDER_BODY) {
                    break;
                  }
                }
                if (split == tokens2.length) {
                  break;
                }
                addSplit(split);
                continue;
              }
              var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
              while (split > minSplit && tokens2[split] < PLACEHOLDER_START) {
                split--;
              }
              if (isCode) {
                while (split > minSplit && tokens2[split] < PLACEHOLDER_START) {
                  split--;
                }
                while (split > minSplit && tokens2[split] == PUNCTUATION) {
                  split--;
                }
              } else {
                while (split > minSplit && tokens2[split] < SPACE) {
                  split--;
                }
              }
              if (split > minSplit) {
                addSplit(++split);
                continue;
              }
              split = lastSplit + wrapLimit;
              if (tokens2[split] == CHAR_EXT)
                split--;
              addSplit(split - indent);
            }
            return splits;
          };
          EditSession2.prototype.$getDisplayTokens = function(str, offset) {
            var arr = [];
            var tabSize;
            offset = offset || 0;
            for (var i = 0; i < str.length; i++) {
              var c = str.charCodeAt(i);
              if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                  arr.push(TAB_SPACE);
                }
              } else if (c == 32) {
                arr.push(SPACE);
              } else if (c > 39 && c < 48 || c > 57 && c < 64) {
                arr.push(PUNCTUATION);
              } else if (c >= 4352 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
              } else {
                arr.push(CHAR);
              }
            }
            return arr;
          };
          EditSession2.prototype.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn == 0)
              return [0, 0];
            if (maxScreenColumn == null)
              maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c, column;
            for (column = 0; column < str.length; column++) {
              c = str.charCodeAt(column);
              if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
              } else if (c >= 4352 && isFullWidth(c)) {
                screenColumn += 2;
              } else {
                screenColumn += 1;
              }
              if (screenColumn > maxScreenColumn) {
                break;
              }
            }
            return [screenColumn, column];
          };
          EditSession2.prototype.getRowLength = function(row) {
            var h = 1;
            if (this.lineWidgets)
              h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            if (!this.$useWrapMode || !this.$wrapData[row])
              return h;
            else
              return this.$wrapData[row].length + h;
          };
          EditSession2.prototype.getRowLineCount = function(row) {
            if (!this.$useWrapMode || !this.$wrapData[row]) {
              return 1;
            } else {
              return this.$wrapData[row].length + 1;
            }
          };
          EditSession2.prototype.getRowWrapIndent = function(screenRow) {
            if (this.$useWrapMode) {
              var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
              var splits = this.$wrapData[pos.row];
              return splits.length && splits[0] < pos.column ? splits.indent : 0;
            } else {
              return 0;
            }
          };
          EditSession2.prototype.getScreenLastRowColumn = function(screenRow) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            return this.documentToScreenColumn(pos.row, pos.column);
          };
          EditSession2.prototype.getDocumentLastRowColumn = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.getScreenLastRowColumn(screenRow);
          };
          EditSession2.prototype.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
          };
          EditSession2.prototype.getRowSplitData = function(row) {
            if (!this.$useWrapMode) {
              return void 0;
            } else {
              return this.$wrapData[row];
            }
          };
          EditSession2.prototype.getScreenTabSize = function(screenColumn) {
            return this.$tabSize - (screenColumn % this.$tabSize | 0);
          };
          EditSession2.prototype.screenToDocumentRow = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).row;
          };
          EditSession2.prototype.screenToDocumentColumn = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).column;
          };
          EditSession2.prototype.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
            if (screenRow < 0)
              return { row: 0, column: 0 };
            var line;
            var docRow = 0;
            var docColumn = 0;
            var column;
            var row = 0;
            var rowLength = 0;
            var rowCache = this.$screenRowCache;
            var i = this.$getRowCacheIndex(rowCache, screenRow);
            var l = rowCache.length;
            if (l && i >= 0) {
              var row = rowCache[i];
              var docRow = this.$docRowCache[i];
              var doCache = screenRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var maxRow = this.getLength() - 1;
            var foldLine = this.getNextFoldLine(docRow);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row <= screenRow) {
              rowLength = this.getRowLength(docRow);
              if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
              } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                  docRow = foldLine.end.row + 1;
                  foldLine = this.getNextFoldLine(docRow, foldLine);
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
              }
              if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
              }
            }
            if (foldLine && foldLine.start.row <= docRow) {
              line = this.getFoldDisplayLine(foldLine);
              docRow = foldLine.start.row;
            } else if (row + rowLength <= screenRow || docRow > maxRow) {
              return {
                row: maxRow,
                column: this.getLine(maxRow).length
              };
            } else {
              line = this.getLine(docRow);
              foldLine = null;
            }
            var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
            if (this.$useWrapMode) {
              var splits = this.$wrapData[docRow];
              if (splits) {
                column = splits[splitIndex];
                if (splitIndex > 0 && splits.length) {
                  wrapIndent = splits.indent;
                  docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                  line = line.substring(docColumn);
                }
              }
            }
            if (offsetX !== void 0 && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
              screenColumn = this.$bidiHandler.offsetToCol(offsetX);
            docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
            if (this.$useWrapMode && docColumn >= column)
              docColumn = column - 1;
            if (foldLine)
              return foldLine.idxToPosition(docColumn);
            return { row: docRow, column: docColumn };
          };
          EditSession2.prototype.documentToScreenPosition = function(docRow, docColumn) {
            if (typeof docColumn === "undefined")
              var pos = this.$clipPositionToDocument(
                /**@type{Point}*/
                docRow.row,
                /**@type{Point}*/
                docRow.column
              );
            else
              pos = this.$clipPositionToDocument(
                /**@type{number}*/
                docRow,
                docColumn
              );
            docRow = pos.row;
            docColumn = pos.column;
            var screenRow = 0;
            var foldStartRow = null;
            var fold2 = null;
            fold2 = this.getFoldAt(docRow, docColumn, 1);
            if (fold2) {
              docRow = fold2.start.row;
              docColumn = fold2.start.column;
            }
            var rowEnd, row = 0;
            var rowCache = this.$docRowCache;
            var i = this.$getRowCacheIndex(rowCache, docRow);
            var l = rowCache.length;
            if (l && i >= 0) {
              var row = rowCache[i];
              var screenRow = this.$screenRowCache[i];
              var doCache = docRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var foldLine = this.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row < docRow) {
              if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                  break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              } else {
                rowEnd = row + 1;
              }
              screenRow += this.getRowLength(row);
              row = rowEnd;
              if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
              }
            }
            var textLine = "";
            if (foldLine && row >= foldStart) {
              textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
              foldStartRow = foldLine.start.row;
            } else {
              textLine = this.getLine(docRow).substring(0, docColumn);
              foldStartRow = docRow;
            }
            var wrapIndent = 0;
            if (this.$useWrapMode) {
              var wrapRow = this.$wrapData[foldStartRow];
              if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                  screenRow++;
                  screenRowOffset++;
                }
                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
              }
            }
            if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
              screenRow += this.lineWidgets[row].rowsAbove;
            return {
              row: screenRow,
              column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
            };
          };
          EditSession2.prototype.documentToScreenColumn = function(row, docColumn) {
            return this.documentToScreenPosition(row, docColumn).column;
          };
          EditSession2.prototype.documentToScreenRow = function(docRow, docColumn) {
            return this.documentToScreenPosition(docRow, docColumn).row;
          };
          EditSession2.prototype.getScreenLength = function() {
            var screenRows = 0;
            var fold2 = null;
            if (!this.$useWrapMode) {
              screenRows = this.getLength();
              var foldData = this.$foldData;
              for (var i = 0; i < foldData.length; i++) {
                fold2 = foldData[i];
                screenRows -= fold2.end.row - fold2.start.row;
              }
            } else {
              var lastRow = this.$wrapData.length;
              var row = 0, i = 0;
              var fold2 = this.$foldData[i++];
              var foldStart = fold2 ? fold2.start.row : Infinity;
              while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row++;
                if (row > foldStart) {
                  row = fold2.end.row + 1;
                  fold2 = this.$foldData[i++];
                  foldStart = fold2 ? fold2.start.row : Infinity;
                }
              }
            }
            if (this.lineWidgets)
              screenRows += this.$getWidgetScreenLength();
            return screenRows;
          };
          EditSession2.prototype.$setFontMetrics = function(fm) {
            if (!this.$enableVarChar)
              return;
            this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
              if (maxScreenColumn === 0)
                return [0, 0];
              if (!maxScreenColumn)
                maxScreenColumn = Infinity;
              screenColumn = screenColumn || 0;
              var c, column;
              for (column = 0; column < str.length; column++) {
                c = str.charAt(column);
                if (c === "	") {
                  screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                  screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn > maxScreenColumn) {
                  break;
                }
              }
              return [screenColumn, column];
            };
          };
          EditSession2.prototype.getPrecedingCharacter = function() {
            var pos = this.selection.getCursor();
            if (pos.column === 0) {
              return pos.row === 0 ? "" : this.doc.getNewLineCharacter();
            }
            var currentLine = this.getLine(pos.row);
            return currentLine[pos.column - 1];
          };
          EditSession2.prototype.destroy = function() {
            if (!this.destroyed) {
              this.bgTokenizer.setDocument(null);
              this.bgTokenizer.cleanup();
              this.destroyed = true;
            }
            this.endOperation();
            this.$stopWorker();
            this.removeAllListeners();
            if (this.doc) {
              this.doc.off("change", this.$onChange);
            }
            if (this.selection) {
              this.selection.off("changeCursor", this.$onSelectionChange);
              this.selection.off("changeSelection", this.$onSelectionChange);
            }
            this.selection.detach();
          };
          return EditSession2;
        }()
      );
      EditSession.$uid = 0;
      EditSession.prototype.$modes = config2.$modes;
      EditSession.prototype.getValue = EditSession.prototype.toString;
      EditSession.prototype.$defaultUndoManager = {
        undo: function() {
        },
        redo: function() {
        },
        hasUndo: function() {
        },
        hasRedo: function() {
        },
        reset: function() {
        },
        add: function() {
        },
        addSelection: function() {
        },
        startNewGroup: function() {
        },
        addSession: function() {
        }
      };
      EditSession.prototype.$overwrite = false;
      EditSession.prototype.$mode = null;
      EditSession.prototype.$modeId = null;
      EditSession.prototype.$scrollTop = 0;
      EditSession.prototype.$scrollLeft = 0;
      EditSession.prototype.$wrapLimit = 80;
      EditSession.prototype.$useWrapMode = false;
      EditSession.prototype.$wrapLimitRange = {
        min: null,
        max: null
      };
      EditSession.prototype.lineWidgets = null;
      EditSession.prototype.isFullWidth = isFullWidth;
      oop.implement(EditSession.prototype, EventEmitter);
      var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
      function isFullWidth(c) {
        if (c < 4352)
          return false;
        return c >= 4352 && c <= 4447 || c >= 4515 && c <= 4519 || c >= 4602 && c <= 4607 || c >= 9001 && c <= 9002 || c >= 11904 && c <= 11929 || c >= 11931 && c <= 12019 || c >= 12032 && c <= 12245 || c >= 12272 && c <= 12283 || c >= 12288 && c <= 12350 || c >= 12353 && c <= 12438 || c >= 12441 && c <= 12543 || c >= 12549 && c <= 12589 || c >= 12593 && c <= 12686 || c >= 12688 && c <= 12730 || c >= 12736 && c <= 12771 || c >= 12784 && c <= 12830 || c >= 12832 && c <= 12871 || c >= 12880 && c <= 13054 || c >= 13056 && c <= 19903 || c >= 19968 && c <= 42124 || c >= 42128 && c <= 42182 || c >= 43360 && c <= 43388 || c >= 44032 && c <= 55203 || c >= 55216 && c <= 55238 || c >= 55243 && c <= 55291 || c >= 63744 && c <= 64255 || c >= 65040 && c <= 65049 || c >= 65072 && c <= 65106 || c >= 65108 && c <= 65126 || c >= 65128 && c <= 65131 || c >= 65281 && c <= 65376 || c >= 65504 && c <= 65510;
      }
      require2("./edit_session/folding").Folding.call(EditSession.prototype);
      require2("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
      config2.defineOptions(EditSession.prototype, "session", {
        wrap: {
          set: function(value) {
            if (!value || value == "off")
              value = false;
            else if (value == "free")
              value = true;
            else if (value == "printMargin")
              value = -1;
            else if (typeof value == "string")
              value = parseInt(value, 10) || false;
            if (this.$wrap == value)
              return;
            this.$wrap = value;
            if (!value) {
              this.setUseWrapMode(false);
            } else {
              var col = typeof value == "number" ? value : null;
              this.setWrapLimitRange(col, col);
              this.setUseWrapMode(true);
            }
          },
          get: function() {
            if (this.getUseWrapMode()) {
              if (this.$wrap == -1)
                return "printMargin";
              if (!this.getWrapLimitRange().min)
                return "free";
              return this.$wrap;
            }
            return "off";
          },
          handlesSet: true
        },
        wrapMethod: {
          set: function(val) {
            val = val == "auto" ? this.$mode.type != "text" : val != "text";
            if (val != this.$wrapAsCode) {
              this.$wrapAsCode = val;
              if (this.$useWrapMode) {
                this.$useWrapMode = false;
                this.setUseWrapMode(true);
              }
            }
          },
          initialValue: "auto"
        },
        indentedSoftWrap: {
          set: function() {
            if (this.$useWrapMode) {
              this.$useWrapMode = false;
              this.setUseWrapMode(true);
            }
          },
          initialValue: true
        },
        firstLineNumber: {
          set: function() {
            this._signal("changeBreakpoint");
          },
          initialValue: 1
        },
        useWorker: {
          set: function(useWorker) {
            this.$useWorker = useWorker;
            this.$stopWorker();
            if (useWorker)
              this.$startWorker();
          },
          initialValue: true
        },
        useSoftTabs: { initialValue: true },
        tabSize: {
          set: function(tabSize) {
            tabSize = parseInt(tabSize);
            if (tabSize > 0 && this.$tabSize !== tabSize) {
              this.$modified = true;
              this.$rowLengthCache = [];
              this.$tabSize = tabSize;
              this._signal("changeTabSize");
            }
          },
          initialValue: 4,
          handlesSet: true
        },
        navigateWithinSoftTabs: { initialValue: false },
        foldStyle: {
          set: function(val) {
            this.setFoldStyle(val);
          },
          handlesSet: true
        },
        overwrite: {
          set: function(val) {
            this._signal("changeOverwrite");
          },
          initialValue: false
        },
        newLineMode: {
          set: function(val) {
            this.doc.setNewLineMode(val);
          },
          get: function() {
            return this.doc.getNewLineMode();
          },
          handlesSet: true
        },
        mode: {
          set: function(val) {
            this.setMode(val);
          },
          get: function() {
            return this.$modeId;
          },
          handlesSet: true
        }
      });
      exports2.EditSession = EditSession;
    });
    ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var lang = require2("./lib/lang");
      var oop = require2("./lib/oop");
      var Range2 = require2("./range").Range;
      var Search = (
        /** @class */
        function() {
          function Search2() {
            this.$options = {};
          }
          Search2.prototype.set = function(options) {
            oop.mixin(this.$options, options);
            return this;
          };
          Search2.prototype.getOptions = function() {
            return lang.copyObject(this.$options);
          };
          Search2.prototype.setOptions = function(options) {
            this.$options = options;
          };
          Search2.prototype.find = function(session) {
            var options = this.$options;
            var iterator = this.$matchIterator(session, options);
            if (!iterator)
              return false;
            var firstRange = null;
            iterator.forEach(function(sr, sc, er, ec) {
              firstRange = new Range2(sr, sc, er, ec);
              if (sc == ec && options.start && /**@type{Range}*/
              options.start.start && options.skipCurrent != false && firstRange.isEqual(
                /**@type{Range}*/
                options.start
              )) {
                firstRange = null;
                return false;
              }
              return true;
            });
            return firstRange;
          };
          Search2.prototype.findAll = function(session) {
            var options = this.$options;
            if (!options.needle)
              return [];
            this.$assembleRegExp(options);
            var range = options.range;
            var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
            var ranges = [];
            var re = options.re;
            if (options.$isMultiLine) {
              var len = re.length;
              var maxRow = lines.length - len;
              var prevRange;
              outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                  if (lines[row + j].search(re[j]) == -1)
                    continue outer;
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;
                if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                  continue;
                }
                ranges.push(prevRange = new Range2(row, startIndex, row + len - 1, endIndex));
                if (len > 2)
                  row = row + len - 2;
              }
            } else {
              for (var matches, i = 0; i < lines.length; i++) {
                if (this.$isMultilineSearch(options)) {
                  var lng = lines.length - 1;
                  matches = this.$multiLineForward(session, re, i, lng);
                  if (matches) {
                    var end_row = matches.endRow <= lng ? matches.endRow - 1 : lng;
                    if (end_row > i)
                      i = end_row;
                    ranges.push(new Range2(matches.startRow, matches.startCol, matches.endRow, matches.endCol));
                  }
                } else {
                  matches = lang.getMatchOffsets(lines[i], re);
                  for (var j = 0; j < matches.length; j++) {
                    var match2 = matches[j];
                    ranges.push(new Range2(i, match2.offset, i, match2.offset + match2.length));
                  }
                }
              }
            }
            if (range) {
              var startColumn = range.start.column;
              var endColumn = range.end.column;
              var i = 0, j = ranges.length - 1;
              while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)
                i++;
              var endRow = range.end.row - range.start.row;
              while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)
                j--;
              ranges = ranges.slice(i, j + 1);
              for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
              }
            }
            return ranges;
          };
          Search2.prototype.parseReplaceString = function(replaceString) {
            var CharCode = {
              DollarSign: 36,
              Ampersand: 38,
              Digit0: 48,
              Digit1: 49,
              Digit9: 57,
              Backslash: 92,
              n: 110,
              t: 116
            };
            var replacement = "";
            for (var i = 0, len = replaceString.length; i < len; i++) {
              var chCode = replaceString.charCodeAt(i);
              if (chCode === CharCode.Backslash) {
                i++;
                if (i >= len) {
                  replacement += "\\";
                  break;
                }
                var nextChCode = replaceString.charCodeAt(i);
                switch (nextChCode) {
                  case CharCode.Backslash:
                    replacement += "\\";
                    break;
                  case CharCode.n:
                    replacement += "\n";
                    break;
                  case CharCode.t:
                    replacement += "	";
                    break;
                }
                continue;
              }
              if (chCode === CharCode.DollarSign) {
                i++;
                if (i >= len) {
                  replacement += "$";
                  break;
                }
                var nextChCode_1 = replaceString.charCodeAt(i);
                if (nextChCode_1 === CharCode.DollarSign) {
                  replacement += "$$";
                  continue;
                }
                if (nextChCode_1 === CharCode.Digit0 || nextChCode_1 === CharCode.Ampersand) {
                  replacement += "$&";
                  continue;
                }
                if (CharCode.Digit1 <= nextChCode_1 && nextChCode_1 <= CharCode.Digit9) {
                  replacement += "$" + replaceString[i];
                  continue;
                }
              }
              replacement += replaceString[i];
            }
            return replacement || replaceString;
          };
          Search2.prototype.replace = function(input, replacement) {
            var options = this.$options;
            var re = this.$assembleRegExp(options);
            if (options.$isMultiLine)
              return replacement;
            if (!re)
              return;
            var mtSearch = this.$isMultilineSearch(options);
            if (mtSearch)
              input = input.replace(/\r\n|\r|\n/g, "\n");
            var match2 = re.exec(input);
            if (!match2 || !mtSearch && match2[0].length != input.length)
              return null;
            replacement = options.regExp ? this.parseReplaceString(replacement) : replacement.replace(/\$/g, "$$$$");
            replacement = input.replace(re, replacement);
            if (options.preserveCase) {
              replacement = replacement.split("");
              for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                  replacement[i] = replacement[i].toUpperCase();
                else
                  replacement[i] = replacement[i].toLowerCase();
              }
              replacement = replacement.join("");
            }
            return replacement;
          };
          Search2.prototype.$assembleRegExp = function(options, $disableFakeMultiline) {
            if (options.needle instanceof RegExp)
              return options.re = options.needle;
            var needle = options.needle;
            if (!options.needle)
              return options.re = false;
            if (!options.regExp)
              needle = lang.escapeRegExp(needle);
            var modifier = options.caseSensitive ? "gm" : "gmi";
            try {
              new RegExp(needle, "u");
              options.$supportsUnicodeFlag = true;
              modifier += "u";
            } catch (e75) {
              options.$supportsUnicodeFlag = false;
            }
            if (options.wholeWord)
              needle = addWordBoundary(needle, options);
            options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
            if (options.$isMultiLine)
              return options.re = this.$assembleMultilineRegExp(needle, modifier);
            try {
              var re = new RegExp(needle, modifier);
            } catch (e75) {
              re = false;
            }
            return options.re = re;
          };
          Search2.prototype.$assembleMultilineRegExp = function(needle, modifier) {
            var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
            var re = [];
            for (var i = 0; i < parts.length; i++)
              try {
                re.push(new RegExp(parts[i], modifier));
              } catch (e75) {
                return false;
              }
            return re;
          };
          Search2.prototype.$isMultilineSearch = function(options) {
            return options.re && /\\r\\n|\\r|\\n/.test(options.re.source) && options.regExp && !options.$isMultiLine;
          };
          Search2.prototype.$multiLineForward = function(session, re, start, last) {
            var line, chunk = chunkEnd(session, start);
            for (var row = start; row <= last; ) {
              for (var i = 0; i < chunk; i++) {
                if (row > last)
                  break;
                var next = session.getLine(row++);
                line = line == null ? next : line + "\n" + next;
              }
              var match2 = re.exec(line);
              re.lastIndex = 0;
              if (match2) {
                var beforeMatch = line.slice(0, match2.index).split("\n");
                var matchedText = match2[0].split("\n");
                var startRow = start + beforeMatch.length - 1;
                var startCol = beforeMatch[beforeMatch.length - 1].length;
                var endRow = startRow + matchedText.length - 1;
                var endCol = matchedText.length == 1 ? startCol + matchedText[0].length : matchedText[matchedText.length - 1].length;
                return {
                  startRow,
                  startCol,
                  endRow,
                  endCol
                };
              }
            }
            return null;
          };
          Search2.prototype.$multiLineBackward = function(session, re, endIndex, start, first) {
            var line, chunk = chunkEnd(session, start), endMargin = session.getLine(start).length - endIndex;
            for (var row = start; row >= first; ) {
              for (var i = 0; i < chunk && row >= first; i++) {
                var next = session.getLine(row--);
                line = line == null ? next : next + "\n" + line;
              }
              var match2 = multiLineBackwardMatch(line, re, endMargin);
              if (match2) {
                var beforeMatch = line.slice(0, match2.index).split("\n");
                var matchedText = match2[0].split("\n");
                var startRow = row + beforeMatch.length;
                var startCol = beforeMatch[beforeMatch.length - 1].length;
                var endRow = startRow + matchedText.length - 1;
                var endCol = matchedText.length == 1 ? startCol + matchedText[0].length : matchedText[matchedText.length - 1].length;
                return {
                  startRow,
                  startCol,
                  endRow,
                  endCol
                };
              }
            }
            return null;
          };
          Search2.prototype.$matchIterator = function(session, options) {
            var re = this.$assembleRegExp(options);
            if (!re)
              return false;
            var mtSearch = this.$isMultilineSearch(options);
            var mtForward = this.$multiLineForward;
            var mtBackward = this.$multiLineBackward;
            var backwards = options.backwards == true;
            var skipCurrent = options.skipCurrent != false;
            var supportsUnicodeFlag = re.unicode;
            var range = options.range;
            var start = options.start;
            if (!start)
              start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
            if (start.start)
              start = start[skipCurrent != backwards ? "end" : "start"];
            var firstRow = range ? range.start.row : 0;
            var lastRow = range ? range.end.row : session.getLength() - 1;
            if (backwards) {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row--; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
              };
            } else {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row = row + 1; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
              };
            }
            if (options.$isMultiLine) {
              var len = re.length;
              var forEachInLine = function(row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0 || startRow + len > session.getLength())
                  return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re[0]);
                if (!backwards && startIndex < offset || startIndex === -1)
                  return;
                for (var i = 1; i < len; i++) {
                  line = session.getLine(startRow + i);
                  if (line.search(re[i]) == -1)
                    return;
                }
                var endIndex = line.match(re[len - 1])[0].length;
                if (backwards && endIndex > offset)
                  return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                  return true;
              };
            } else if (backwards) {
              var forEachInLine = function(row, endIndex, callback) {
                if (mtSearch) {
                  var pos = mtBackward(session, re, endIndex, row, firstRow);
                  if (!pos)
                    return false;
                  if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
                    return true;
                } else {
                  var line = session.getLine(row);
                  var matches = [];
                  var m, last = 0;
                  re.lastIndex = 0;
                  while (m = re.exec(line)) {
                    var length = m[0].length;
                    last = m.index;
                    if (!length) {
                      if (last >= line.length)
                        break;
                      re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                    }
                    if (m.index + length > endIndex)
                      break;
                    matches.push(m.index, length);
                  }
                  for (var i = matches.length - 1; i >= 0; i -= 2) {
                    var column = matches[i - 1];
                    var length = matches[i];
                    if (callback(row, column, row, column + length))
                      return true;
                  }
                }
              };
            } else {
              var forEachInLine = function(row, startIndex, callback) {
                re.lastIndex = startIndex;
                if (mtSearch) {
                  var pos = mtForward(session, re, row, lastRow);
                  if (pos) {
                    var end_row = pos.endRow <= lastRow ? pos.endRow - 1 : lastRow;
                    if (end_row > row)
                      row = end_row;
                  }
                  if (!pos)
                    return false;
                  if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
                    return true;
                } else {
                  var line = session.getLine(row);
                  var last;
                  var m;
                  while (m = re.exec(line)) {
                    var length = m[0].length;
                    last = m.index;
                    if (callback(row, last, row, last + length))
                      return true;
                    if (!length) {
                      re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                      if (last >= line.length)
                        return false;
                    }
                  }
                }
              };
            }
            return { forEach };
          };
          return Search2;
        }()
      );
      function addWordBoundary(needle, options) {
        var supportsLookbehind = lang.supportsLookbehind();
        function wordBoundary(c, firstChar2) {
          if (firstChar2 === void 0) {
            firstChar2 = true;
          }
          var wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]", "u") : new RegExp("\\w");
          if (wordRegExp.test(c) || options.regExp) {
            if (supportsLookbehind && options.$supportsUnicodeFlag) {
              if (firstChar2)
                return "(?<=^|[^\\p{L}\\p{N}_])";
              return "(?=[^\\p{L}\\p{N}_]|$)";
            }
            return "\\b";
          }
          return "";
        }
        var needleArray = Array.from(needle);
        var firstChar = needleArray[0];
        var lastChar = needleArray[needleArray.length - 1];
        return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);
      }
      function multiLineBackwardMatch(line, re, endMargin) {
        var match2 = null;
        var from = 0;
        while (from <= line.length) {
          re.lastIndex = from;
          var newMatch = re.exec(line);
          if (!newMatch)
            break;
          var end = newMatch.index + newMatch[0].length;
          if (end > line.length - endMargin)
            break;
          if (!match2 || end > match2.index + match2[0].length)
            match2 = newMatch;
          from = newMatch.index + 1;
        }
        return match2;
      }
      function chunkEnd(session, start) {
        var base = 5e3, startPosition = { row: start, column: 0 }, startIndex = session.doc.positionToIndex(startPosition), targetIndex = startIndex + base, targetPosition = session.doc.indexToPosition(targetIndex), targetLine = targetPosition.row;
        return targetLine + 1;
      }
      exports2.Search = Search;
    });
    ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var keyUtil = require2("../lib/keys");
      var useragent = require2("../lib/useragent");
      var KEY_MODS = keyUtil.KEY_MODS;
      var MultiHashHandler = (
        /** @class */
        function() {
          function MultiHashHandler2(config2, platform) {
            this.$init(config2, platform, false);
          }
          MultiHashHandler2.prototype.$init = function(config2, platform, $singleCommand) {
            this.platform = platform || (useragent.isMac ? "mac" : "win");
            this.commands = {};
            this.commandKeyBinding = {};
            this.addCommands(config2);
            this.$singleCommand = $singleCommand;
          };
          MultiHashHandler2.prototype.addCommand = function(command) {
            if (this.commands[command.name])
              this.removeCommand(command);
            this.commands[command.name] = command;
            if (command.bindKey)
              this._buildKeyHash(command);
          };
          MultiHashHandler2.prototype.removeCommand = function(command, keepCommand) {
            var name = command && (typeof command === "string" ? command : command.name);
            command = this.commands[name];
            if (!keepCommand)
              delete this.commands[name];
            var ckb = this.commandKeyBinding;
            for (var keyId in ckb) {
              var cmdGroup = ckb[keyId];
              if (cmdGroup == command) {
                delete ckb[keyId];
              } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                  cmdGroup.splice(i, 1);
                  if (cmdGroup.length == 1)
                    ckb[keyId] = cmdGroup[0];
                }
              }
            }
          };
          MultiHashHandler2.prototype.bindKey = function(key, command, position2) {
            if (typeof key == "object" && key) {
              if (position2 == void 0)
                position2 = key.position;
              key = key[this.platform];
            }
            if (!key)
              return;
            if (typeof command == "function")
              return this.addCommand({ exec: command, bindKey: key, name: command.name || /**@type{string}*/
              key });
            key.split("|").forEach(function(keyPart) {
              var chain = "";
              if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart2) {
                  var binding2 = this.parseKeys(keyPart2);
                  var id2 = KEY_MODS[binding2.hashId] + binding2.key;
                  chain += (chain ? " " : "") + id2;
                  this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
              }
              var binding = this.parseKeys(keyPart);
              var id = KEY_MODS[binding.hashId] + binding.key;
              this._addCommandToBinding(chain + id, command, position2);
            }, this);
          };
          MultiHashHandler2.prototype._addCommandToBinding = function(keyId, command, position2) {
            var ckb = this.commandKeyBinding, i;
            if (!command) {
              delete ckb[keyId];
            } else if (!ckb[keyId] || this.$singleCommand) {
              ckb[keyId] = command;
            } else {
              if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
              } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
              }
              if (typeof position2 != "number") {
                position2 = getPosition(command);
              }
              var commands = ckb[keyId];
              for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position2)
                  break;
              }
              commands.splice(i, 0, command);
            }
          };
          MultiHashHandler2.prototype.addCommands = function(commands) {
            commands && Object.keys(commands).forEach(function(name) {
              var command = commands[name];
              if (!command)
                return;
              if (typeof command === "string")
                return this.bindKey(command, name);
              if (typeof command === "function")
                command = { exec: command };
              if (typeof command !== "object")
                return;
              if (!command.name)
                command.name = name;
              this.addCommand(command);
            }, this);
          };
          MultiHashHandler2.prototype.removeCommands = function(commands) {
            Object.keys(commands).forEach(function(name) {
              this.removeCommand(commands[name]);
            }, this);
          };
          MultiHashHandler2.prototype.bindKeys = function(keyList) {
            Object.keys(keyList).forEach(function(key) {
              this.bindKey(key, keyList[key]);
            }, this);
          };
          MultiHashHandler2.prototype._buildKeyHash = function(command) {
            this.bindKey(command.bindKey, command);
          };
          MultiHashHandler2.prototype.parseKeys = function(keys) {
            var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
              return x;
            });
            var key = parts.pop();
            var keyCode = keyUtil[key];
            if (keyUtil.FUNCTION_KEYS[keyCode])
              key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
            else if (!parts.length)
              return { key, hashId: -1 };
            else if (parts.length == 1 && parts[0] == "shift")
              return { key: key.toUpperCase(), hashId: -1 };
            var hashId = 0;
            for (var i = parts.length; i--; ) {
              var modifier = keyUtil.KEY_MODS[parts[i]];
              if (modifier == null) {
                if (typeof console != "undefined")
                  console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
              }
              hashId |= modifier;
            }
            return { key, hashId };
          };
          MultiHashHandler2.prototype.findKeyCommand = function(hashId, keyString) {
            var key = KEY_MODS[hashId] + keyString;
            return this.commandKeyBinding[key];
          };
          MultiHashHandler2.prototype.handleKeyboard = function(data, hashId, keyString, keyCode) {
            if (keyCode < 0)
              return;
            var key = KEY_MODS[hashId] + keyString;
            var command = this.commandKeyBinding[key];
            if (data.$keyChain) {
              data.$keyChain += " " + key;
              command = this.commandKeyBinding[data.$keyChain] || command;
            }
            if (command) {
              if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return { command: "null" };
              }
            }
            if (data.$keyChain) {
              if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
              else if (hashId == -1 || keyCode > 0)
                data.$keyChain = "";
            }
            return { command };
          };
          MultiHashHandler2.prototype.getStatusText = function(editor2, data) {
            return data.$keyChain || "";
          };
          return MultiHashHandler2;
        }()
      );
      function getPosition(command) {
        return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
      }
      var HashHandler = (
        /** @class */
        function(_super) {
          __extends(HashHandler2, _super);
          function HashHandler2(config2, platform) {
            var _this = _super.call(this, config2, platform) || this;
            _this.$singleCommand = true;
            return _this;
          }
          return HashHandler2;
        }(MultiHashHandler)
      );
      HashHandler.call = function(thisArg, config2, platform) {
        MultiHashHandler.prototype.$init.call(thisArg, config2, platform, true);
      };
      MultiHashHandler.call = function(thisArg, config2, platform) {
        MultiHashHandler.prototype.$init.call(thisArg, config2, platform, false);
      };
      exports2.HashHandler = HashHandler;
      exports2.MultiHashHandler = MultiHashHandler;
    });
    ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var oop = require2("../lib/oop");
      var MultiHashHandler = require2("../keyboard/hash_handler").MultiHashHandler;
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var CommandManager = (
        /** @class */
        function(_super) {
          __extends(CommandManager2, _super);
          function CommandManager2(platform, commands) {
            var _this = _super.call(this, commands, platform) || this;
            _this.byName = _this.commands;
            _this.setDefaultHandler("exec", function(e75) {
              if (!e75.args) {
                return e75.command.exec(e75.editor, {}, e75.event, true);
              }
              return e75.command.exec(e75.editor, e75.args, e75.event, false);
            });
            return _this;
          }
          CommandManager2.prototype.exec = function(command, editor2, args) {
            if (Array.isArray(command)) {
              for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor2, args))
                  return true;
              }
              return false;
            }
            if (typeof command === "string")
              command = this.commands[command];
            var e75 = { editor: editor2, command, args };
            if (!this.canExecute(command, editor2)) {
              this._signal("commandUnavailable", e75);
              return false;
            }
            e75.returnValue = this._emit("exec", e75);
            this._signal("afterExec", e75);
            return e75.returnValue === false ? false : true;
          };
          CommandManager2.prototype.canExecute = function(command, editor2) {
            if (typeof command === "string")
              command = this.commands[command];
            if (!command)
              return false;
            if (editor2 && editor2.$readOnly && !command.readOnly)
              return false;
            if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor2))
              return false;
            return true;
          };
          CommandManager2.prototype.toggleRecording = function(editor2) {
            if (this.$inReplay)
              return;
            editor2 && editor2._emit("changeStatus");
            if (this.recording) {
              this.macro.pop();
              this.off("exec", this.$addCommandToMacro);
              if (!this.macro.length)
                this.macro = this.oldMacro;
              return this.recording = false;
            }
            if (!this.$addCommandToMacro) {
              this.$addCommandToMacro = function(e75) {
                this.macro.push([e75.command, e75.args]);
              }.bind(this);
            }
            this.oldMacro = this.macro;
            this.macro = [];
            this.on("exec", this.$addCommandToMacro);
            return this.recording = true;
          };
          CommandManager2.prototype.replay = function(editor2) {
            if (this.$inReplay || !this.macro)
              return;
            if (this.recording)
              return this.toggleRecording(editor2);
            try {
              this.$inReplay = true;
              this.macro.forEach(function(x) {
                if (typeof x == "string")
                  this.exec(x, editor2);
                else
                  this.exec(x[0], editor2, x[1]);
              }, this);
            } finally {
              this.$inReplay = false;
            }
          };
          CommandManager2.prototype.trimMacro = function(m) {
            return m.map(function(x) {
              if (typeof x[0] != "string")
                x[0] = x[0].name;
              if (!x[1])
                x = x[0];
              return x;
            });
          };
          return CommandManager2;
        }(MultiHashHandler)
      );
      oop.implement(CommandManager.prototype, EventEmitter);
      exports2.CommandManager = CommandManager;
    });
    ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var lang = require2("../lib/lang");
      var config2 = require2("../config");
      var Range2 = require2("../range").Range;
      function bindKey(win, mac) {
        return { win, mac };
      }
      exports2.commands = [
        {
          name: "showSettingsMenu",
          description: "Show settings menu",
          bindKey: bindKey("Ctrl-,", "Command-,"),
          exec: function(editor2) {
            config2.loadModule("ace/ext/settings_menu", function(module3) {
              module3.init(editor2);
              editor2.showSettingsMenu();
            });
          },
          readOnly: true
        },
        {
          name: "goToNextError",
          description: "Go to next error",
          bindKey: bindKey("Alt-E", "F4"),
          exec: function(editor2) {
            config2.loadModule("ace/ext/error_marker", function(module3) {
              module3.showErrorMarker(editor2, 1);
            });
          },
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "goToPreviousError",
          description: "Go to previous error",
          bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
          exec: function(editor2) {
            config2.loadModule("ace/ext/error_marker", function(module3) {
              module3.showErrorMarker(editor2, -1);
            });
          },
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "selectall",
          description: "Select all",
          bindKey: bindKey("Ctrl-A", "Command-A"),
          exec: function(editor2) {
            editor2.selectAll();
          },
          readOnly: true
        },
        {
          name: "centerselection",
          description: "Center selection",
          bindKey: bindKey(null, "Ctrl-L"),
          exec: function(editor2) {
            editor2.centerSelection();
          },
          readOnly: true
        },
        {
          name: "gotoline",
          description: "Go to line...",
          bindKey: bindKey("Ctrl-L", "Command-L"),
          exec: function(editor2, line) {
            if (typeof line === "number" && !isNaN(line))
              editor2.gotoLine(line);
            editor2.prompt({ $type: "gotoLine" });
          },
          readOnly: true
        },
        {
          name: "fold",
          bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
          exec: function(editor2) {
            editor2.session.toggleFold(false);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "unfold",
          bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
          exec: function(editor2) {
            editor2.session.toggleFold(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "toggleFoldWidget",
          description: "Toggle fold widget",
          bindKey: bindKey("F2", "F2"),
          exec: function(editor2) {
            editor2.session.toggleFoldWidget();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "toggleParentFoldWidget",
          description: "Toggle parent fold widget",
          bindKey: bindKey("Alt-F2", "Alt-F2"),
          exec: function(editor2) {
            editor2.session.toggleFoldWidget(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldall",
          description: "Fold all",
          bindKey: bindKey(null, "Ctrl-Command-Option-0"),
          exec: function(editor2) {
            editor2.session.foldAll();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldAllComments",
          description: "Fold all comments",
          bindKey: bindKey(null, "Ctrl-Command-Option-0"),
          exec: function(editor2) {
            editor2.session.foldAllComments();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldOther",
          description: "Fold other",
          bindKey: bindKey("Alt-0", "Command-Option-0"),
          exec: function(editor2) {
            editor2.session.foldAll();
            editor2.session.unfold(editor2.selection.getAllRanges());
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "unfoldall",
          description: "Unfold all",
          bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
          exec: function(editor2) {
            editor2.session.unfold();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "findnext",
          description: "Find next",
          bindKey: bindKey("Ctrl-K", "Command-G"),
          exec: function(editor2) {
            editor2.findNext();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "findprevious",
          description: "Find previous",
          bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
          exec: function(editor2) {
            editor2.findPrevious();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "selectOrFindNext",
          description: "Select or find next",
          bindKey: bindKey("Alt-K", "Ctrl-G"),
          exec: function(editor2) {
            if (editor2.selection.isEmpty())
              editor2.selection.selectWord();
            else
              editor2.findNext();
          },
          readOnly: true
        },
        {
          name: "selectOrFindPrevious",
          description: "Select or find previous",
          bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
          exec: function(editor2) {
            if (editor2.selection.isEmpty())
              editor2.selection.selectWord();
            else
              editor2.findPrevious();
          },
          readOnly: true
        },
        {
          name: "find",
          description: "Find",
          bindKey: bindKey("Ctrl-F", "Command-F"),
          exec: function(editor2) {
            config2.loadModule("ace/ext/searchbox", function(e75) {
              e75.Search(editor2);
            });
          },
          readOnly: true
        },
        {
          name: "overwrite",
          description: "Overwrite",
          bindKey: "Insert",
          exec: function(editor2) {
            editor2.toggleOverwrite();
          },
          readOnly: true
        },
        {
          name: "selecttostart",
          description: "Select to start",
          bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
          exec: function(editor2) {
            editor2.getSelection().selectFileStart();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "gotostart",
          description: "Go to start",
          bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
          exec: function(editor2) {
            editor2.navigateFileStart();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "selectup",
          description: "Select up",
          bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
          exec: function(editor2) {
            editor2.getSelection().selectUp();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "golineup",
          description: "Go line up",
          bindKey: bindKey("Up", "Up|Ctrl-P"),
          exec: function(editor2, args) {
            editor2.navigateUp(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttoend",
          description: "Select to end",
          bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
          exec: function(editor2) {
            editor2.getSelection().selectFileEnd();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "gotoend",
          description: "Go to end",
          bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
          exec: function(editor2) {
            editor2.navigateFileEnd();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "selectdown",
          description: "Select down",
          bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
          exec: function(editor2) {
            editor2.getSelection().selectDown();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "golinedown",
          description: "Go line down",
          bindKey: bindKey("Down", "Down|Ctrl-N"),
          exec: function(editor2, args) {
            editor2.navigateDown(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectwordleft",
          description: "Select word left",
          bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
          exec: function(editor2) {
            editor2.getSelection().selectWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotowordleft",
          description: "Go to word left",
          bindKey: bindKey("Ctrl-Left", "Option-Left"),
          exec: function(editor2) {
            editor2.navigateWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttolinestart",
          description: "Select to line start",
          bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
          exec: function(editor2) {
            editor2.getSelection().selectLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotolinestart",
          description: "Go to line start",
          bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
          exec: function(editor2) {
            editor2.navigateLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectleft",
          description: "Select left",
          bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
          exec: function(editor2) {
            editor2.getSelection().selectLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotoleft",
          description: "Go to left",
          bindKey: bindKey("Left", "Left|Ctrl-B"),
          exec: function(editor2, args) {
            editor2.navigateLeft(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectwordright",
          description: "Select word right",
          bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
          exec: function(editor2) {
            editor2.getSelection().selectWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotowordright",
          description: "Go to word right",
          bindKey: bindKey("Ctrl-Right", "Option-Right"),
          exec: function(editor2) {
            editor2.navigateWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttolineend",
          description: "Select to line end",
          bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
          exec: function(editor2) {
            editor2.getSelection().selectLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotolineend",
          description: "Go to line end",
          bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
          exec: function(editor2) {
            editor2.navigateLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectright",
          description: "Select right",
          bindKey: bindKey("Shift-Right", "Shift-Right"),
          exec: function(editor2) {
            editor2.getSelection().selectRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotoright",
          description: "Go to right",
          bindKey: bindKey("Right", "Right|Ctrl-F"),
          exec: function(editor2, args) {
            editor2.navigateRight(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectpagedown",
          description: "Select page down",
          bindKey: "Shift-PageDown",
          exec: function(editor2) {
            editor2.selectPageDown();
          },
          readOnly: true
        },
        {
          name: "pagedown",
          description: "Page down",
          bindKey: bindKey(null, "Option-PageDown"),
          exec: function(editor2) {
            editor2.scrollPageDown();
          },
          readOnly: true
        },
        {
          name: "gotopagedown",
          description: "Go to page down",
          bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
          exec: function(editor2) {
            editor2.gotoPageDown();
          },
          readOnly: true
        },
        {
          name: "selectpageup",
          description: "Select page up",
          bindKey: "Shift-PageUp",
          exec: function(editor2) {
            editor2.selectPageUp();
          },
          readOnly: true
        },
        {
          name: "pageup",
          description: "Page up",
          bindKey: bindKey(null, "Option-PageUp"),
          exec: function(editor2) {
            editor2.scrollPageUp();
          },
          readOnly: true
        },
        {
          name: "gotopageup",
          description: "Go to page up",
          bindKey: "PageUp",
          exec: function(editor2) {
            editor2.gotoPageUp();
          },
          readOnly: true
        },
        {
          name: "scrollup",
          description: "Scroll up",
          bindKey: bindKey("Ctrl-Up", null),
          exec: function(e75) {
            e75.renderer.scrollBy(0, -2 * e75.renderer.layerConfig.lineHeight);
          },
          readOnly: true
        },
        {
          name: "scrolldown",
          description: "Scroll down",
          bindKey: bindKey("Ctrl-Down", null),
          exec: function(e75) {
            e75.renderer.scrollBy(0, 2 * e75.renderer.layerConfig.lineHeight);
          },
          readOnly: true
        },
        {
          name: "selectlinestart",
          description: "Select line start",
          bindKey: "Shift-Home",
          exec: function(editor2) {
            editor2.getSelection().selectLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectlineend",
          description: "Select line end",
          bindKey: "Shift-End",
          exec: function(editor2) {
            editor2.getSelection().selectLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "togglerecording",
          description: "Toggle recording",
          bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
          exec: function(editor2) {
            editor2.commands.toggleRecording(editor2);
          },
          readOnly: true
        },
        {
          name: "replaymacro",
          description: "Replay macro",
          bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
          exec: function(editor2) {
            editor2.commands.replay(editor2);
          },
          readOnly: true
        },
        {
          name: "jumptomatching",
          description: "Jump to matching",
          bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
          exec: function(editor2) {
            editor2.jumpToMatching();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "selecttomatching",
          description: "Select to matching",
          bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
          exec: function(editor2) {
            editor2.jumpToMatching(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "expandToMatching",
          description: "Expand to matching",
          bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
          exec: function(editor2) {
            editor2.jumpToMatching(true, true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "passKeysToBrowser",
          description: "Pass keys to browser",
          bindKey: bindKey(null, null),
          exec: function() {
          },
          passEvent: true,
          readOnly: true
        },
        {
          name: "copy",
          description: "Copy",
          exec: function(editor2) {
          },
          readOnly: true
        },
        {
          name: "cut",
          description: "Cut",
          exec: function(editor2) {
            var cutLine = editor2.$copyWithEmptySelection && editor2.selection.isEmpty();
            var range = cutLine ? editor2.selection.getLineRange() : editor2.selection.getRange();
            editor2._emit("cut", range);
            if (!range.isEmpty())
              editor2.session.remove(range);
            editor2.clearSelection();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "paste",
          description: "Paste",
          exec: function(editor2, args) {
            editor2.$handlePaste(args);
          },
          scrollIntoView: "cursor"
        },
        {
          name: "removeline",
          description: "Remove line",
          bindKey: bindKey("Ctrl-D", "Command-D"),
          exec: function(editor2) {
            editor2.removeLines();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEachLine"
        },
        {
          name: "duplicateSelection",
          description: "Duplicate selection",
          bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
          exec: function(editor2) {
            editor2.duplicateSelection();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "sortlines",
          description: "Sort lines",
          bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
          exec: function(editor2) {
            editor2.sortLines();
          },
          scrollIntoView: "selection",
          multiSelectAction: "forEachLine"
        },
        {
          name: "togglecomment",
          description: "Toggle comment",
          bindKey: bindKey("Ctrl-/", "Command-/"),
          exec: function(editor2) {
            editor2.toggleCommentLines();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "toggleBlockComment",
          description: "Toggle block comment",
          bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
          exec: function(editor2) {
            editor2.toggleBlockComment();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "modifyNumberUp",
          description: "Modify number up",
          bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
          exec: function(editor2) {
            editor2.modifyNumber(1);
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "modifyNumberDown",
          description: "Modify number down",
          bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
          exec: function(editor2) {
            editor2.modifyNumber(-1);
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "replace",
          description: "Replace",
          bindKey: bindKey("Ctrl-H", "Command-Option-F"),
          exec: function(editor2) {
            config2.loadModule("ace/ext/searchbox", function(e75) {
              e75.Search(editor2, true);
            });
          }
        },
        {
          name: "undo",
          description: "Undo",
          bindKey: bindKey("Ctrl-Z", "Command-Z"),
          exec: function(editor2) {
            editor2.undo();
          }
        },
        {
          name: "redo",
          description: "Redo",
          bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
          exec: function(editor2) {
            editor2.redo();
          }
        },
        {
          name: "copylinesup",
          description: "Copy lines up",
          bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
          exec: function(editor2) {
            editor2.copyLinesUp();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "movelinesup",
          description: "Move lines up",
          bindKey: bindKey("Alt-Up", "Option-Up"),
          exec: function(editor2) {
            editor2.moveLinesUp();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "copylinesdown",
          description: "Copy lines down",
          bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
          exec: function(editor2) {
            editor2.copyLinesDown();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "movelinesdown",
          description: "Move lines down",
          bindKey: bindKey("Alt-Down", "Option-Down"),
          exec: function(editor2) {
            editor2.moveLinesDown();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "del",
          description: "Delete",
          bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
          exec: function(editor2) {
            editor2.remove("right");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "backspace",
          description: "Backspace",
          bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
          exec: function(editor2) {
            editor2.remove("left");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "cut_or_delete",
          description: "Cut or delete",
          bindKey: bindKey("Shift-Delete", null),
          exec: function(editor2) {
            if (editor2.selection.isEmpty()) {
              editor2.remove("left");
            } else {
              return false;
            }
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolinestart",
          description: "Remove to line start",
          bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
          exec: function(editor2) {
            editor2.removeToLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolineend",
          description: "Remove to line end",
          bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
          exec: function(editor2) {
            editor2.removeToLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolinestarthard",
          description: "Remove to line start hard",
          bindKey: bindKey("Ctrl-Shift-Backspace", null),
          exec: function(editor2) {
            var range = editor2.selection.getRange();
            range.start.column = 0;
            editor2.session.remove(range);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolineendhard",
          description: "Remove to line end hard",
          bindKey: bindKey("Ctrl-Shift-Delete", null),
          exec: function(editor2) {
            var range = editor2.selection.getRange();
            range.end.column = Number.MAX_VALUE;
            editor2.session.remove(range);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removewordleft",
          description: "Remove word left",
          bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
          exec: function(editor2) {
            editor2.removeWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removewordright",
          description: "Remove word right",
          bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
          exec: function(editor2) {
            editor2.removeWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "outdent",
          description: "Outdent",
          bindKey: bindKey("Shift-Tab", "Shift-Tab"),
          exec: function(editor2) {
            editor2.blockOutdent();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "indent",
          description: "Indent",
          bindKey: bindKey("Tab", "Tab"),
          exec: function(editor2) {
            editor2.indent();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "blockoutdent",
          description: "Block outdent",
          bindKey: bindKey("Ctrl-[", "Ctrl-["),
          exec: function(editor2) {
            editor2.blockOutdent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "blockindent",
          description: "Block indent",
          bindKey: bindKey("Ctrl-]", "Ctrl-]"),
          exec: function(editor2) {
            editor2.blockIndent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "insertstring",
          description: "Insert string",
          exec: function(editor2, str) {
            editor2.insert(str);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "inserttext",
          description: "Insert text",
          exec: function(editor2, args) {
            editor2.insert(lang.stringRepeat(args.text || "", args.times || 1));
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "splitline",
          description: "Split line",
          bindKey: bindKey(null, "Ctrl-O"),
          exec: function(editor2) {
            editor2.splitLine();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "transposeletters",
          description: "Transpose letters",
          bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
          exec: function(editor2) {
            editor2.transposeLetters();
          },
          multiSelectAction: function(editor2) {
            editor2.transposeSelections(1);
          },
          scrollIntoView: "cursor"
        },
        {
          name: "touppercase",
          description: "To uppercase",
          bindKey: bindKey("Ctrl-U", "Ctrl-U"),
          exec: function(editor2) {
            editor2.toUpperCase();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "tolowercase",
          description: "To lowercase",
          bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
          exec: function(editor2) {
            editor2.toLowerCase();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "autoindent",
          description: "Auto Indent",
          bindKey: bindKey(null, null),
          exec: function(editor2) {
            editor2.autoIndent();
          },
          scrollIntoView: "animate"
        },
        {
          name: "expandtoline",
          description: "Expand to line",
          bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
          exec: function(editor2) {
            var range = editor2.selection.getRange();
            range.start.column = range.end.column = 0;
            range.end.row++;
            editor2.selection.setRange(range, false);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "openlink",
          bindKey: bindKey("Ctrl+F3", "F3"),
          exec: function(editor2) {
            editor2.openLink();
          }
        },
        {
          name: "joinlines",
          description: "Join lines",
          bindKey: bindKey(null, null),
          exec: function(editor2) {
            var isBackwards = editor2.selection.isBackwards();
            var selectionStart = isBackwards ? editor2.selection.getSelectionLead() : editor2.selection.getSelectionAnchor();
            var selectionEnd = isBackwards ? editor2.selection.getSelectionAnchor() : editor2.selection.getSelectionLead();
            var firstLineEndCol = editor2.session.doc.getLine(selectionStart.row).length;
            var selectedText = editor2.session.doc.getTextRange(editor2.selection.getRange());
            var selectedCount = selectedText.replace(/\n\s*/, " ").length;
            var insertLine = editor2.session.doc.getLine(selectionStart.row);
            for (var i2 = selectionStart.row + 1; i2 <= selectionEnd.row + 1; i2++) {
              var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor2.session.doc.getLine(i2)));
              if (curLine.length !== 0) {
                curLine = " " + curLine;
              }
              insertLine += curLine;
            }
            if (selectionEnd.row + 1 < editor2.session.doc.getLength() - 1) {
              insertLine += editor2.session.doc.getNewLineCharacter();
            }
            editor2.clearSelection();
            editor2.session.doc.replace(new Range2(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
            if (selectedCount > 0) {
              editor2.selection.moveCursorTo(selectionStart.row, selectionStart.column);
              editor2.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
            } else {
              firstLineEndCol = editor2.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
              editor2.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
            }
          },
          multiSelectAction: "forEach",
          readOnly: true
        },
        {
          name: "invertSelection",
          description: "Invert selection",
          bindKey: bindKey(null, null),
          exec: function(editor2) {
            var endRow = editor2.session.doc.getLength() - 1;
            var endCol = editor2.session.doc.getLine(endRow).length;
            var ranges = editor2.selection.rangeList.ranges;
            var newRanges = [];
            if (ranges.length < 1) {
              ranges = [editor2.selection.getRange()];
            }
            for (var i2 = 0; i2 < ranges.length; i2++) {
              if (i2 == ranges.length - 1) {
                if (!(ranges[i2].end.row === endRow && ranges[i2].end.column === endCol)) {
                  newRanges.push(new Range2(ranges[i2].end.row, ranges[i2].end.column, endRow, endCol));
                }
              }
              if (i2 === 0) {
                if (!(ranges[i2].start.row === 0 && ranges[i2].start.column === 0)) {
                  newRanges.push(new Range2(0, 0, ranges[i2].start.row, ranges[i2].start.column));
                }
              } else {
                newRanges.push(new Range2(ranges[i2 - 1].end.row, ranges[i2 - 1].end.column, ranges[i2].start.row, ranges[i2].start.column));
              }
            }
            editor2.exitMultiSelectMode();
            editor2.clearSelection();
            for (var i2 = 0; i2 < newRanges.length; i2++) {
              editor2.selection.addRange(newRanges[i2], false);
            }
          },
          readOnly: true,
          scrollIntoView: "none"
        },
        {
          name: "addLineAfter",
          description: "Add new line after the current line",
          exec: function(editor2) {
            editor2.selection.clearSelection();
            editor2.navigateLineEnd();
            editor2.insert("\n");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "addLineBefore",
          description: "Add new line before the current line",
          exec: function(editor2) {
            editor2.selection.clearSelection();
            var cursor = editor2.getCursorPosition();
            editor2.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
            editor2.insert("\n");
            if (cursor.row === 0)
              editor2.navigateUp();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "openCommandPallete",
          exec: function(editor2) {
            console.warn("This is an obsolete command. Please use `openCommandPalette` instead.");
            editor2.prompt({ $type: "commands" });
          },
          readOnly: true
        },
        {
          name: "openCommandPalette",
          description: "Open command palette",
          bindKey: bindKey("F1", "F1"),
          exec: function(editor2) {
            editor2.prompt({ $type: "commands" });
          },
          readOnly: true
        },
        {
          name: "modeSelect",
          description: "Change language mode...",
          bindKey: bindKey(null, null),
          exec: function(editor2) {
            editor2.prompt({ $type: "modes" });
          },
          readOnly: true
        }
      ];
      for (var i = 1; i < 9; i++) {
        exports2.commands.push({
          name: "foldToLevel" + i,
          description: "Fold To Level " + i,
          level: i,
          exec: function(editor2) {
            editor2.session.foldToLevel(this.level);
          },
          scrollIntoView: "center",
          readOnly: true
        });
      }
    });
    ace.define("ace/keyboard/gutter_handler", ["require", "exports", "module", "ace/lib/keys", "ace/mouse/default_gutter_handler"], function(require2, exports2, module2) {
      "use strict";
      var keys = require2("../lib/keys");
      var GutterTooltip = require2("../mouse/default_gutter_handler").GutterTooltip;
      var GutterKeyboardHandler = (
        /** @class */
        function() {
          function GutterKeyboardHandler2(editor2) {
            this.editor = editor2;
            this.gutterLayer = editor2.renderer.$gutterLayer;
            this.element = editor2.renderer.$gutter;
            this.lines = editor2.renderer.$gutterLayer.$lines;
            this.activeRowIndex = null;
            this.activeLane = null;
            this.annotationTooltip = new GutterTooltip(this.editor);
          }
          GutterKeyboardHandler2.prototype.addListener = function() {
            this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this));
            this.element.addEventListener("focusout", this.$blurGutter.bind(this));
            this.editor.on("mousewheel", this.$blurGutter.bind(this));
          };
          GutterKeyboardHandler2.prototype.removeListener = function() {
            this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this));
            this.element.removeEventListener("focusout", this.$blurGutter.bind(this));
            this.editor.off("mousewheel", this.$blurGutter.bind(this));
          };
          GutterKeyboardHandler2.prototype.$onGutterKeyDown = function(e75) {
            if (this.annotationTooltip.isOpen) {
              e75.preventDefault();
              if (e75.keyCode === keys["escape"])
                this.annotationTooltip.hideTooltip();
              return;
            }
            if (e75.target === this.element) {
              if (e75.keyCode != keys["enter"]) {
                return;
              }
              e75.preventDefault();
              var row = this.editor.getCursorPosition().row;
              if (!this.editor.isRowVisible(row))
                this.editor.scrollToLine(row, true, true);
              setTimeout(
                function() {
                  var index = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);
                  var nearestFoldLaneWidgetIndex = this.$findNearestFoldLaneWidget(index);
                  var nearestAnnotationIndex = this.$findNearestAnnotation(index);
                  if (nearestFoldLaneWidgetIndex === null && nearestAnnotationIndex === null)
                    return;
                  var futureActiveRowIndex = this.$findClosestNumber(nearestFoldLaneWidgetIndex, nearestAnnotationIndex, index);
                  if (futureActiveRowIndex === nearestFoldLaneWidgetIndex) {
                    this.activeLane = "fold";
                    this.activeRowIndex = nearestFoldLaneWidgetIndex;
                    if (this.$isCustomWidgetVisible(nearestFoldLaneWidgetIndex)) {
                      this.$focusCustomWidget(this.activeRowIndex);
                      return;
                    } else {
                      this.$focusFoldWidget(this.activeRowIndex);
                      return;
                    }
                  } else {
                    this.activeRowIndex = nearestAnnotationIndex;
                    this.activeLane = "annotation";
                    this.$focusAnnotation(this.activeRowIndex);
                    return;
                  }
                }.bind(this),
                10
              );
              return;
            }
            this.$handleGutterKeyboardInteraction(e75);
            setTimeout(function() {
              this.editor._signal("gutterkeydown", new GutterKeyboardEvent(e75, this));
            }.bind(this), 10);
          };
          GutterKeyboardHandler2.prototype.$handleGutterKeyboardInteraction = function(e75) {
            if (e75.keyCode === keys["tab"]) {
              e75.preventDefault();
              return;
            }
            if (e75.keyCode === keys["escape"]) {
              e75.preventDefault();
              this.$blurGutter();
              this.element.focus();
              this.lane = null;
              return;
            }
            if (e75.keyCode === keys["up"]) {
              e75.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  this.$moveFoldWidgetUp();
                  break;
                case "annotation":
                  this.$moveAnnotationUp();
                  break;
              }
              return;
            }
            if (e75.keyCode === keys["down"]) {
              e75.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  this.$moveFoldWidgetDown();
                  break;
                case "annotation":
                  this.$moveAnnotationDown();
                  break;
              }
              return;
            }
            if (e75.keyCode === keys["left"]) {
              e75.preventDefault();
              this.$switchLane("annotation");
              return;
            }
            if (e75.keyCode === keys["right"]) {
              e75.preventDefault();
              this.$switchLane("fold");
              return;
            }
            if (e75.keyCode === keys["enter"] || e75.keyCode === keys["space"]) {
              e75.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  var row = this.$rowIndexToRow(this.activeRowIndex);
                  var customWidget = this.editor.session.$gutterCustomWidgets[row];
                  if (customWidget) {
                    if (customWidget.callbacks && customWidget.callbacks.onClick) {
                      customWidget.callbacks.onClick(e75, row);
                    }
                  } else if (this.gutterLayer.session.foldWidgets[row] === "start") {
                    this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e75);
                    setTimeout(
                      function() {
                        if (this.$rowIndexToRow(this.activeRowIndex) !== row) {
                          this.$blurFoldWidget(this.activeRowIndex);
                          this.activeRowIndex = this.$rowToRowIndex(row);
                          this.$focusFoldWidget(this.activeRowIndex);
                        }
                      }.bind(this),
                      10
                    );
                    break;
                  } else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "end") {
                    break;
                  }
                  return;
                case "annotation":
                  var gutterElement = this.lines.cells[this.activeRowIndex].element.childNodes[2];
                  var rect = gutterElement.getBoundingClientRect();
                  var style = this.annotationTooltip.getElement().style;
                  style.left = rect.right + "px";
                  style.top = rect.bottom + "px";
                  this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));
                  break;
              }
              return;
            }
          };
          GutterKeyboardHandler2.prototype.$blurGutter = function() {
            if (this.activeRowIndex !== null) {
              switch (this.activeLane) {
                case "fold":
                  this.$blurFoldWidget(this.activeRowIndex);
                  this.$blurCustomWidget(this.activeRowIndex);
                  break;
                case "annotation":
                  this.$blurAnnotation(this.activeRowIndex);
                  break;
              }
            }
            if (this.annotationTooltip.isOpen)
              this.annotationTooltip.hideTooltip();
            return;
          };
          GutterKeyboardHandler2.prototype.$isFoldWidgetVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = this.$getFoldWidget(index).style.display !== "none";
            return isRowFullyVisible && isIconVisible;
          };
          GutterKeyboardHandler2.prototype.$isCustomWidgetVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = !!this.$getCustomWidget(index);
            return isRowFullyVisible && isIconVisible;
          };
          GutterKeyboardHandler2.prototype.$isAnnotationVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = this.$getAnnotation(index).style.display !== "none";
            return isRowFullyVisible && isIconVisible;
          };
          GutterKeyboardHandler2.prototype.$getFoldWidget = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[1];
          };
          GutterKeyboardHandler2.prototype.$getCustomWidget = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[3];
          };
          GutterKeyboardHandler2.prototype.$getAnnotation = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[2];
          };
          GutterKeyboardHandler2.prototype.$findNearestFoldLaneWidget = function(index) {
            if (this.$isCustomWidgetVisible(index))
              return index;
            if (this.$isFoldWidgetVisible(index))
              return index;
            var i = 0;
            while (index - i > 0 || index + i < this.lines.getLength() - 1) {
              i++;
              if (index - i >= 0 && this.$isCustomWidgetVisible(index - i))
                return index - i;
              if (index + i <= this.lines.getLength() - 1 && this.$isCustomWidgetVisible(index + i))
                return index + i;
              if (index - i >= 0 && this.$isFoldWidgetVisible(index - i))
                return index - i;
              if (index + i <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index + i))
                return index + i;
            }
            return null;
          };
          GutterKeyboardHandler2.prototype.$findNearestAnnotation = function(index) {
            if (this.$isAnnotationVisible(index))
              return index;
            var i = 0;
            while (index - i > 0 || index + i < this.lines.getLength() - 1) {
              i++;
              if (index - i >= 0 && this.$isAnnotationVisible(index - i))
                return index - i;
              if (index + i <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index + i))
                return index + i;
            }
            return null;
          };
          GutterKeyboardHandler2.prototype.$focusFoldWidget = function(index) {
            if (index == null)
              return;
            var foldWidget = this.$getFoldWidget(index);
            foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
            foldWidget.focus();
          };
          GutterKeyboardHandler2.prototype.$focusCustomWidget = function(index) {
            if (index == null)
              return;
            var customWidget = this.$getCustomWidget(index);
            if (customWidget) {
              customWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
              customWidget.focus();
            }
          };
          GutterKeyboardHandler2.prototype.$focusAnnotation = function(index) {
            if (index == null)
              return;
            var annotation = this.$getAnnotation(index);
            annotation.classList.add(this.editor.renderer.keyboardFocusClassName);
            annotation.focus();
          };
          GutterKeyboardHandler2.prototype.$blurFoldWidget = function(index) {
            var foldWidget = this.$getFoldWidget(index);
            foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
            foldWidget.blur();
          };
          GutterKeyboardHandler2.prototype.$blurCustomWidget = function(index) {
            var customWidget = this.$getCustomWidget(index);
            if (customWidget) {
              customWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
              customWidget.blur();
            }
          };
          GutterKeyboardHandler2.prototype.$blurAnnotation = function(index) {
            var annotation = this.$getAnnotation(index);
            annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);
            annotation.blur();
          };
          GutterKeyboardHandler2.prototype.$moveFoldWidgetUp = function() {
            var index = this.activeRowIndex;
            while (index > 0) {
              index--;
              if (this.$isFoldWidgetVisible(index) || this.$isCustomWidgetVisible(index)) {
                this.$blurFoldWidget(this.activeRowIndex);
                this.$blurCustomWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                if (this.$isFoldWidgetVisible(index)) {
                  this.$focusFoldWidget(this.activeRowIndex);
                } else {
                  this.$focusCustomWidget(this.activeRowIndex);
                }
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveFoldWidgetDown = function() {
            var index = this.activeRowIndex;
            while (index < this.lines.getLength() - 1) {
              index++;
              if (this.$isFoldWidgetVisible(index) || this.$isCustomWidgetVisible(index)) {
                this.$blurFoldWidget(this.activeRowIndex);
                this.$blurCustomWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                if (this.$isFoldWidgetVisible(index)) {
                  this.$focusFoldWidget(this.activeRowIndex);
                } else {
                  this.$focusCustomWidget(this.activeRowIndex);
                }
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveAnnotationUp = function() {
            var index = this.activeRowIndex;
            while (index > 0) {
              index--;
              if (this.$isAnnotationVisible(index)) {
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveAnnotationDown = function() {
            var index = this.activeRowIndex;
            while (index < this.lines.getLength() - 1) {
              index++;
              if (this.$isAnnotationVisible(index)) {
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$findClosestNumber = function(num1, num2, target2) {
            if (num1 === null)
              return num2;
            if (num2 === null)
              return num1;
            return Math.abs(target2 - num1) <= Math.abs(target2 - num2) ? num1 : num2;
          };
          GutterKeyboardHandler2.prototype.$switchLane = function(desinationLane) {
            switch (desinationLane) {
              case "annotation":
                if (this.activeLane === "annotation") {
                  break;
                }
                var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);
                if (annotationIndex == null) {
                  break;
                }
                this.activeLane = "annotation";
                this.$blurFoldWidget(this.activeRowIndex);
                this.$blurCustomWidget(this.activeRowIndex);
                this.activeRowIndex = annotationIndex;
                this.$focusAnnotation(this.activeRowIndex);
                break;
              case "fold":
                if (this.activeLane === "fold") {
                  break;
                }
                var foldLaneWidgetIndex = this.$findNearestFoldLaneWidget(this.activeRowIndex);
                if (foldLaneWidgetIndex === null) {
                  break;
                }
                this.activeLane = "fold";
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = foldLaneWidgetIndex;
                if (this.$isCustomWidgetVisible(foldLaneWidgetIndex)) {
                  this.$focusCustomWidget(this.activeRowIndex);
                } else {
                  this.$focusFoldWidget(this.activeRowIndex);
                }
                break;
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$rowIndexToRow = function(index) {
            var cell = this.lines.get(index);
            if (cell)
              return cell.row;
            return null;
          };
          GutterKeyboardHandler2.prototype.$rowToRowIndex = function(row) {
            for (var i = 0; i < this.lines.getLength(); i++) {
              var cell = this.lines.get(i);
              if (cell.row == row)
                return i;
            }
            return null;
          };
          return GutterKeyboardHandler2;
        }()
      );
      exports2.GutterKeyboardHandler = GutterKeyboardHandler;
      var GutterKeyboardEvent = (
        /** @class */
        function() {
          function GutterKeyboardEvent2(domEvent, gutterKeyboardHandler) {
            this.gutterKeyboardHandler = gutterKeyboardHandler;
            this.domEvent = domEvent;
          }
          GutterKeyboardEvent2.prototype.getKey = function() {
            return keys.keyCodeToString(this.domEvent.keyCode);
          };
          GutterKeyboardEvent2.prototype.getRow = function() {
            return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
          };
          GutterKeyboardEvent2.prototype.isInAnnotationLane = function() {
            return this.gutterKeyboardHandler.activeLane === "annotation";
          };
          GutterKeyboardEvent2.prototype.isInFoldLane = function() {
            return this.gutterKeyboardHandler.activeLane === "fold";
          };
          return GutterKeyboardEvent2;
        }()
      );
      exports2.GutterKeyboardEvent = GutterKeyboardEvent;
    });
    ace.define("ace/editor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator", "ace/keyboard/gutter_handler", "ace/config", "ace/clipboard", "ace/lib/keys", "ace/lib/event", "ace/tooltip"], function(require2, exports2, module2) {
      "use strict";
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var lang = require2("./lib/lang");
      var useragent = require2("./lib/useragent");
      var TextInput = require2("./keyboard/textinput").TextInput;
      var MouseHandler = require2("./mouse/mouse_handler").MouseHandler;
      var FoldHandler = require2("./mouse/fold_handler").FoldHandler;
      var KeyBinding = require2("./keyboard/keybinding").KeyBinding;
      var EditSession = require2("./edit_session").EditSession;
      var Search = require2("./search").Search;
      var Range2 = require2("./range").Range;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var CommandManager = require2("./commands/command_manager").CommandManager;
      var defaultCommands = require2("./commands/default_commands").commands;
      var config2 = require2("./config");
      var TokenIterator = require2("./token_iterator").TokenIterator;
      var GutterKeyboardHandler = require2("./keyboard/gutter_handler").GutterKeyboardHandler;
      var nls = require2("./config").nls;
      var clipboard = require2("./clipboard");
      var keys = require2("./lib/keys");
      var event = require2("./lib/event");
      var HoverTooltip = require2("./tooltip").HoverTooltip;
      var Editor = (
        /** @class */
        function() {
          function Editor2(renderer, session, options) {
            this.id = "editor" + ++Editor2.$uid;
            this.session;
            this.$toDestroy = [];
            var container = renderer.getContainerElement();
            this.container = container;
            this.renderer = renderer;
            this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
            if (typeof document == "object") {
              this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
              this.renderer.textarea = this.textInput.getElement();
              this.$mouseHandler = new MouseHandler(this);
              new FoldHandler(this);
            }
            this.keyBinding = new KeyBinding(this);
            this.$search = new Search().set({
              wrap: true
            });
            this.$historyTracker = this.$historyTracker.bind(this);
            this.commands.on("exec", this.$historyTracker);
            this.$initOperationListeners();
            this._$emitInputEvent = lang.delayedCall(function() {
              this._signal("input", {});
              if (this.session && !this.session.destroyed)
                this.session.bgTokenizer.scheduleStart();
            }.bind(this));
            this.on("change", function(_, _self) {
              _self._$emitInputEvent.schedule(31);
            });
            this.setSession(session || options && options.session || new EditSession(""));
            config2.resetOptions(this);
            if (options)
              this.setOptions(options);
            config2._signal("editor", this);
          }
          Editor2.prototype.$initOperationListeners = function() {
            this.commands.on("exec", this.startOperation.bind(this), true);
            this.commands.on("afterExec", this.endOperation.bind(this), true);
          };
          Editor2.prototype.startOperation = function(commandEvent) {
            this.session.startOperation(commandEvent);
          };
          Editor2.prototype.endOperation = function(e75) {
            this.session.endOperation(e75);
          };
          Editor2.prototype.onStartOperation = function(commandEvent) {
            this.curOp = this.session.curOp;
            this.curOp.scrollTop = this.renderer.scrollTop;
            this.prevOp = this.session.prevOp;
            if (!commandEvent) {
              this.previousCommand = null;
            }
          };
          Editor2.prototype.onEndOperation = function(e75) {
            if (this.curOp && this.session) {
              if (e75 && e75.returnValue === false) {
                this.curOp = null;
                return;
              }
              this._signal("beforeEndOperation");
              if (!this.curOp)
                return;
              var command = this.curOp.command;
              var scrollIntoView = command && command.scrollIntoView;
              if (scrollIntoView) {
                switch (scrollIntoView) {
                  case "center-animate":
                    scrollIntoView = "animate";
                  case "center":
                    this.renderer.scrollCursorIntoView(null, 0.5);
                    break;
                  case "animate":
                  case "cursor":
                    this.renderer.scrollCursorIntoView();
                    break;
                  case "selectionPart":
                    var range = this.selection.getRange();
                    var config3 = this.renderer.layerConfig;
                    if (range.start.row >= config3.lastRow || range.end.row <= config3.firstRow) {
                      this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                    }
                    break;
                  default:
                    break;
                }
                if (scrollIntoView == "animate")
                  this.renderer.animateScrolling(this.curOp.scrollTop);
              }
              this.$lastSel = this.session.selection.toJSON();
              this.prevOp = this.curOp;
              this.curOp = null;
            }
          };
          Editor2.prototype.$historyTracker = function(e75) {
            if (!this.$mergeUndoDeltas)
              return;
            var prev = this.prevOp;
            var mergeableCommands = this.$mergeableCommands;
            var shouldMerge = prev.command && e75.command.name == prev.command.name;
            if (e75.command.name == "insertstring") {
              var text = e75.args;
              if (this.mergeNextCommand === void 0)
                this.mergeNextCommand = true;
              shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
              this.mergeNextCommand = true;
            } else {
              shouldMerge = shouldMerge && mergeableCommands.indexOf(e75.command.name) !== -1;
            }
            if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3) {
              shouldMerge = false;
            }
            if (shouldMerge)
              this.session.mergeUndoDeltas = true;
            else if (mergeableCommands.indexOf(e75.command.name) !== -1)
              this.sequenceStartTime = Date.now();
          };
          Editor2.prototype.setKeyboardHandler = function(keyboardHandler, cb) {
            if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
              this.$keybindingId = keyboardHandler;
              var _self = this;
              config2.loadModule(["keybinding", keyboardHandler], function(module3) {
                if (_self.$keybindingId == keyboardHandler)
                  _self.keyBinding.setKeyboardHandler(module3 && module3.handler);
                cb && cb();
              });
            } else {
              this.$keybindingId = null;
              this.keyBinding.setKeyboardHandler(keyboardHandler);
              cb && cb();
            }
          };
          Editor2.prototype.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
          };
          Editor2.prototype.setSession = function(session) {
            if (this.session == session)
              return;
            if (this.curOp)
              this.endOperation();
            this.curOp = {};
            var oldSession = this.session;
            if (oldSession) {
              this.session.off("change", this.$onDocumentChange);
              this.session.off("changeMode", this.$onChangeMode);
              this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
              this.session.off("changeTabSize", this.$onChangeTabSize);
              this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
              this.session.off("changeWrapMode", this.$onChangeWrapMode);
              this.session.off("changeFold", this.$onChangeFold);
              this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
              this.session.off("changeBackMarker", this.$onChangeBackMarker);
              this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
              this.session.off("changeAnnotation", this.$onChangeAnnotation);
              this.session.off("changeOverwrite", this.$onCursorChange);
              this.session.off("changeScrollTop", this.$onScrollTopChange);
              this.session.off("changeScrollLeft", this.$onScrollLeftChange);
              this.session.off("startOperation", this.$onStartOperation);
              this.session.off("endOperation", this.$onEndOperation);
              var selection = this.session.getSelection();
              selection.off("changeCursor", this.$onCursorChange);
              selection.off("changeSelection", this.$onSelectionChange);
            }
            this.session = session;
            if (session) {
              this.$onDocumentChange = this.onDocumentChange.bind(this);
              session.on("change", this.$onDocumentChange);
              this.renderer.setSession(session);
              this.$onChangeMode = this.onChangeMode.bind(this);
              session.on("changeMode", this.$onChangeMode);
              this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
              session.on("tokenizerUpdate", this.$onTokenizerUpdate);
              this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
              session.on("changeTabSize", this.$onChangeTabSize);
              this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
              session.on("changeWrapLimit", this.$onChangeWrapLimit);
              this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
              session.on("changeWrapMode", this.$onChangeWrapMode);
              this.$onChangeFold = this.onChangeFold.bind(this);
              session.on("changeFold", this.$onChangeFold);
              this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
              this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
              this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
              this.session.on("changeBackMarker", this.$onChangeBackMarker);
              this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
              this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
              this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
              this.session.on("changeAnnotation", this.$onChangeAnnotation);
              this.$onCursorChange = this.onCursorChange.bind(this);
              this.session.on("changeOverwrite", this.$onCursorChange);
              this.$onScrollTopChange = this.onScrollTopChange.bind(this);
              this.session.on("changeScrollTop", this.$onScrollTopChange);
              this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
              this.session.on("changeScrollLeft", this.$onScrollLeftChange);
              this.selection = session.getSelection();
              this.selection.on("changeCursor", this.$onCursorChange);
              this.$onSelectionChange = this.onSelectionChange.bind(this);
              this.selection.on("changeSelection", this.$onSelectionChange);
              this.$onStartOperation = this.onStartOperation.bind(this);
              this.session.on("startOperation", this.$onStartOperation);
              this.$onEndOperation = this.onEndOperation.bind(this);
              this.session.on("endOperation", this.$onEndOperation);
              this.onChangeMode();
              this.onCursorChange();
              this.onScrollTopChange();
              this.onScrollLeftChange();
              this.onSelectionChange();
              this.onChangeFrontMarker();
              this.onChangeBackMarker();
              this.onChangeBreakpoint();
              this.onChangeAnnotation();
              this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
              this.renderer.updateFull();
            } else {
              this.selection = null;
              this.renderer.setSession(session);
            }
            this._signal("changeSession", {
              session,
              oldSession
            });
            this.curOp = null;
            oldSession && oldSession._signal("changeEditor", { oldEditor: this });
            if (oldSession)
              oldSession.$editor = null;
            session && session._signal("changeEditor", { editor: this });
            if (session)
              session.$editor = this;
            if (session && !session.destroyed)
              session.bgTokenizer.scheduleStart();
          };
          Editor2.prototype.getSession = function() {
            return this.session;
          };
          Editor2.prototype.setValue = function(val, cursorPos) {
            this.session.doc.setValue(val);
            if (!cursorPos)
              this.selectAll();
            else if (cursorPos == 1)
              this.navigateFileEnd();
            else if (cursorPos == -1)
              this.navigateFileStart();
            return val;
          };
          Editor2.prototype.getValue = function() {
            return this.session.getValue();
          };
          Editor2.prototype.getSelection = function() {
            return this.selection;
          };
          Editor2.prototype.resize = function(force) {
            this.renderer.onResize(force);
          };
          Editor2.prototype.setTheme = function(theme, cb) {
            this.renderer.setTheme(theme, cb);
          };
          Editor2.prototype.getTheme = function() {
            return this.renderer.getTheme();
          };
          Editor2.prototype.setStyle = function(style, incluude) {
            this.renderer.setStyle(style, incluude);
          };
          Editor2.prototype.unsetStyle = function(style) {
            this.renderer.unsetStyle(style);
          };
          Editor2.prototype.getFontSize = function() {
            return this.getOption("fontSize") || dom.computedStyle(this.container).fontSize;
          };
          Editor2.prototype.setFontSize = function(size) {
            this.setOption("fontSize", size);
          };
          Editor2.prototype.$highlightBrackets = function() {
            if (this.$highlightPending) {
              return;
            }
            var self2 = this;
            this.$highlightPending = true;
            setTimeout(function() {
              self2.$highlightPending = false;
              var session = self2.session;
              if (!session || session.destroyed)
                return;
              if (session.$bracketHighlight) {
                session.$bracketHighlight.markerIds.forEach(function(id) {
                  session.removeMarker(id);
                });
                session.$bracketHighlight = null;
              }
              var pos = self2.getCursorPosition();
              var handler = self2.getKeyboardHandler();
              var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self2);
              var ranges = session.getMatchingBracketRanges(pos, isBackwards);
              if (!ranges) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                  var tagNamesRanges = session.getMatchingTags(pos);
                  if (tagNamesRanges) {
                    ranges = [
                      tagNamesRanges.openTagName.isEmpty() ? tagNamesRanges.openTag : tagNamesRanges.openTagName,
                      tagNamesRanges.closeTagName.isEmpty() ? tagNamesRanges.closeTag : tagNamesRanges.closeTagName
                    ];
                  }
                }
              }
              if (!ranges && session.$mode.getMatching)
                ranges = session.$mode.getMatching(self2.session);
              if (!ranges) {
                if (self2.getHighlightIndentGuides())
                  self2.renderer.$textLayer.$highlightIndentGuide();
                return;
              }
              var markerType = "ace_bracket";
              if (!Array.isArray(ranges)) {
                ranges = [ranges];
              } else if (ranges.length == 1) {
                markerType = "ace_error_bracket";
              }
              if (ranges.length == 2) {
                if (Range2.comparePoints(ranges[0].end, ranges[1].start) == 0)
                  ranges = [Range2.fromPoints(ranges[0].start, ranges[1].end)];
                else if (Range2.comparePoints(ranges[0].start, ranges[1].end) == 0)
                  ranges = [Range2.fromPoints(ranges[1].start, ranges[0].end)];
              }
              session.$bracketHighlight = {
                ranges,
                markerIds: ranges.map(function(range) {
                  return session.addMarker(range, markerType, "text");
                })
              };
              if (self2.getHighlightIndentGuides())
                self2.renderer.$textLayer.$highlightIndentGuide();
            }, 50);
          };
          Editor2.prototype.focus = function() {
            this.textInput.focus();
          };
          Editor2.prototype.isFocused = function() {
            return this.textInput.isFocused();
          };
          Editor2.prototype.blur = function() {
            this.textInput.blur();
          };
          Editor2.prototype.onFocus = function(e75) {
            if (this.$isFocused)
              return;
            this.$isFocused = true;
            this.renderer.showCursor();
            this.renderer.visualizeFocus();
            this._emit("focus", e75);
          };
          Editor2.prototype.onBlur = function(e75) {
            if (!this.$isFocused)
              return;
            this.$isFocused = false;
            this.renderer.hideCursor();
            this.renderer.visualizeBlur();
            this._emit("blur", e75);
          };
          Editor2.prototype.$cursorChange = function() {
            this.renderer.updateCursor();
            this.$highlightBrackets();
            this.$updateHighlightActiveLine();
          };
          Editor2.prototype.onDocumentChange = function(delta) {
            var wrap = this.session.$useWrapMode;
            var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
            this.renderer.updateLines(delta.start.row, lastRow, wrap);
            this._signal("change", delta);
            this.$cursorChange();
          };
          Editor2.prototype.onTokenizerUpdate = function(e75) {
            var rows = e75.data;
            this.renderer.updateLines(rows.first, rows.last);
          };
          Editor2.prototype.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
          };
          Editor2.prototype.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
          };
          Editor2.prototype.onCursorChange = function() {
            this.$cursorChange();
            this._signal("changeSelection");
          };
          Editor2.prototype.$updateHighlightActiveLine = function() {
            var session = this.getSession();
            var highlight;
            if (this.$highlightActiveLine) {
              if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
              if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                highlight = false;
              if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
            }
            if (session.$highlightLineMarker && !highlight) {
              session.removeMarker(session.$highlightLineMarker.id);
              session.$highlightLineMarker = null;
            } else if (!session.$highlightLineMarker && highlight) {
              var range = new Range2(highlight.row, highlight.column, highlight.row, Infinity);
              range.id = session.addMarker(range, "ace_active-line", "screenLine");
              session.$highlightLineMarker = range;
            } else if (highlight) {
              session.$highlightLineMarker.start.row = highlight.row;
              session.$highlightLineMarker.end.row = highlight.row;
              session.$highlightLineMarker.start.column = highlight.column;
              session._signal("changeBackMarker");
            }
          };
          Editor2.prototype.onSelectionChange = function(e75) {
            var session = this.session;
            if (session.$selectionMarker) {
              session.removeMarker(session.$selectionMarker);
            }
            session.$selectionMarker = null;
            if (!this.selection.isEmpty()) {
              var range = this.selection.getRange();
              var style = this.getSelectionStyle();
              session.$selectionMarker = session.addMarker(range, "ace_selection", style);
            } else {
              this.$updateHighlightActiveLine();
            }
            var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(re);
            this._signal("changeSelection");
          };
          Editor2.prototype.$getSelectionHighLightRegexp = function() {
            var session = this.session;
            var selection = this.getSelectionRange();
            if (selection.isEmpty() || selection.isMultiLine())
              return;
            var startColumn = selection.start.column;
            var endColumn = selection.end.column;
            var line = session.getLine(selection.start.row);
            var needle = line.substring(startColumn, endColumn);
            if (needle.length > 5e3 || !/[\w\d]/.test(needle))
              return;
            var re = this.$search.$assembleRegExp({
              wholeWord: true,
              caseSensitive: true,
              needle
            });
            var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
            if (!re.test(wordWithBoundary))
              return;
            return re;
          };
          Editor2.prototype.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
          };
          Editor2.prototype.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
          };
          Editor2.prototype.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
          };
          Editor2.prototype.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
          };
          Editor2.prototype.onChangeMode = function(e75) {
            this.renderer.updateText();
            this._emit("changeMode", e75);
          };
          Editor2.prototype.onChangeWrapLimit = function() {
            this.renderer.updateFull();
          };
          Editor2.prototype.onChangeWrapMode = function() {
            this.renderer.onResize(true);
          };
          Editor2.prototype.onChangeFold = function() {
            this.$updateHighlightActiveLine();
            this.renderer.updateFull();
          };
          Editor2.prototype.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
          };
          Editor2.prototype.getCopyText = function() {
            var text = this.getSelectedText();
            var nl = this.session.doc.getNewLineCharacter();
            var copyLine = false;
            if (!text && this.$copyWithEmptySelection) {
              copyLine = true;
              var ranges = this.selection.getAllRanges();
              for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (i && ranges[i - 1].start.row == range.start.row)
                  continue;
                text += this.session.getLine(range.start.row) + nl;
              }
            }
            var e75 = { text };
            this._signal("copy", e75);
            clipboard.lineMode = copyLine ? e75.text : false;
            return e75.text;
          };
          Editor2.prototype.onCopy = function() {
            this.commands.exec("copy", this);
          };
          Editor2.prototype.onCut = function() {
            this.commands.exec("cut", this);
          };
          Editor2.prototype.onPaste = function(text, event2) {
            var e75 = { text, event: event2 };
            this.commands.exec("paste", this, e75);
          };
          Editor2.prototype.$handlePaste = function(e75) {
            if (typeof e75 == "string")
              e75 = { text: e75 };
            this._signal("paste", e75);
            var text = e75.text;
            var lineMode = text === clipboard.lineMode;
            var session = this.session;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
              if (lineMode)
                session.insert({ row: this.selection.lead.row, column: 0 }, text);
              else
                this.insert(text);
            } else if (lineMode) {
              this.selection.rangeList.ranges.forEach(function(range2) {
                session.insert({ row: range2.start.row, column: 0 }, text);
              });
            } else {
              var lines = text.split(/\r\n|\r|\n/);
              var ranges = this.selection.rangeList.ranges;
              var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
              if (lines.length != ranges.length || isFullLine)
                return this.commands.exec("insertstring", this, text);
              for (var i = ranges.length; i--; ) {
                var range = ranges[i];
                if (!range.isEmpty())
                  session.remove(range);
                session.insert(range.start, lines[i]);
              }
            }
          };
          Editor2.prototype.execCommand = function(command, args) {
            return this.commands.exec(command, this, args);
          };
          Editor2.prototype.insert = function(text, pasted) {
            var session = this.session;
            var mode = session.getMode();
            var cursor = this.getCursorPosition();
            if (this.getBehavioursEnabled() && !pasted) {
              var transform = mode.transformAction(session.getState(cursor.row), "insertion", this, session, text);
              if (transform) {
                if (text !== transform.text) {
                  if (!this.inVirtualSelectionMode) {
                    this.session.mergeUndoDeltas = false;
                    this.mergeNextCommand = false;
                  }
                }
                text = transform.text;
              }
            }
            if (text == "	")
              text = this.session.getTabString();
            if (!this.selection.isEmpty()) {
              var range = this.getSelectionRange();
              cursor = this.session.remove(range);
              this.clearSelection();
            } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
              var range = Range2.fromPoints(cursor, cursor);
              range.end.column += text.length;
              this.session.remove(range);
            }
            if (text == "\n" || text == "\r\n") {
              var line = session.getLine(cursor.row);
              if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
              }
            }
            this.clearSelection();
            var start = cursor.column;
            var lineState = session.getState(cursor.row);
            var line = session.getLine(cursor.row);
            var shouldOutdent = mode.checkOutdent(lineState, line, text);
            session.insert(cursor, text);
            if (transform && transform.selection) {
              if (transform.selection.length == 2) {
                this.selection.setSelectionRange(new Range2(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
              } else {
                this.selection.setSelectionRange(new Range2(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
              }
            }
            if (this.$enableAutoIndent) {
              if (session.getDocument().isNewLine(text)) {
                var lineIndent2 = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                session.insert({ row: cursor.row + 1, column: 0 }, lineIndent2);
              }
              if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
            }
          };
          Editor2.prototype.autoIndent = function() {
            var session = this.session;
            var mode = session.getMode();
            var ranges = this.selection.isEmpty() ? [new Range2(0, 0, session.doc.getLength() - 1, 0)] : this.selection.getAllRanges();
            var prevLineState = "";
            var prevLine = "";
            var lineIndent2 = "";
            var tab = session.getTabString();
            for (var i = 0; i < ranges.length; i++) {
              var startRow = ranges[i].start.row;
              var endRow = ranges[i].end.row;
              for (var row = startRow; row <= endRow; row++) {
                if (row > 0) {
                  prevLineState = session.getState(row - 1);
                  prevLine = session.getLine(row - 1);
                  lineIndent2 = mode.getNextLineIndent(prevLineState, prevLine, tab);
                }
                var line = session.getLine(row);
                var currIndent = mode.$getIndent(line);
                if (lineIndent2 !== currIndent) {
                  if (currIndent.length > 0) {
                    var range = new Range2(row, 0, row, currIndent.length);
                    session.remove(range);
                  }
                  if (lineIndent2.length > 0) {
                    session.insert({ row, column: 0 }, lineIndent2);
                  }
                }
                mode.autoOutdent(prevLineState, session, row);
              }
            }
          };
          Editor2.prototype.onTextInput = function(text, composition) {
            if (!composition)
              return this.keyBinding.onTextInput(text);
            this.startOperation({ command: { name: "insertstring" } });
            var applyComposition = this.applyComposition.bind(this, text, composition);
            if (this.selection.rangeCount)
              this.forEachSelection(applyComposition);
            else
              applyComposition();
            this.endOperation();
          };
          Editor2.prototype.applyComposition = function(text, composition) {
            if (composition.extendLeft || composition.extendRight) {
              var r = this.selection.getRange();
              r.start.column -= composition.extendLeft;
              r.end.column += composition.extendRight;
              if (r.start.column < 0) {
                r.start.row--;
                r.start.column += this.session.getLine(r.start.row).length + 1;
              }
              this.selection.setRange(r);
              if (!text && !r.isEmpty())
                this.remove();
            }
            if (text || !this.selection.isEmpty())
              this.insert(text, true);
            if (composition.restoreStart || composition.restoreEnd) {
              var r = this.selection.getRange();
              r.start.column -= composition.restoreStart;
              r.end.column -= composition.restoreEnd;
              this.selection.setRange(r);
            }
          };
          Editor2.prototype.onCommandKey = function(e75, hashId, keyCode) {
            return this.keyBinding.onCommandKey(e75, hashId, keyCode);
          };
          Editor2.prototype.setOverwrite = function(overwrite) {
            this.session.setOverwrite(overwrite);
          };
          Editor2.prototype.getOverwrite = function() {
            return this.session.getOverwrite();
          };
          Editor2.prototype.toggleOverwrite = function() {
            this.session.toggleOverwrite();
          };
          Editor2.prototype.setScrollSpeed = function(speed) {
            this.setOption("scrollSpeed", speed);
          };
          Editor2.prototype.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
          };
          Editor2.prototype.setDragDelay = function(dragDelay) {
            this.setOption("dragDelay", dragDelay);
          };
          Editor2.prototype.getDragDelay = function() {
            return this.getOption("dragDelay");
          };
          Editor2.prototype.setSelectionStyle = function(val) {
            this.setOption("selectionStyle", val);
          };
          Editor2.prototype.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
          };
          Editor2.prototype.setHighlightActiveLine = function(shouldHighlight) {
            this.setOption("highlightActiveLine", shouldHighlight);
          };
          Editor2.prototype.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
          };
          Editor2.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          Editor2.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          Editor2.prototype.setHighlightSelectedWord = function(shouldHighlight) {
            this.setOption("highlightSelectedWord", shouldHighlight);
          };
          Editor2.prototype.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
          };
          Editor2.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.renderer.setAnimatedScroll(shouldAnimate);
          };
          Editor2.prototype.getAnimatedScroll = function() {
            return this.renderer.getAnimatedScroll();
          };
          Editor2.prototype.setShowInvisibles = function(showInvisibles) {
            this.renderer.setShowInvisibles(showInvisibles);
          };
          Editor2.prototype.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
          };
          Editor2.prototype.setDisplayIndentGuides = function(display) {
            this.renderer.setDisplayIndentGuides(display);
          };
          Editor2.prototype.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
          };
          Editor2.prototype.setHighlightIndentGuides = function(highlight) {
            this.renderer.setHighlightIndentGuides(highlight);
          };
          Editor2.prototype.getHighlightIndentGuides = function() {
            return this.renderer.getHighlightIndentGuides();
          };
          Editor2.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.renderer.setShowPrintMargin(showPrintMargin);
          };
          Editor2.prototype.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
          };
          Editor2.prototype.setPrintMarginColumn = function(showPrintMargin) {
            this.renderer.setPrintMarginColumn(showPrintMargin);
          };
          Editor2.prototype.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
          };
          Editor2.prototype.setReadOnly = function(readOnly) {
            this.setOption("readOnly", readOnly);
          };
          Editor2.prototype.getReadOnly = function() {
            return this.getOption("readOnly");
          };
          Editor2.prototype.setBehavioursEnabled = function(enabled) {
            this.setOption("behavioursEnabled", enabled);
          };
          Editor2.prototype.getBehavioursEnabled = function() {
            return this.getOption("behavioursEnabled");
          };
          Editor2.prototype.setWrapBehavioursEnabled = function(enabled) {
            this.setOption("wrapBehavioursEnabled", enabled);
          };
          Editor2.prototype.getWrapBehavioursEnabled = function() {
            return this.getOption("wrapBehavioursEnabled");
          };
          Editor2.prototype.setShowFoldWidgets = function(show) {
            this.setOption("showFoldWidgets", show);
          };
          Editor2.prototype.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
          };
          Editor2.prototype.setFadeFoldWidgets = function(fade) {
            this.setOption("fadeFoldWidgets", fade);
          };
          Editor2.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          Editor2.prototype.remove = function(dir) {
            if (this.selection.isEmpty()) {
              if (dir == "left")
                this.selection.selectLeft();
              else
                this.selection.selectRight();
            }
            var range = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
              var session = this.session;
              var state = session.getState(range.start.row);
              var new_range = session.getMode().transformAction(state, "deletion", this, session, range);
              if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                  var line = session.getLine(range.end.row);
                  if (/^\s+$/.test(line)) {
                    range.end.column = line.length;
                  }
                }
              }
              if (new_range)
                range = new_range;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          Editor2.prototype.removeWordRight = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordRight();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeWordLeft = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeToLineStart = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineStart();
            if (this.selection.isEmpty())
              this.selection.selectLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeToLineEnd = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineEnd();
            var range = this.getSelectionRange();
            if (range.start.column == range.end.column && range.start.row == range.end.row) {
              range.end.column = 0;
              range.end.row++;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          Editor2.prototype.splitLine = function() {
            if (!this.selection.isEmpty()) {
              this.session.remove(this.getSelectionRange());
              this.clearSelection();
            }
            var cursor = this.getCursorPosition();
            this.insert("\n");
            this.moveCursorToPosition(cursor);
          };
          Editor2.prototype.setGhostText = function(text, position2) {
            this.renderer.setGhostText(text, position2);
          };
          Editor2.prototype.removeGhostText = function() {
            this.renderer.removeGhostText();
          };
          Editor2.prototype.transposeLetters = function() {
            if (!this.selection.isEmpty()) {
              return;
            }
            var cursor = this.getCursorPosition();
            var column = cursor.column;
            if (column === 0)
              return;
            var line = this.session.getLine(cursor.row);
            var swap, range;
            if (column < line.length) {
              swap = line.charAt(column) + line.charAt(column - 1);
              range = new Range2(cursor.row, column - 1, cursor.row, column + 1);
            } else {
              swap = line.charAt(column - 1) + line.charAt(column - 2);
              range = new Range2(cursor.row, column - 2, cursor.row, column);
            }
            this.session.replace(range, swap);
            this.session.selection.moveToPosition(range.end);
          };
          Editor2.prototype.toLowerCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toLowerCase());
            this.selection.setSelectionRange(originalRange);
          };
          Editor2.prototype.toUpperCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toUpperCase());
            this.selection.setSelectionRange(originalRange);
          };
          Editor2.prototype.indent = function() {
            var session = this.session;
            var range = this.getSelectionRange();
            if (range.start.row < range.end.row) {
              var rows = this.$getSelectedRows();
              session.indentRows(rows.first, rows.last, "	");
              return;
            } else if (range.start.column < range.end.column) {
              var text = session.getTextRange(range);
              if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "	");
                return;
              }
            }
            var line = session.getLine(range.start.row);
            var position2 = range.start;
            var size = session.getTabSize();
            var column = session.documentToScreenColumn(position2.row, position2.column);
            if (this.session.getUseSoftTabs()) {
              var count = size - column % size;
              var indentString = lang.stringRepeat(" ", count);
            } else {
              var count = column % size;
              while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
              }
              this.selection.setSelectionRange(range);
              indentString = "	";
            }
            return this.insert(indentString);
          };
          Editor2.prototype.blockIndent = function() {
            var rows = this.$getSelectedRows();
            this.session.indentRows(rows.first, rows.last, "	");
          };
          Editor2.prototype.blockOutdent = function() {
            var selection = this.session.getSelection();
            this.session.outdentRows(selection.getRange());
          };
          Editor2.prototype.sortLines = function() {
            var rows = this.$getSelectedRows();
            var session = this.session;
            var lines = [];
            for (var i = rows.first; i <= rows.last; i++)
              lines.push(session.getLine(i));
            lines.sort(function(a, b) {
              if (a.toLowerCase() < b.toLowerCase())
                return -1;
              if (a.toLowerCase() > b.toLowerCase())
                return 1;
              return 0;
            });
            var deleteRange = new Range2(0, 0, 0, 0);
            for (var i = rows.first; i <= rows.last; i++) {
              var line = session.getLine(i);
              deleteRange.start.row = i;
              deleteRange.end.row = i;
              deleteRange.end.column = line.length;
              session.replace(deleteRange, lines[i - rows.first]);
            }
          };
          Editor2.prototype.toggleCommentLines = function() {
            var state = this.session.getState(this.getCursorPosition().row);
            var rows = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
          };
          Editor2.prototype.toggleBlockComment = function() {
            var cursor = this.getCursorPosition();
            var state = this.session.getState(cursor.row);
            var range = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
          };
          Editor2.prototype.getNumberAt = function(row, column) {
            var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            _numberRx.lastIndex = 0;
            var s = this.session.getLine(row);
            while (_numberRx.lastIndex < column) {
              var m = _numberRx.exec(s);
              if (m.index <= column && m.index + m[0].length >= column) {
                var number = {
                  value: m[0],
                  start: m.index,
                  end: m.index + m[0].length
                };
                return number;
              }
            }
            return null;
          };
          Editor2.prototype.modifyNumber = function(amount) {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            var charRange = new Range2(row, column - 1, row, column);
            var c = this.session.getTextRange(charRange);
            if (!isNaN(parseFloat(c)) && isFinite(c)) {
              var nr = this.getNumberAt(row, column);
              if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;
                var t2 = parseFloat(nr.value);
                t2 *= Math.pow(10, decimals);
                if (fp !== nr.end && column < fp) {
                  amount *= Math.pow(10, nr.end - column - 1);
                } else {
                  amount *= Math.pow(10, nr.end - column);
                }
                t2 += amount;
                t2 /= Math.pow(10, decimals);
                var nnr = t2.toFixed(decimals);
                var replaceRange = new Range2(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
              }
            } else {
              this.toggleWord();
            }
          };
          Editor2.prototype.toggleWord = function() {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            this.selection.selectWord();
            var currentState = this.getSelectedText();
            var currWordStart = this.selection.getWordRange().start.column;
            var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/);
            var delta = column - currWordStart - 1;
            if (delta < 0)
              delta = 0;
            var curLength = 0, itLength = 0;
            var that = this;
            if (currentState.match(/[A-Za-z0-9_]+/)) {
              wordParts.forEach(function(item2, i2) {
                itLength = curLength + item2.length;
                if (delta >= curLength && delta <= itLength) {
                  currentState = item2;
                  that.selection.clearSelection();
                  that.moveCursorTo(row, curLength + currWordStart);
                  that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
              });
            }
            var wordPairs = this.$toggleWordPairs;
            var reg;
            for (var i = 0; i < wordPairs.length; i++) {
              var item = wordPairs[i];
              for (var j = 0; j <= 1; j++) {
                var negate = +!j;
                var firstCondition = currentState.match(new RegExp("^\\s?_?(" + lang.escapeRegExp(item[j]) + ")\\s?$", "i"));
                if (firstCondition) {
                  var secondCondition = currentState.match(new RegExp("([_]|^|\\s)(" + lang.escapeRegExp(firstCondition[1]) + ")($|\\s)", "g"));
                  if (secondCondition) {
                    reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), "i"), function(result) {
                      var res = item[negate];
                      if (result.toUpperCase() == result) {
                        res = res.toUpperCase();
                      } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                        res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                      }
                      return res;
                    });
                    this.insert(reg);
                    reg = "";
                  }
                }
              }
            }
          };
          Editor2.prototype.findLinkAt = function(row, column) {
            var e_1, _a;
            var line = this.session.getLine(row);
            var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
            var columnPosition = column;
            if (columnPosition < 0)
              columnPosition = 0;
            var previousPosition = 0, currentPosition = 0, match2;
            try {
              for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {
                var item = wordParts_1_1.value;
                currentPosition = previousPosition + item.length;
                if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                  if (item.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                    match2 = item.replace(/[\s:.,'";}\]]+$/, "");
                    break;
                  }
                }
                previousPosition = currentPosition;
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (wordParts_1_1 && !wordParts_1_1.done && (_a = wordParts_1.return)) _a.call(wordParts_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return match2;
          };
          Editor2.prototype.openLink = function() {
            var cursor = this.selection.getCursor();
            var url = this.findLinkAt(cursor.row, cursor.column);
            if (url)
              window.open(url, "_blank");
            return url != null;
          };
          Editor2.prototype.removeLines = function() {
            var rows = this.$getSelectedRows();
            this.session.removeFullLines(rows.first, rows.last);
            this.clearSelection();
          };
          Editor2.prototype.duplicateSelection = function() {
            var sel = this.selection;
            var doc2 = this.session;
            var range = sel.getRange();
            var reverse = sel.isBackwards();
            if (range.isEmpty()) {
              var row = range.start.row;
              doc2.duplicateLines(row, row);
            } else {
              var point = reverse ? range.start : range.end;
              var endPoint = doc2.insert(point, doc2.getTextRange(range));
              range.start = point;
              range.end = endPoint;
              sel.setSelectionRange(range, reverse);
            }
          };
          Editor2.prototype.moveLinesDown = function() {
            this.$moveLines(1, false);
          };
          Editor2.prototype.moveLinesUp = function() {
            this.$moveLines(-1, false);
          };
          Editor2.prototype.moveText = function(range, toPosition, copy) {
            return this.session.moveText(range, toPosition, copy);
          };
          Editor2.prototype.copyLinesUp = function() {
            this.$moveLines(-1, true);
          };
          Editor2.prototype.copyLinesDown = function() {
            this.$moveLines(1, true);
          };
          Editor2.prototype.$moveLines = function(dir, copy) {
            var rows, moved;
            var selection = this.selection;
            if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
              var range = selection.toOrientedRange();
              rows = this.$getSelectedRows(range);
              moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
              if (copy && dir == -1)
                moved = 0;
              range.moveBy(moved, 0);
              selection.fromOrientedRange(range);
            } else {
              var ranges = selection.rangeList.ranges;
              selection.rangeList.detach(this.session);
              this.inVirtualSelectionMode = true;
              var diff = 0;
              var totalDiff = 0;
              var l = ranges.length;
              for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                  if (totalDiff)
                    ranges[i].moveBy(totalDiff, 0);
                  var subRows = this.$getSelectedRows(ranges[i]);
                  if (copy && subRows.first != last)
                    break;
                  else if (!copy && subRows.first > last + 1)
                    break;
                  last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1)
                  rangeIndex = i + 1;
                while (rangeIndex <= i) {
                  ranges[rangeIndex].moveBy(diff, 0);
                  rangeIndex++;
                }
                if (!copy)
                  diff = 0;
                totalDiff += diff;
              }
              selection.fromOrientedRange(selection.ranges[0]);
              selection.rangeList.attach(this.session);
              this.inVirtualSelectionMode = false;
            }
          };
          Editor2.prototype.$getSelectedRows = function(range) {
            range = (range || this.getSelectionRange()).collapseRows();
            return {
              first: this.session.getRowFoldStart(range.start.row),
              last: this.session.getRowFoldEnd(range.end.row)
            };
          };
          Editor2.prototype.onCompositionStart = function(compositionState) {
            this.renderer.showComposition(compositionState);
          };
          Editor2.prototype.onCompositionUpdate = function(text) {
            this.renderer.setCompositionText(text);
          };
          Editor2.prototype.onCompositionEnd = function() {
            this.renderer.hideComposition();
          };
          Editor2.prototype.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
          };
          Editor2.prototype.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
          };
          Editor2.prototype.isRowVisible = function(row) {
            return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
          };
          Editor2.prototype.isRowFullyVisible = function(row) {
            return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
          };
          Editor2.prototype.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
          };
          Editor2.prototype.$moveByPage = function(dir, select) {
            var renderer = this.renderer;
            var config3 = this.renderer.layerConfig;
            var rows = dir * Math.floor(config3.height / config3.lineHeight);
            if (select === true) {
              this.selection.$moveSelection(function() {
                this.moveCursorBy(rows, 0);
              });
            } else if (select === false) {
              this.selection.moveCursorBy(rows, 0);
              this.selection.clearSelection();
            }
            var scrollTop = renderer.scrollTop;
            renderer.scrollBy(0, rows * config3.lineHeight);
            if (select != null)
              renderer.scrollCursorIntoView(null, 0.5);
            renderer.animateScrolling(scrollTop);
          };
          Editor2.prototype.selectPageDown = function() {
            this.$moveByPage(1, true);
          };
          Editor2.prototype.selectPageUp = function() {
            this.$moveByPage(-1, true);
          };
          Editor2.prototype.gotoPageDown = function() {
            this.$moveByPage(1, false);
          };
          Editor2.prototype.gotoPageUp = function() {
            this.$moveByPage(-1, false);
          };
          Editor2.prototype.scrollPageDown = function() {
            this.$moveByPage(1);
          };
          Editor2.prototype.scrollPageUp = function() {
            this.$moveByPage(-1);
          };
          Editor2.prototype.scrollToRow = function(row) {
            this.renderer.scrollToRow(row);
          };
          Editor2.prototype.scrollToLine = function(line, center, animate, callback) {
            this.renderer.scrollToLine(line, center, animate, callback);
          };
          Editor2.prototype.centerSelection = function() {
            var range = this.getSelectionRange();
            var pos = {
              row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
              column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
            };
            this.renderer.alignCursor(pos, 0.5);
          };
          Editor2.prototype.getCursorPosition = function() {
            return this.selection.getCursor();
          };
          Editor2.prototype.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
          };
          Editor2.prototype.getSelectionRange = function() {
            return this.selection.getRange();
          };
          Editor2.prototype.selectAll = function() {
            this.selection.selectAll();
          };
          Editor2.prototype.clearSelection = function() {
            this.selection.clearSelection();
          };
          Editor2.prototype.moveCursorTo = function(row, column) {
            this.selection.moveCursorTo(row, column);
          };
          Editor2.prototype.moveCursorToPosition = function(pos) {
            this.selection.moveCursorToPosition(pos);
          };
          Editor2.prototype.jumpToMatching = function(select, expand) {
            var cursor = this.getCursorPosition();
            var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
            var prevToken = iterator.getCurrentToken();
            var tokenCount = 0;
            if (prevToken && prevToken.type.indexOf("tag-name") !== -1) {
              prevToken = iterator.stepBackward();
            }
            var token = prevToken || iterator.stepForward();
            if (!token)
              return;
            var matchType;
            var found = false;
            var depth = {};
            var i = cursor.column - token.start;
            var bracketType;
            var brackets = {
              ")": "(",
              "(": "(",
              "]": "[",
              "[": "[",
              "{": "{",
              "}": "{"
            };
            do {
              if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                  if (!brackets[token.value[i]]) {
                    continue;
                  }
                  bracketType = brackets[token.value[i]] + "." + token.type.replace("rparen", "lparen");
                  if (isNaN(depth[bracketType])) {
                    depth[bracketType] = 0;
                  }
                  switch (token.value[i]) {
                    case "(":
                    case "[":
                    case "{":
                      depth[bracketType]++;
                      break;
                    case ")":
                    case "]":
                    case "}":
                      depth[bracketType]--;
                      if (depth[bracketType] === -1) {
                        matchType = "bracket";
                        found = true;
                      }
                      break;
                  }
                }
              } else if (token.type.indexOf("tag-name") !== -1) {
                if (isNaN(depth[token.value])) {
                  depth[token.value] = 0;
                }
                if (prevToken.value === "<" && tokenCount > 1) {
                  depth[token.value]++;
                } else if (prevToken.value === "</") {
                  depth[token.value]--;
                }
                if (depth[token.value] === -1) {
                  matchType = "tag";
                  found = true;
                }
              }
              if (!found) {
                prevToken = token;
                tokenCount++;
                token = iterator.stepForward();
                i = 0;
              }
            } while (token && !found);
            if (!matchType)
              return;
            var range, pos;
            if (matchType === "bracket") {
              range = this.session.getBracketRange(cursor);
              if (!range) {
                range = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                  range = this.session.getBracketRange(pos);
              }
            } else if (matchType === "tag") {
              if (!token || token.type.indexOf("tag-name") === -1)
                return;
              range = new Range2(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
              if (range.compare(cursor.row, cursor.column) === 0) {
                var tagsRanges = this.session.getMatchingTags(cursor);
                if (tagsRanges) {
                  if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                    range = tagsRanges.closeTag;
                    pos = range.start;
                  } else {
                    range = tagsRanges.openTag;
                    if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column === cursor.column)
                      pos = range.end;
                    else
                      pos = range.start;
                  }
                }
              }
              pos = pos || range.start;
            }
            pos = range && range.cursor || pos;
            if (pos) {
              if (select) {
                if (range && expand) {
                  this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                  this.clearSelection();
                } else {
                  this.selection.selectTo(pos.row, pos.column);
                }
              } else {
                this.selection.moveTo(pos.row, pos.column);
              }
            }
          };
          Editor2.prototype.gotoLine = function(lineNumber, column, animate) {
            this.selection.clearSelection();
            this.session.unfold({ row: lineNumber - 1, column: column || 0 });
            this.exitMultiSelectMode && this.exitMultiSelectMode();
            this.moveCursorTo(lineNumber - 1, column || 0);
            if (!this.isRowFullyVisible(lineNumber - 1))
              this.scrollToLine(lineNumber - 1, true, animate);
          };
          Editor2.prototype.navigateTo = function(row, column) {
            this.selection.moveTo(row, column);
          };
          Editor2.prototype.navigateUp = function(times) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
              var selectionStart = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionStart);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(-times || -1, 0);
          };
          Editor2.prototype.navigateDown = function(times) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
              var selectionEnd = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionEnd);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(times || 1, 0);
          };
          Editor2.prototype.navigateLeft = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionStart = this.getSelectionRange().start;
              this.moveCursorToPosition(selectionStart);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorLeft();
              }
            }
            this.clearSelection();
          };
          Editor2.prototype.navigateRight = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionEnd = this.getSelectionRange().end;
              this.moveCursorToPosition(selectionEnd);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorRight();
              }
            }
            this.clearSelection();
          };
          Editor2.prototype.navigateLineStart = function() {
            this.selection.moveCursorLineStart();
            this.clearSelection();
          };
          Editor2.prototype.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd();
            this.clearSelection();
          };
          Editor2.prototype.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd();
            this.clearSelection();
          };
          Editor2.prototype.navigateFileStart = function() {
            this.selection.moveCursorFileStart();
            this.clearSelection();
          };
          Editor2.prototype.navigateWordRight = function() {
            this.selection.moveCursorWordRight();
            this.clearSelection();
          };
          Editor2.prototype.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft();
            this.clearSelection();
          };
          Editor2.prototype.replace = function(replacement, options) {
            if (options)
              this.$search.set(options);
            var range = this.$search.find(this.session);
            var replaced = 0;
            if (!range)
              return replaced;
            if (this.$tryReplace(range, replacement)) {
              replaced = 1;
            }
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
            return replaced;
          };
          Editor2.prototype.replaceAll = function(replacement, options) {
            if (options) {
              this.$search.set(options);
            }
            var ranges = this.$search.findAll(this.session);
            var replaced = 0;
            if (!ranges.length)
              return replaced;
            var selection = this.getSelectionRange();
            this.selection.moveTo(0, 0);
            for (var i = ranges.length - 1; i >= 0; --i) {
              if (this.$tryReplace(ranges[i], replacement)) {
                replaced++;
              }
            }
            this.selection.setSelectionRange(selection);
            return replaced;
          };
          Editor2.prototype.$tryReplace = function(range, replacement) {
            var input = this.session.getTextRange(range);
            replacement = this.$search.replace(input, replacement);
            if (replacement !== null) {
              range.end = this.session.replace(range, replacement);
              return range;
            } else {
              return null;
            }
          };
          Editor2.prototype.getLastSearchOptions = function() {
            return this.$search.getOptions();
          };
          Editor2.prototype.find = function(needle, options, animate) {
            if (!options)
              options = {};
            if (typeof needle == "string" || needle instanceof RegExp)
              options.needle = needle;
            else if (typeof needle == "object")
              oop.mixin(options, needle);
            var range = this.selection.getRange();
            if (options.needle == null) {
              needle = this.session.getTextRange(range) || this.$search.$options.needle;
              if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
              }
              this.$search.set({ needle });
            }
            this.$search.set(options);
            if (!options.start)
              this.$search.set({ start: range });
            var newRange = this.$search.find(this.session);
            if (options.preventScroll)
              return newRange;
            if (newRange) {
              this.revealRange(newRange, animate);
              return newRange;
            }
            if (options.backwards)
              range.start = range.end;
            else
              range.end = range.start;
            this.selection.setRange(range);
          };
          Editor2.prototype.findNext = function(options, animate) {
            this.find({ skipCurrent: true, backwards: false }, options, animate);
          };
          Editor2.prototype.findPrevious = function(options, animate) {
            this.find(options, { skipCurrent: true, backwards: true }, animate);
          };
          Editor2.prototype.revealRange = function(range, animate) {
            this.session.unfold(range);
            this.selection.setSelectionRange(range);
            var scrollTop = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
            if (animate !== false)
              this.renderer.animateScrolling(scrollTop);
          };
          Editor2.prototype.undo = function() {
            this.session.getUndoManager().undo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          Editor2.prototype.redo = function() {
            this.session.getUndoManager().redo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          Editor2.prototype.destroy = function() {
            if (this.$toDestroy) {
              this.$toDestroy.forEach(function(el) {
                el.destroy();
              });
              this.$toDestroy = null;
            }
            if (this.$mouseHandler)
              this.$mouseHandler.destroy();
            this.renderer.destroy();
            this._signal("destroy", this);
            if (this.session)
              this.session.destroy();
            if (this._$emitInputEvent)
              this._$emitInputEvent.cancel();
            this.removeAllListeners();
          };
          Editor2.prototype.setAutoScrollEditorIntoView = function(enable) {
            if (!enable)
              return;
            var rect;
            var self2 = this;
            var shouldScroll = false;
            if (!this.$scrollAnchor)
              this.$scrollAnchor = document.createElement("div");
            var scrollAnchor = this.$scrollAnchor;
            scrollAnchor.style.cssText = "position:absolute";
            this.container.insertBefore(scrollAnchor, this.container.firstChild);
            var onChangeSelection = this.on("changeSelection", function() {
              shouldScroll = true;
            });
            var onBeforeRender = this.renderer.on("beforeRender", function() {
              if (shouldScroll)
                rect = self2.renderer.container.getBoundingClientRect();
            });
            var onAfterRender = this.renderer.on("afterRender", function() {
              if (shouldScroll && rect && (self2.isFocused() || self2.searchBox && self2.searchBox.isFocused())) {
                var renderer = self2.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config3 = renderer.layerConfig;
                var top = pos.top - config3.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                  shouldScroll = true;
                } else if (pos.top < config3.height && pos.top + rect.top + config3.lineHeight > window.innerHeight) {
                  shouldScroll = false;
                } else {
                  shouldScroll = null;
                }
                if (shouldScroll != null) {
                  scrollAnchor.style.top = top + "px";
                  scrollAnchor.style.left = pos.left + "px";
                  scrollAnchor.style.height = config3.lineHeight + "px";
                  scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
              }
            });
            this.setAutoScrollEditorIntoView = function(enable2) {
              if (enable2)
                return;
              delete this.setAutoScrollEditorIntoView;
              this.off("changeSelection", onChangeSelection);
              this.renderer.off("afterRender", onAfterRender);
              this.renderer.off("beforeRender", onBeforeRender);
            };
          };
          Editor2.prototype.$resetCursorStyle = function() {
            var style = this.$cursorStyle || "ace";
            var cursorLayer = this.renderer.$cursorLayer;
            if (!cursorLayer)
              return;
            cursorLayer.setSmoothBlinking(/smooth/.test(style));
            cursorLayer.isBlinking = !this.$readOnly && style != "wide";
            dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
          };
          Editor2.prototype.prompt = function(message, options, callback) {
            var editor2 = this;
            config2.loadModule("ace/ext/prompt", function(module3) {
              module3.prompt(editor2, message, options, callback);
            });
          };
          return Editor2;
        }()
      );
      Editor.$uid = 0;
      Editor.prototype.curOp = null;
      Editor.prototype.prevOp = {};
      Editor.prototype.$mergeableCommands = ["backspace", "del", "insertstring"];
      Editor.prototype.$toggleWordPairs = [
        ["first", "last"],
        ["true", "false"],
        ["yes", "no"],
        ["width", "height"],
        ["top", "bottom"],
        ["right", "left"],
        ["on", "off"],
        ["x", "y"],
        ["get", "set"],
        ["max", "min"],
        ["horizontal", "vertical"],
        ["show", "hide"],
        ["add", "remove"],
        ["up", "down"],
        ["before", "after"],
        ["even", "odd"],
        ["in", "out"],
        ["inside", "outside"],
        ["next", "previous"],
        ["increase", "decrease"],
        ["attach", "detach"],
        ["&&", "||"],
        ["==", "!="]
      ];
      oop.implement(Editor.prototype, EventEmitter);
      config2.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
          set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", { data: style });
          },
          initialValue: "line"
        },
        highlightActiveLine: {
          set: function() {
            this.$updateHighlightActiveLine();
          },
          initialValue: true
        },
        highlightSelectedWord: {
          set: function(shouldHighlight) {
            this.$onSelectionChange();
          },
          initialValue: true
        },
        readOnly: {
          set: function(readOnly) {
            var _this = this;
            this.textInput.setReadOnly(readOnly);
            this.$resetCursorStyle();
            if (!this.$readOnlyCallback) {
              this.$readOnlyCallback = function(e75) {
                var shouldShow = false;
                if (e75 && e75.type == "keydown") {
                  shouldShow = e75 && e75.key && e75.key.length == 1 && !e75.ctrlKey && !e75.metaKey;
                  if (!shouldShow)
                    return;
                } else if (e75 && e75.type !== "exec") {
                  shouldShow = true;
                }
                if (shouldShow) {
                  if (!_this.hoverTooltip) {
                    _this.hoverTooltip = new HoverTooltip();
                  }
                  var domNode = dom.createElement("div");
                  domNode.textContent = nls("editor.tooltip.disable-editing", "Editing is disabled");
                  if (!_this.hoverTooltip.isOpen) {
                    _this.hoverTooltip.showForRange(_this, _this.getSelectionRange(), domNode);
                  }
                } else if (_this.hoverTooltip && _this.hoverTooltip.isOpen) {
                  _this.hoverTooltip.hide();
                }
              };
            }
            var textArea = this.textInput.getElement();
            if (readOnly) {
              event.addListener(textArea, "keydown", this.$readOnlyCallback, this);
              this.commands.on("exec", this.$readOnlyCallback);
              this.commands.on("commandUnavailable", this.$readOnlyCallback);
            } else {
              event.removeListener(textArea, "keydown", this.$readOnlyCallback);
              this.commands.off("exec", this.$readOnlyCallback);
              this.commands.off("commandUnavailable", this.$readOnlyCallback);
              if (this.hoverTooltip) {
                this.hoverTooltip.destroy();
                this.hoverTooltip = null;
              }
            }
          },
          initialValue: false
        },
        copyWithEmptySelection: {
          set: function(value) {
            this.textInput.setCopyWithEmptySelection(value);
          },
          initialValue: false
        },
        cursorStyle: {
          set: function(val) {
            this.$resetCursorStyle();
          },
          values: ["ace", "slim", "smooth", "wide"],
          initialValue: "ace"
        },
        mergeUndoDeltas: {
          values: [false, true, "always"],
          initialValue: true
        },
        behavioursEnabled: { initialValue: true },
        wrapBehavioursEnabled: { initialValue: true },
        enableAutoIndent: { initialValue: true },
        autoScrollEditorIntoView: {
          set: function(val) {
            this.setAutoScrollEditorIntoView(val);
          }
        },
        keyboardHandler: {
          set: function(val) {
            this.setKeyboardHandler(val);
          },
          get: function() {
            return this.$keybindingId;
          },
          handlesSet: true
        },
        value: {
          set: function(val) {
            this.session.setValue(val);
          },
          get: function() {
            return this.getValue();
          },
          handlesSet: true,
          hidden: true
        },
        session: {
          set: function(val) {
            this.setSession(val);
          },
          get: function() {
            return this.session;
          },
          handlesSet: true,
          hidden: true
        },
        showLineNumbers: {
          set: function(show) {
            this.renderer.$gutterLayer.setShowLineNumbers(show);
            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
            if (show && this.$relativeLineNumbers)
              relativeNumberRenderer.attach(this);
            else
              relativeNumberRenderer.detach(this);
          },
          initialValue: true
        },
        relativeLineNumbers: {
          set: function(value) {
            if (this.$showLineNumbers && value)
              relativeNumberRenderer.attach(this);
            else
              relativeNumberRenderer.detach(this);
          }
        },
        placeholder: {
          set: function(message) {
            if (!this.$updatePlaceholder) {
              this.$updatePlaceholder = function() {
                var hasValue = this.session && (this.renderer.$composition || this.session.getLength() > 1 || this.session.getLine(0).length > 0);
                if (hasValue && this.renderer.placeholderNode) {
                  this.renderer.off("afterRender", this.$updatePlaceholder);
                  dom.removeCssClass(this.container, "ace_hasPlaceholder");
                  this.renderer.placeholderNode.remove();
                  this.renderer.placeholderNode = null;
                } else if (!hasValue && !this.renderer.placeholderNode) {
                  this.renderer.on("afterRender", this.$updatePlaceholder);
                  dom.addCssClass(this.container, "ace_hasPlaceholder");
                  var el = dom.createElement("div");
                  el.className = "ace_placeholder";
                  el.textContent = this.$placeholder || "";
                  this.renderer.placeholderNode = el;
                  this.renderer.content.appendChild(this.renderer.placeholderNode);
                } else if (!hasValue && this.renderer.placeholderNode) {
                  this.renderer.placeholderNode.textContent = this.$placeholder || "";
                }
              }.bind(this);
              this.on("input", this.$updatePlaceholder);
            }
            this.$updatePlaceholder();
          }
        },
        enableKeyboardAccessibility: {
          set: function(value) {
            var blurCommand = {
              name: "blurTextInput",
              description: "Set focus to the editor content div to allow tabbing through the page",
              bindKey: "Esc",
              exec: function(editor2) {
                editor2.blur();
                editor2.renderer.scroller.focus();
              },
              readOnly: true
            };
            var focusOnEnterKeyup = function(e75) {
              if (e75.target == this.renderer.scroller && e75.keyCode === keys["enter"]) {
                e75.preventDefault();
                var row = this.getCursorPosition().row;
                if (!this.isRowVisible(row))
                  this.scrollToLine(row, true, true);
                this.focus();
              }
            };
            var gutterKeyboardHandler;
            if (value) {
              this.renderer.enableKeyboardAccessibility = true;
              this.renderer.keyboardFocusClassName = "ace_keyboard-focus";
              this.textInput.getElement().setAttribute("tabindex", -1);
              this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);
              this.renderer.scroller.setAttribute("tabindex", 0);
              this.renderer.scroller.setAttribute("role", "group");
              this.renderer.scroller.setAttribute("aria-roledescription", nls("editor.scroller.aria-roledescription", "editor"));
              this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);
              this.renderer.scroller.setAttribute("aria-label", nls("editor.scroller.aria-label", "Editor content, press Enter to start editing, press Escape to exit"));
              this.renderer.scroller.addEventListener("keyup", focusOnEnterKeyup.bind(this));
              this.commands.addCommand(blurCommand);
              this.renderer.$gutter.setAttribute("tabindex", 0);
              this.renderer.$gutter.setAttribute("aria-hidden", false);
              this.renderer.$gutter.setAttribute("role", "group");
              this.renderer.$gutter.setAttribute("aria-roledescription", nls("editor.gutter.aria-roledescription", "editor gutter"));
              this.renderer.$gutter.setAttribute("aria-label", nls("editor.gutter.aria-label", "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit"));
              this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);
              this.renderer.content.setAttribute("aria-hidden", true);
              if (!gutterKeyboardHandler)
                gutterKeyboardHandler = new GutterKeyboardHandler(this);
              gutterKeyboardHandler.addListener();
              this.textInput.setAriaOptions({
                setLabel: true
              });
            } else {
              this.renderer.enableKeyboardAccessibility = false;
              this.textInput.getElement().setAttribute("tabindex", 0);
              this.textInput.setNumberOfExtraLines(0);
              this.renderer.scroller.setAttribute("tabindex", -1);
              this.renderer.scroller.removeAttribute("role");
              this.renderer.scroller.removeAttribute("aria-roledescription");
              this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);
              this.renderer.scroller.removeAttribute("aria-label");
              this.renderer.scroller.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
              this.commands.removeCommand(blurCommand);
              this.renderer.content.removeAttribute("aria-hidden");
              this.renderer.$gutter.setAttribute("tabindex", -1);
              this.renderer.$gutter.setAttribute("aria-hidden", true);
              this.renderer.$gutter.removeAttribute("role");
              this.renderer.$gutter.removeAttribute("aria-roledescription");
              this.renderer.$gutter.removeAttribute("aria-label");
              this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);
              if (gutterKeyboardHandler)
                gutterKeyboardHandler.removeListener();
            }
          },
          initialValue: false
        },
        textInputAriaLabel: {
          set: function(val) {
            this.$textInputAriaLabel = val;
          },
          initialValue: ""
        },
        enableMobileMenu: {
          set: function(val) {
            this.$enableMobileMenu = val;
          },
          initialValue: true
        },
        customScrollbar: "renderer",
        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        displayIndentGuides: "renderer",
        highlightIndentGuides: "renderer",
        showGutter: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        hasCssTransforms: "renderer",
        maxPixelHeight: "renderer",
        useTextareaForIME: "renderer",
        useResizeObserver: "renderer",
        useSvgGutterIcons: "renderer",
        showFoldedAnnotations: "renderer",
        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimeout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",
        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        navigateWithinSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
      });
      var relativeNumberRenderer = {
        getText: function(session, row) {
          return (Math.abs(session.selection.lead.row - row) || row + 1 + (row < 9 ? "" : "")) + "";
        },
        getWidth: function(session, lastLineNumber, config3) {
          return Math.max(lastLineNumber.toString().length, (config3.lastRow + 1).toString().length, 2) * config3.characterWidth;
        },
        update: function(e75, editor2) {
          editor2.renderer.$loop.schedule(editor2.renderer.CHANGE_GUTTER);
        },
        attach: function(editor2) {
          editor2.renderer.$gutterLayer.$renderer = this;
          editor2.on("changeSelection", this.update);
          this.update(null, editor2);
        },
        detach: function(editor2) {
          if (editor2.renderer.$gutterLayer.$renderer == this)
            editor2.renderer.$gutterLayer.$renderer = null;
          editor2.off("changeSelection", this.update);
          this.update(null, editor2);
        }
      };
      exports2.Editor = Editor;
    });
    ace.define("ace/layer/lines", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var Lines = (
        /** @class */
        function() {
          function Lines2(element, canvasHeight) {
            this.element = element;
            this.canvasHeight = canvasHeight || 5e5;
            this.element.style.height = this.canvasHeight * 2 + "px";
            this.cells = [];
            this.cellCache = [];
            this.$offsetCoefficient = 0;
          }
          Lines2.prototype.moveContainer = function(config2) {
            dom.translate(this.element, 0, -(config2.firstRowScreen * config2.lineHeight % this.canvasHeight) - config2.offset * this.$offsetCoefficient);
          };
          Lines2.prototype.pageChanged = function(oldConfig, newConfig) {
            return Math.floor(oldConfig.firstRowScreen * oldConfig.lineHeight / this.canvasHeight) !== Math.floor(newConfig.firstRowScreen * newConfig.lineHeight / this.canvasHeight);
          };
          Lines2.prototype.computeLineTop = function(row, config2, session) {
            var screenTop = config2.firstRowScreen * config2.lineHeight;
            var screenPage = Math.floor(screenTop / this.canvasHeight);
            var lineTop = session.documentToScreenRow(row, 0) * config2.lineHeight;
            return lineTop - screenPage * this.canvasHeight;
          };
          Lines2.prototype.computeLineHeight = function(row, config2, session) {
            return config2.lineHeight * session.getRowLineCount(row);
          };
          Lines2.prototype.getLength = function() {
            return this.cells.length;
          };
          Lines2.prototype.get = function(index) {
            return this.cells[index];
          };
          Lines2.prototype.shift = function() {
            this.$cacheCell(this.cells.shift());
          };
          Lines2.prototype.pop = function() {
            this.$cacheCell(this.cells.pop());
          };
          Lines2.prototype.push = function(cell) {
            if (Array.isArray(cell)) {
              this.cells.push.apply(this.cells, cell);
              var fragment = dom.createFragment(this.element);
              for (var i = 0; i < cell.length; i++) {
                fragment.appendChild(cell[i].element);
              }
              this.element.appendChild(fragment);
            } else {
              this.cells.push(cell);
              this.element.appendChild(cell.element);
            }
          };
          Lines2.prototype.unshift = function(cell) {
            if (Array.isArray(cell)) {
              this.cells.unshift.apply(this.cells, cell);
              var fragment = dom.createFragment(this.element);
              for (var i = 0; i < cell.length; i++) {
                fragment.appendChild(cell[i].element);
              }
              if (this.element.firstChild)
                this.element.insertBefore(fragment, this.element.firstChild);
              else
                this.element.appendChild(fragment);
            } else {
              this.cells.unshift(cell);
              this.element.insertAdjacentElement("afterbegin", cell.element);
            }
          };
          Lines2.prototype.last = function() {
            if (this.cells.length)
              return this.cells[this.cells.length - 1];
            else
              return null;
          };
          Lines2.prototype.$cacheCell = function(cell) {
            if (!cell)
              return;
            cell.element.remove();
            this.cellCache.push(cell);
          };
          Lines2.prototype.createCell = function(row, config2, session, initElement) {
            var cell = this.cellCache.pop();
            if (!cell) {
              var element = dom.createElement("div");
              if (initElement)
                initElement(element);
              this.element.appendChild(element);
              cell = {
                element,
                text: "",
                row
              };
            }
            cell.row = row;
            return cell;
          };
          return Lines2;
        }()
      );
      exports2.Lines = Lines;
    });
    ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/layer/lines", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var oop = require2("../lib/oop");
      var lang = require2("../lib/lang");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var Lines = require2("./lines").Lines;
      var nls = require2("../config").nls;
      var Gutter = (
        /** @class */
        function() {
          function Gutter2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_gutter-layer";
            parentEl.appendChild(this.element);
            this.setShowFoldWidgets(this.$showFoldWidgets);
            this.gutterWidth = 0;
            this.$annotations = [];
            this.$updateAnnotations = this.$updateAnnotations.bind(this);
            this.$lines = new Lines(this.element);
            this.$lines.$offsetCoefficient = 1;
          }
          Gutter2.prototype.setSession = function(session) {
            if (this.session)
              this.session.off("change", this.$updateAnnotations);
            this.session = session;
            if (session)
              session.on("change", this.$updateAnnotations);
          };
          Gutter2.prototype.addGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.addGutterDecoration");
            this.session.addGutterDecoration(row, className);
          };
          Gutter2.prototype.removeGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.removeGutterDecoration");
            this.session.removeGutterDecoration(row, className);
          };
          Gutter2.prototype.setAnnotations = function(annotations) {
            this.$annotations = [];
            for (var i = 0; i < annotations.length; i++) {
              var annotation = annotations[i];
              var row = annotation.row;
              var rowInfo = this.$annotations[row];
              if (!rowInfo)
                rowInfo = this.$annotations[row] = { text: [], type: [], displayText: [] };
              var annoText = annotation.text;
              var displayAnnoText = annotation.text;
              var annoType = annotation.type;
              annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
              displayAnnoText = displayAnnoText ? displayAnnoText : annotation.html || "";
              if (rowInfo.text.indexOf(annoText) === -1) {
                rowInfo.text.push(annoText);
                rowInfo.type.push(annoType);
                rowInfo.displayText.push(displayAnnoText);
              }
              var className = annotation.className;
              if (className) {
                rowInfo.className = className;
              } else if (annoType === "error") {
                rowInfo.className = " ace_error";
              } else if (annoType === "security" && !/\bace_error\b/.test(rowInfo.className)) {
                rowInfo.className = " ace_security";
              } else if (annoType === "warning" && !/\bace_(error|security)\b/.test(rowInfo.className)) {
                rowInfo.className = " ace_warning";
              } else if (annoType === "info" && !rowInfo.className) {
                rowInfo.className = " ace_info";
              } else if (annoType === "hint" && !rowInfo.className) {
                rowInfo.className = " ace_hint";
              }
            }
          };
          Gutter2.prototype.$updateAnnotations = function(delta) {
            if (!this.$annotations.length)
              return;
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) {
            } else if (delta.action == "remove") {
              this.$annotations.splice(firstRow, len + 1, null);
            } else {
              var args = new Array(len + 1);
              args.unshift(firstRow, 1);
              this.$annotations.splice.apply(this.$annotations, args);
            }
          };
          Gutter2.prototype.update = function(config2) {
            this.config = config2;
            var session = this.session;
            var firstRow = config2.firstRow;
            var lastRow = Math.min(
              config2.lastRow + config2.gutterOffset,
              // needed to compensate for hor scollbar
              session.getLength() - 1
            );
            this.oldLastRow = lastRow;
            this.config = config2;
            this.$lines.moveContainer(config2);
            this.$updateCursorRow();
            var fold2 = session.getNextFoldLine(firstRow);
            var foldStart = fold2 ? fold2.start.row : Infinity;
            var cell = null;
            var index = -1;
            var row = firstRow;
            while (true) {
              if (row > foldStart) {
                row = fold2.end.row + 1;
                fold2 = session.getNextFoldLine(row, fold2);
                foldStart = fold2 ? fold2.start.row : Infinity;
              }
              if (row > lastRow) {
                while (this.$lines.getLength() > index + 1)
                  this.$lines.pop();
                break;
              }
              cell = this.$lines.get(++index);
              if (cell) {
                cell.row = row;
              } else {
                cell = this.$lines.createCell(row, config2, this.session, onCreateCell);
                this.$lines.push(cell);
              }
              this.$renderCell(cell, config2, fold2, row);
              row++;
            }
            this._signal("afterRender");
            this.$updateGutterWidth(config2);
          };
          Gutter2.prototype.$updateGutterWidth = function(config2) {
            var session = this.session;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var firstLineNumber = session.$firstLineNumber;
            var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
            if (this.$fixedWidth || session.$useWrapMode)
              lastLineText = session.getLength() + firstLineNumber - 1;
            var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineText, config2) : lastLineText.toString().length * config2.characterWidth;
            var padding = this.$padding || this.$computePadding();
            gutterWidth += padding.left + padding.right;
            if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
              this.gutterWidth = gutterWidth;
              this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px";
              this._signal("changeGutterWidth", gutterWidth);
            }
          };
          Gutter2.prototype.$updateCursorRow = function() {
            if (!this.$highlightGutterLine)
              return;
            var position2 = this.session.selection.getCursor();
            if (this.$cursorRow === position2.row)
              return;
            this.$cursorRow = position2.row;
          };
          Gutter2.prototype.updateLineHighlight = function() {
            if (!this.$highlightGutterLine)
              return;
            var row = this.session.selection.cursor.row;
            this.$cursorRow = row;
            if (this.$cursorCell && this.$cursorCell.row == row)
              return;
            if (this.$cursorCell)
              this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
            var cells = this.$lines.cells;
            this.$cursorCell = null;
            for (var i = 0; i < cells.length; i++) {
              var cell = cells[i];
              if (cell.row >= this.$cursorRow) {
                if (cell.row > this.$cursorRow) {
                  var fold2 = this.session.getFoldLine(this.$cursorRow);
                  if (i > 0 && fold2 && fold2.start.row == cells[i - 1].row)
                    cell = cells[i - 1];
                  else
                    break;
                }
                cell.element.className = "ace_gutter-active-line " + cell.element.className;
                this.$cursorCell = cell;
                break;
              }
            }
          };
          Gutter2.prototype.scrollLines = function(config2) {
            var oldConfig = this.config;
            this.config = config2;
            this.$updateCursorRow();
            if (this.$lines.pageChanged(oldConfig, config2))
              return this.update(config2);
            this.$lines.moveContainer(config2);
            var lastRow = Math.min(
              config2.lastRow + config2.gutterOffset,
              // needed to compensate for hor scollbar
              this.session.getLength() - 1
            );
            var oldLastRow = this.oldLastRow;
            this.oldLastRow = lastRow;
            if (!oldConfig || oldLastRow < config2.firstRow)
              return this.update(config2);
            if (lastRow < oldConfig.firstRow)
              return this.update(config2);
            if (oldConfig.firstRow < config2.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config2.firstRow - 1); row > 0; row--)
                this.$lines.shift();
            if (oldLastRow > lastRow)
              for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)
                this.$lines.pop();
            if (config2.firstRow < oldConfig.firstRow) {
              this.$lines.unshift(this.$renderLines(config2, config2.firstRow, oldConfig.firstRow - 1));
            }
            if (lastRow > oldLastRow) {
              this.$lines.push(this.$renderLines(config2, oldLastRow + 1, lastRow));
            }
            this.updateLineHighlight();
            this._signal("afterRender");
            this.$updateGutterWidth(config2);
          };
          Gutter2.prototype.$renderLines = function(config2, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var cell = this.$lines.createCell(row, config2, this.session, onCreateCell);
              this.$renderCell(cell, config2, foldLine, row);
              fragment.push(cell);
              row++;
            }
            return fragment;
          };
          Gutter2.prototype.$renderCell = function(cell, config2, fold2, row) {
            var element = cell.element;
            var session = this.session;
            var textNode = element.childNodes[0];
            var foldWidget = element.childNodes[1];
            var annotationNode = element.childNodes[2];
            var customWidget = element.childNodes[3];
            var annotationIconNode = annotationNode.firstChild;
            var firstLineNumber = session.$firstLineNumber;
            var breakpoints = session.$breakpoints;
            var decorations = session.$decorations;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
            var foldStart = fold2 ? fold2.start.row : Number.MAX_VALUE;
            var lineHeight = config2.lineHeight + "px";
            var className = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ";
            var iconClassName = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            var rowText = (gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber).toString();
            if (this.$highlightGutterLine) {
              if (row == this.$cursorRow || fold2 && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold2.end.row) {
                className += "ace_gutter-active-line ";
                if (this.$cursorCell != cell) {
                  if (this.$cursorCell)
                    this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                  this.$cursorCell = cell;
                }
              }
            }
            if (breakpoints[row])
              className += breakpoints[row];
            if (decorations[row])
              className += decorations[row];
            if (this.$annotations[row] && row !== foldStart)
              className += this.$annotations[row].className;
            if (foldWidgets) {
              var c = foldWidgets[row];
              if (c == null)
                c = foldWidgets[row] = session.getFoldWidget(row);
            }
            if (c) {
              var foldClass = "ace_fold-widget ace_" + c;
              var isClosedFold = c == "start" && row == foldStart && row < fold2.end.row;
              if (isClosedFold) {
                foldClass += " ace_closed";
                var foldAnnotationClass = "";
                var annotationInFold = false;
                for (var i = row + 1; i <= fold2.end.row; i++) {
                  if (!this.$annotations[i])
                    continue;
                  if (this.$annotations[i].className === " ace_error") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_error_fold";
                    break;
                  }
                  if (this.$annotations[i].className === " ace_security") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_security_fold";
                  } else if (this.$annotations[i].className === " ace_warning" && foldAnnotationClass !== " ace_security_fold") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_warning_fold";
                  }
                }
                className += foldAnnotationClass;
              } else
                foldClass += " ace_open";
              if (foldWidget.className != foldClass)
                foldWidget.className = foldClass;
              dom.setStyle(foldWidget.style, "height", lineHeight);
              dom.setStyle(foldWidget.style, "display", "inline-block");
              foldWidget.setAttribute("role", "button");
              foldWidget.setAttribute("tabindex", "-1");
              var foldRange = session.getFoldWidgetRange(row);
              if (foldRange)
                foldWidget.setAttribute("aria-label", nls("gutter.code-folding.range.aria-label", "Toggle code folding, rows $0 through $1", [
                  foldRange.start.row + 1,
                  foldRange.end.row + 1
                ]));
              else {
                if (fold2)
                  foldWidget.setAttribute("aria-label", nls("gutter.code-folding.closed.aria-label", "Toggle code folding, rows $0 through $1", [
                    fold2.start.row + 1,
                    fold2.end.row + 1
                  ]));
                else
                  foldWidget.setAttribute("aria-label", nls("gutter.code-folding.open.aria-label", "Toggle code folding, row $0", [row + 1]));
              }
              if (isClosedFold) {
                foldWidget.setAttribute("aria-expanded", "false");
                foldWidget.setAttribute("title", nls("gutter.code-folding.closed.title", "Unfold code"));
              } else {
                foldWidget.setAttribute("aria-expanded", "true");
                foldWidget.setAttribute("title", nls("gutter.code-folding.open.title", "Fold code"));
              }
            } else {
              if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
                foldWidget.setAttribute("tabindex", "0");
                foldWidget.removeAttribute("role");
                foldWidget.removeAttribute("aria-label");
              }
            }
            var customWidgetAttributes = this.session.$gutterCustomWidgets[row];
            if (customWidgetAttributes) {
              this.$addCustomWidget(row, customWidgetAttributes, cell);
            } else if (customWidget) {
              this.$removeCustomWidget(row, cell);
            }
            if (annotationInFold && this.$showFoldedAnnotations) {
              annotationNode.className = "ace_gutter_annotation";
              annotationIconNode.className = iconClassName;
              annotationIconNode.className += foldAnnotationClass;
              dom.setStyle(annotationIconNode.style, "height", lineHeight);
              dom.setStyle(annotationNode.style, "display", "block");
              dom.setStyle(annotationNode.style, "height", lineHeight);
              var ariaLabel;
              switch (foldAnnotationClass) {
                case " ace_error_fold":
                  ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                  break;
                case " ace_security_fold":
                  ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                  break;
                case " ace_warning_fold":
                  ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                  break;
              }
              annotationNode.setAttribute("aria-label", ariaLabel);
              annotationNode.setAttribute("tabindex", "-1");
              annotationNode.setAttribute("role", "button");
            } else if (this.$annotations[row]) {
              annotationNode.className = "ace_gutter_annotation";
              annotationIconNode.className = iconClassName;
              if (this.$useSvgGutterIcons)
                annotationIconNode.className += this.$annotations[row].className;
              else
                element.classList.add(this.$annotations[row].className.replace(" ", ""));
              dom.setStyle(annotationIconNode.style, "height", lineHeight);
              dom.setStyle(annotationNode.style, "display", "block");
              dom.setStyle(annotationNode.style, "height", lineHeight);
              var ariaLabel;
              switch (this.$annotations[row].className) {
                case " ace_error":
                  ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                  break;
                case " ace_security":
                  ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                  break;
                case " ace_warning":
                  ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                  break;
                case " ace_info":
                  ariaLabel = nls("gutter.annotation.aria-label.info", "Info, read annotations row $0", [rowText]);
                  break;
                case " ace_hint":
                  ariaLabel = nls("gutter.annotation.aria-label.hint", "Suggestion, read annotations row $0", [rowText]);
                  break;
              }
              annotationNode.setAttribute("aria-label", ariaLabel);
              annotationNode.setAttribute("tabindex", "-1");
              annotationNode.setAttribute("role", "button");
            } else {
              dom.setStyle(annotationNode.style, "display", "none");
              annotationNode.removeAttribute("aria-label");
              annotationNode.removeAttribute("role");
              annotationNode.setAttribute("tabindex", "0");
            }
            if (rowText !== textNode.data) {
              textNode.data = rowText;
            }
            if (element.className != className)
              element.className = className;
            dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config2, session) + "px");
            dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config2, session) + "px");
            cell.text = rowText;
            if (annotationNode.style.display === "none" && foldWidget.style.display === "none" && !customWidgetAttributes)
              cell.element.setAttribute("aria-hidden", true);
            else
              cell.element.setAttribute("aria-hidden", false);
            return cell;
          };
          Gutter2.prototype.setHighlightGutterLine = function(highlightGutterLine) {
            this.$highlightGutterLine = highlightGutterLine;
          };
          Gutter2.prototype.setShowLineNumbers = function(show) {
            this.$renderer = !show && {
              getWidth: function() {
                return 0;
              },
              getText: function() {
                return "";
              }
            };
          };
          Gutter2.prototype.getShowLineNumbers = function() {
            return this.$showLineNumbers;
          };
          Gutter2.prototype.setShowFoldWidgets = function(show) {
            if (show)
              dom.addCssClass(this.element, "ace_folding-enabled");
            else
              dom.removeCssClass(this.element, "ace_folding-enabled");
            this.$showFoldWidgets = show;
            this.$padding = null;
          };
          Gutter2.prototype.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
          };
          Gutter2.prototype.$hideFoldWidget = function(row, cell) {
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
              var foldWidget = rowCell.element.childNodes[1];
              if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
              }
            }
          };
          Gutter2.prototype.$showFoldWidget = function(row, cell) {
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
              var foldWidget = rowCell.element.childNodes[1];
              if (foldWidget && this.session.foldWidgets && this.session.foldWidgets[rowCell.row]) {
                dom.setStyle(foldWidget.style, "display", "inline-block");
              }
            }
          };
          Gutter2.prototype.$getGutterCell = function(row) {
            var cells = this.$lines.cells;
            var visibileRow = this.session.documentToScreenRow(row, 0);
            return cells[row - this.config.firstRowScreen - (row - visibileRow)];
          };
          Gutter2.prototype.$addCustomWidget = function(row, _a, cell) {
            var className = _a.className, label = _a.label, title = _a.title, callbacks = _a.callbacks;
            this.session.$gutterCustomWidgets[row] = { className, label, title, callbacks };
            this.$hideFoldWidget(row, cell);
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
              var customWidget = rowCell.element.querySelector(".ace_custom-widget");
              if (customWidget) {
                customWidget.remove();
              }
              customWidget = dom.createElement("span");
              customWidget.className = "ace_custom-widget ".concat(className);
              customWidget.setAttribute("tabindex", "-1");
              customWidget.setAttribute("role", "button");
              customWidget.setAttribute("aria-label", label);
              customWidget.setAttribute("title", title);
              dom.setStyle(customWidget.style, "display", "inline-block");
              dom.setStyle(customWidget.style, "height", "inherit");
              if (callbacks && callbacks.onClick) {
                customWidget.addEventListener("click", function(e75) {
                  callbacks.onClick(e75, row);
                  e75.stopPropagation();
                });
              }
              rowCell.element.appendChild(customWidget);
            }
          };
          Gutter2.prototype.$removeCustomWidget = function(row, cell) {
            delete this.session.$gutterCustomWidgets[row];
            this.$showFoldWidget(row, cell);
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
              var customWidget = rowCell.element.querySelector(".ace_custom-widget");
              if (customWidget) {
                rowCell.element.removeChild(customWidget);
              }
            }
          };
          Gutter2.prototype.$computePadding = function() {
            if (!this.element.firstChild)
              return { left: 0, right: 0 };
            var style = dom.computedStyle(
              /**@type{Element}*/
              this.element.firstChild
            );
            this.$padding = {};
            this.$padding.left = (parseInt(style.borderLeftWidth) || 0) + (parseInt(style.paddingLeft) || 0) + 1;
            this.$padding.right = (parseInt(style.borderRightWidth) || 0) + (parseInt(style.paddingRight) || 0);
            return this.$padding;
          };
          Gutter2.prototype.getRegion = function(point) {
            var padding = this.$padding || this.$computePadding();
            var rect = this.element.getBoundingClientRect();
            if (point.x < padding.left + rect.left)
              return "markers";
            if (this.$showFoldWidgets && point.x > rect.right - padding.right)
              return "foldWidgets";
          };
          return Gutter2;
        }()
      );
      Gutter.prototype.$fixedWidth = false;
      Gutter.prototype.$highlightGutterLine = true;
      Gutter.prototype.$renderer = "";
      Gutter.prototype.$showLineNumbers = true;
      Gutter.prototype.$showFoldWidgets = true;
      oop.implement(Gutter.prototype, EventEmitter);
      function onCreateCell(element) {
        var textNode = document.createTextNode("");
        element.appendChild(textNode);
        var foldWidget = dom.createElement("span");
        element.appendChild(foldWidget);
        var annotationNode = dom.createElement("span");
        element.appendChild(annotationNode);
        var annotationIconNode = dom.createElement("span");
        annotationNode.appendChild(annotationIconNode);
        return element;
      }
      exports2.Gutter = Gutter;
    });
    ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var Range2 = require2("../range").Range;
      var dom = require2("../lib/dom");
      var Marker = (
        /** @class */
        function() {
          function Marker2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_marker-layer";
            parentEl.appendChild(this.element);
          }
          Marker2.prototype.setPadding = function(padding) {
            this.$padding = padding;
          };
          Marker2.prototype.setSession = function(session) {
            this.session = session;
          };
          Marker2.prototype.setMarkers = function(markers) {
            this.markers = markers;
          };
          Marker2.prototype.elt = function(className, css) {
            var x = this.i != -1 && this.element.childNodes[this.i];
            if (!x) {
              x = document.createElement("div");
              this.element.appendChild(x);
              this.i = -1;
            } else {
              this.i++;
            }
            x.style.cssText = css;
            x.className = className;
          };
          Marker2.prototype.update = function(config2) {
            if (!config2)
              return;
            this.config = config2;
            this.i = 0;
            var html;
            for (var key in this.markers) {
              var marker = this.markers[key];
              if (!marker.range) {
                marker.update(html, this, this.session, config2);
                continue;
              }
              var range = marker.range.clipRows(config2.firstRow, config2.lastRow);
              if (range.isEmpty())
                continue;
              range = range.toScreenRange(this.session);
              if (marker.renderer) {
                var top = this.$getTop(range.start.row, config2);
                var left = this.$padding + range.start.column * config2.characterWidth;
                marker.renderer(html, range, left, top, config2);
              } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config2);
              } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config2);
              } else if (range.isMultiLine()) {
                if (marker.type == "text")
                  this.drawTextMarker(html, range, marker.clazz, config2);
                else
                  this.drawMultiLineMarker(html, range, marker.clazz, config2);
              } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start ace_br15", config2);
              }
            }
            if (this.i != -1) {
              while (this.i < this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
            }
          };
          Marker2.prototype.$getTop = function(row, layerConfig) {
            return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
          };
          Marker2.prototype.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
            var session = this.session;
            var start = range.start.row;
            var end = range.end.row;
            var row = start;
            var prev = 0;
            var curr = 0;
            var next = session.getScreenLastRowColumn(row);
            var lineRange = new Range2(row, range.start.column, row, curr);
            for (; row <= end; row++) {
              lineRange.start.row = lineRange.end.row = row;
              lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
              lineRange.end.column = next;
              prev = curr;
              curr = next;
              next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
              this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
            }
          };
          Marker2.prototype.drawMultiLineMarker = function(stringBuilder, range, clazz, config2, extraStyle) {
            var padding = this.$padding;
            var height = config2.lineHeight;
            var top = this.$getTop(range.start.row, config2);
            var left = padding + range.start.column * config2.characterWidth;
            extraStyle = extraStyle || "";
            if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
              var range1 = range.clone();
              range1.end.row = range1.start.row;
              range1.end.column = this.session.getLine(range1.start.row).length;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config2, null, extraStyle);
            } else {
              this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;right:" + padding + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
            }
            if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
              var range1 = range.clone();
              range1.start.row = range1.end.row;
              range1.start.column = 0;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config2, null, extraStyle);
            } else {
              top = this.$getTop(range.end.row, config2);
              var width = range.end.column * config2.characterWidth;
              this.elt(clazz + " ace_br12", "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
            }
            height = (range.end.row - range.start.row - 1) * config2.lineHeight;
            if (height <= 0)
              return;
            top = this.$getTop(range.start.row + 1, config2);
            var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
            this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;right:" + padding + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
          };
          Marker2.prototype.drawSingleLineMarker = function(stringBuilder, range, clazz, config2, extraLength, extraStyle) {
            if (this.session.$bidiHandler.isBidiRow(range.start.row))
              return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config2, extraLength, extraStyle);
            var height = config2.lineHeight;
            var width = (range.end.column + (extraLength || 0) - range.start.column) * config2.characterWidth;
            var top = this.$getTop(range.start.row, config2);
            var left = this.$padding + range.start.column * config2.characterWidth;
            this.elt(clazz, "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
          };
          Marker2.prototype.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config2, extraLength, extraStyle) {
            var height = config2.lineHeight, top = this.$getTop(range.start.row, config2), padding = this.$padding;
            var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
            selections.forEach(function(selection) {
              this.elt(clazz, "height:" + height + "px;width:" + (selection.width + (extraLength || 0)) + "px;top:" + top + "px;left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
            }, this);
          };
          Marker2.prototype.drawFullLineMarker = function(stringBuilder, range, clazz, config2, extraStyle) {
            var top = this.$getTop(range.start.row, config2);
            var height = config2.lineHeight;
            if (range.start.row != range.end.row)
              height += this.$getTop(range.end.row, config2) - top;
            this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
          };
          Marker2.prototype.drawScreenLineMarker = function(stringBuilder, range, clazz, config2, extraStyle) {
            var top = this.$getTop(range.start.row, config2);
            var height = config2.lineHeight;
            this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
          };
          return Marker2;
        }()
      );
      Marker.prototype.$padding = 0;
      function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
      }
      exports2.Marker = Marker;
    });
    ace.define("ace/layer/text_util", ["require", "exports", "module"], function(require2, exports2, module2) {
      var textTokens = /* @__PURE__ */ new Set(["text", "rparen", "lparen"]);
      exports2.isTextToken = function(tokenType) {
        return textTokens.has(tokenType);
      };
    });
    ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/layer/lines", "ace/lib/event_emitter", "ace/config", "ace/layer/text_util"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("../lib/oop");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var Lines = require2("./lines").Lines;
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var nls = require2("../config").nls;
      var isTextToken = require2("./text_util").isTextToken;
      var Text = (
        /** @class */
        function() {
          function Text2(parentEl) {
            this.dom = dom;
            this.element = this.dom.createElement("div");
            this.element.className = "ace_layer ace_text-layer";
            parentEl.appendChild(this.element);
            this.$updateEolChar = this.$updateEolChar.bind(this);
            this.$lines = new Lines(this.element);
          }
          Text2.prototype.$updateEolChar = function() {
            var doc2 = this.session.doc;
            var unixMode = doc2.getNewLineCharacter() == "\n" && doc2.getNewLineMode() != "windows";
            var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != EOL_CHAR) {
              this.EOL_CHAR = EOL_CHAR;
              return true;
            }
          };
          Text2.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.element.style.margin = "0 " + padding + "px";
          };
          Text2.prototype.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
          };
          Text2.prototype.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
          };
          Text2.prototype.$setFontMetrics = function(measure) {
            this.$fontMetrics = measure;
            this.$fontMetrics.on(
              "changeCharacterSize",
              function(e75) {
                this._signal("changeCharacterSize", e75);
              }.bind(this)
            );
            this.$pollSizeChanges();
          };
          Text2.prototype.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
          };
          Text2.prototype.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
          };
          Text2.prototype.setSession = function(session) {
            this.session = session;
            if (session)
              this.$computeTabString();
          };
          Text2.prototype.setShowInvisibles = function(showInvisibles) {
            if (this.showInvisibles == showInvisibles)
              return false;
            this.showInvisibles = showInvisibles;
            if (typeof showInvisibles == "string") {
              this.showSpaces = /tab/i.test(showInvisibles);
              this.showTabs = /space/i.test(showInvisibles);
              this.showEOL = /eol/i.test(showInvisibles);
            } else {
              this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
            }
            this.$computeTabString();
            return true;
          };
          Text2.prototype.setDisplayIndentGuides = function(display) {
            if (this.displayIndentGuides == display)
              return false;
            this.displayIndentGuides = display;
            this.$computeTabString();
            return true;
          };
          Text2.prototype.setHighlightIndentGuides = function(highlight) {
            if (this.$highlightIndentGuides === highlight)
              return false;
            this.$highlightIndentGuides = highlight;
            return highlight;
          };
          Text2.prototype.$computeTabString = function() {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [0];
            for (var i = 1; i < tabSize + 1; i++) {
              if (this.showTabs) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_tab";
                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                tabStr.push(span);
              } else {
                tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
              }
            }
            if (this.displayIndentGuides) {
              this.$indentGuideRe = /\s\S| \t|\t |\s$/;
              var className = "ace_indent-guide";
              var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
              var spaceContent = this.showSpaces ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize) : lang.stringRepeat(" ", this.tabSize);
              var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
              var tabContent = this.showTabs ? lang.stringRepeat(this.TAB_CHAR, this.tabSize) : spaceContent;
              var span = this.dom.createElement("span");
              span.className = className + spaceClass;
              span.textContent = spaceContent;
              this.$tabStrings[" "] = span;
              var span = this.dom.createElement("span");
              span.className = className + tabClass;
              span.textContent = tabContent;
              this.$tabStrings["	"] = span;
            }
          };
          Text2.prototype.updateLines = function(config2, firstRow, lastRow) {
            if (this.config.lastRow != config2.lastRow || this.config.firstRow != config2.firstRow) {
              return this.update(config2);
            }
            this.config = config2;
            var first = Math.max(firstRow, config2.firstRow);
            var last = Math.min(lastRow, config2.lastRow);
            var lineElements = this.element.childNodes;
            var lineElementsIdx = 0;
            for (var row = config2.firstRow; row < first; row++) {
              var foldLine = this.session.getFoldLine(row);
              if (foldLine) {
                if (foldLine.containsRow(first)) {
                  first = foldLine.start.row;
                  break;
                } else {
                  row = foldLine.end.row;
                }
              }
              lineElementsIdx++;
            }
            var heightChanged = false;
            var row = first;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > last)
                break;
              var lineElement = lineElements[lineElementsIdx++];
              if (lineElement) {
                this.dom.removeChildren(lineElement);
                this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
                if (heightChanged)
                  lineElement.style.top = this.$lines.computeLineTop(row, config2, this.session) + "px";
                var height = config2.lineHeight * this.session.getRowLength(row) + "px";
                if (lineElement.style.height != height) {
                  heightChanged = true;
                  lineElement.style.height = height;
                }
              }
              row++;
            }
            if (heightChanged) {
              while (lineElementsIdx < this.$lines.cells.length) {
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config2, this.session) + "px";
              }
            }
          };
          Text2.prototype.scrollLines = function(config2) {
            var oldConfig = this.config;
            this.config = config2;
            if (this.$lines.pageChanged(oldConfig, config2))
              return this.update(config2);
            this.$lines.moveContainer(config2);
            var lastRow = config2.lastRow;
            var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
            if (!oldConfig || oldLastRow < config2.firstRow)
              return this.update(config2);
            if (lastRow < oldConfig.firstRow)
              return this.update(config2);
            if (!oldConfig || oldConfig.lastRow < config2.firstRow)
              return this.update(config2);
            if (config2.lastRow < oldConfig.firstRow)
              return this.update(config2);
            if (oldConfig.firstRow < config2.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config2.firstRow - 1); row > 0; row--)
                this.$lines.shift();
            if (oldConfig.lastRow > config2.lastRow)
              for (var row = this.session.getFoldedRowCount(config2.lastRow + 1, oldConfig.lastRow); row > 0; row--)
                this.$lines.pop();
            if (config2.firstRow < oldConfig.firstRow) {
              this.$lines.unshift(this.$renderLinesFragment(config2, config2.firstRow, oldConfig.firstRow - 1));
            }
            if (config2.lastRow > oldConfig.lastRow) {
              this.$lines.push(this.$renderLinesFragment(config2, oldConfig.lastRow + 1, config2.lastRow));
            }
            this.$highlightIndentGuide();
          };
          Text2.prototype.$renderLinesFragment = function(config2, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var line = this.$lines.createCell(row, config2, this.session);
              var lineEl = line.element;
              this.dom.removeChildren(lineEl);
              dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config2, this.session) + "px");
              dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config2, this.session) + "px");
              this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
              if (this.$useLineGroups()) {
                lineEl.className = "ace_line_group";
              } else {
                lineEl.className = "ace_line";
              }
              fragment.push(line);
              row++;
            }
            return fragment;
          };
          Text2.prototype.update = function(config2) {
            this.$lines.moveContainer(config2);
            this.config = config2;
            var firstRow = config2.firstRow;
            var lastRow = config2.lastRow;
            var lines = this.$lines;
            while (lines.getLength())
              lines.pop();
            lines.push(this.$renderLinesFragment(config2, firstRow, lastRow));
          };
          Text2.prototype.$renderToken = function(parent, screenColumn, token, value) {
            var self2 = this;
            var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206B\u206C\u206D\u206E\u206F]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
            var valueFragment = this.dom.createFragment(this.element);
            var m;
            var i = 0;
            while (m = re.exec(value)) {
              var tab = m[1];
              var simpleSpace = m[2];
              var controlCharacter = m[3];
              var cjkSpace = m[4];
              var cjk = m[5];
              if (!self2.showSpaces && simpleSpace)
                continue;
              var before = i != m.index ? value.slice(i, m.index) : "";
              i = m.index + m[0].length;
              if (before) {
                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
              }
              if (tab) {
                var tabSize = self2.session.getScreenTabSize(screenColumn + m.index);
                valueFragment.appendChild(self2.$tabStrings[tabSize].cloneNode(true));
                screenColumn += tabSize - 1;
              } else if (simpleSpace) {
                if (self2.showSpaces) {
                  var span = this.dom.createElement("span");
                  span.className = "ace_invisible ace_invisible_space";
                  span.textContent = lang.stringRepeat(self2.SPACE_CHAR, simpleSpace.length);
                  valueFragment.appendChild(span);
                } else {
                  valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));
                }
              } else if (controlCharacter) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_space ace_invalid";
                span.textContent = lang.stringRepeat(self2.SPACE_CHAR, controlCharacter.length);
                valueFragment.appendChild(span);
              } else if (cjkSpace) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = self2.config.characterWidth * 2 + "px";
                span.className = self2.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                span.textContent = self2.showSpaces ? self2.SPACE_CHAR : cjkSpace;
                valueFragment.appendChild(span);
              } else if (cjk) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = self2.config.characterWidth * 2 + "px";
                span.className = "ace_cjk";
                span.textContent = cjk;
                valueFragment.appendChild(span);
              }
            }
            valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));
            if (!isTextToken(token.type)) {
              var classes = "ace_" + token.type.replace(/\./g, " ace_");
              var span = this.dom.createElement("span");
              if (token.type == "fold") {
                span.style.width = token.value.length * this.config.characterWidth + "px";
                span.setAttribute("title", nls("inline-fold.closed.title", "Unfold code"));
              }
              span.className = classes;
              span.appendChild(valueFragment);
              parent.appendChild(span);
            } else {
              parent.appendChild(valueFragment);
            }
            return screenColumn + value.length;
          };
          Text2.prototype.renderIndentGuide = function(parent, value, max) {
            var cols = value.search(this.$indentGuideRe);
            if (cols <= 0 || cols >= max)
              return value;
            if (value[0] == " ") {
              cols -= cols % this.tabSize;
              var count = cols / this.tabSize;
              for (var i = 0; i < count; i++) {
                parent.appendChild(this.$tabStrings[" "].cloneNode(true));
              }
              this.$highlightIndentGuide();
              return value.substr(cols);
            } else if (value[0] == "	") {
              for (var i = 0; i < cols; i++) {
                parent.appendChild(this.$tabStrings["	"].cloneNode(true));
              }
              this.$highlightIndentGuide();
              return value.substr(cols);
            }
            this.$highlightIndentGuide();
            return value;
          };
          Text2.prototype.$highlightIndentGuide = function() {
            if (!this.$highlightIndentGuides || !this.displayIndentGuides)
              return;
            this.$highlightIndentGuideMarker = {
              indentLevel: void 0,
              start: void 0,
              end: void 0,
              dir: void 0
            };
            var lines = this.session.doc.$lines;
            if (!lines)
              return;
            var cursor = this.session.selection.getCursor();
            var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
            var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
            this.$highlightIndentGuideMarker = {
              indentLevel: elementIndentLevel,
              start: cursor.row
            };
            var bracketHighlight = this.session.$bracketHighlight;
            if (bracketHighlight) {
              var ranges = this.session.$bracketHighlight.ranges;
              for (var i = 0; i < ranges.length; i++) {
                if (cursor.row !== ranges[i].start.row) {
                  this.$highlightIndentGuideMarker.end = ranges[i].start.row + 1;
                  if (cursor.row > ranges[i].start.row) {
                    this.$highlightIndentGuideMarker.dir = -1;
                  } else {
                    this.$highlightIndentGuideMarker.dir = 1;
                  }
                  break;
                }
              }
            }
            if (!this.$highlightIndentGuideMarker.end) {
              if (lines[cursor.row] !== "" && cursor.column === lines[cursor.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for (var i = cursor.row + 1; i < lines.length; i++) {
                  var line = lines[i];
                  var currentIndent = /^\s*/.exec(line)[0].length;
                  if (line !== "") {
                    this.$highlightIndentGuideMarker.end = i;
                    if (currentIndent <= initialIndent)
                      break;
                  }
                }
              }
            }
            this.$renderHighlightIndentGuide();
          };
          Text2.prototype.$clearActiveIndentGuide = function() {
            var activeIndentGuides = this.element.querySelectorAll(".ace_indent-guide-active");
            for (var i = 0; i < activeIndentGuides.length; i++) {
              activeIndentGuides[i].classList.remove("ace_indent-guide-active");
            }
          };
          Text2.prototype.$setIndentGuideActive = function(cell, indentLevel) {
            var line = this.session.doc.getLine(cell.row);
            if (line !== "") {
              var element = cell.element;
              if (cell.element.classList && cell.element.classList.contains("ace_line_group")) {
                if (cell.element.childNodes.length > 0) {
                  element = cell.element.childNodes[0];
                } else {
                  return;
                }
              }
              var childNodes = element.childNodes;
              if (childNodes) {
                var node = childNodes[indentLevel - 1];
                if (node && node.classList && node.classList.contains("ace_indent-guide"))
                  node.classList.add("ace_indent-guide-active");
              }
            }
          };
          Text2.prototype.$renderHighlightIndentGuide = function() {
            if (!this.$lines)
              return;
            var cells = this.$lines.cells;
            this.$clearActiveIndentGuide();
            var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
            if (indentLevel !== 0) {
              if (this.$highlightIndentGuideMarker.dir === 1) {
                for (var i = 0; i < cells.length; i++) {
                  var cell = cells[i];
                  if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start + 1) {
                    if (cell.row >= this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(cell, indentLevel);
                  }
                }
              } else {
                for (var i = cells.length - 1; i >= 0; i--) {
                  var cell = cells[i];
                  if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                    if (cell.row < this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(cell, indentLevel);
                  }
                }
              }
            }
          };
          Text2.prototype.$createLineElement = function(parent) {
            var lineEl = this.dom.createElement("div");
            lineEl.className = "ace_line";
            lineEl.style.height = this.config.lineHeight + "px";
            return lineEl;
          };
          Text2.prototype.$renderWrappedLine = function(parent, tokens2, splits) {
            var chars = 0;
            var split = 0;
            var splitChars = splits[0];
            var screenColumn = 0;
            var lineEl = this.$createLineElement();
            parent.appendChild(lineEl);
            for (var i = 0; i < tokens2.length; i++) {
              var token = tokens2[i];
              var value = token.value;
              if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(lineEl, value, splitChars);
                if (!value)
                  continue;
                chars -= value.length;
              }
              if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                chars += value.length;
              } else {
                while (chars + value.length >= splitChars) {
                  screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
                  value = value.substring(splitChars - chars);
                  chars = splitChars;
                  lineEl = this.$createLineElement();
                  parent.appendChild(lineEl);
                  lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("", splits.indent), this.element));
                  split++;
                  screenColumn = 0;
                  splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                  chars += value.length;
                  screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                }
              }
            }
            if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
              this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
          };
          Text2.prototype.$renderSimpleLine = function(parent, tokens2) {
            var screenColumn = 0;
            for (var i = 0; i < tokens2.length; i++) {
              var token = tokens2[i];
              var value = token.value;
              if (i == 0 && this.displayIndentGuides) {
                value = this.renderIndentGuide(parent, value);
                if (!value)
                  continue;
              }
              if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(parent, screenColumn, token, value);
              screenColumn = this.$renderToken(parent, screenColumn, token, value);
            }
          };
          Text2.prototype.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
            token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
            var overflowEl = this.dom.createElement("span");
            overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
            overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
            parent.appendChild(overflowEl);
          };
          Text2.prototype.$renderLine = function(parent, row, foldLine) {
            if (!foldLine && foldLine != false)
              foldLine = this.session.getFoldLine(row);
            if (foldLine)
              var tokens2 = this.$getFoldLineTokens(row, foldLine);
            else
              var tokens2 = this.session.getTokens(row);
            var lastLineEl = parent;
            if (tokens2.length) {
              var splits = this.session.getRowSplitData(row);
              if (splits && splits.length) {
                this.$renderWrappedLine(parent, tokens2, splits);
                var lastLineEl = parent.lastChild;
              } else {
                var lastLineEl = parent;
                if (this.$useLineGroups()) {
                  lastLineEl = this.$createLineElement();
                  parent.appendChild(lastLineEl);
                }
                this.$renderSimpleLine(lastLineEl, tokens2);
              }
            } else if (this.$useLineGroups()) {
              lastLineEl = this.$createLineElement();
              parent.appendChild(lastLineEl);
            }
            if (this.showEOL && lastLineEl) {
              if (foldLine)
                row = foldLine.end.row;
              var invisibleEl = this.dom.createElement("span");
              invisibleEl.className = "ace_invisible ace_invisible_eol";
              invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
              lastLineEl.appendChild(invisibleEl);
            }
          };
          Text2.prototype.$getFoldLineTokens = function(row, foldLine) {
            var session = this.session;
            var renderTokens = [];
            function addTokens(tokens3, from, to) {
              var idx = 0, col = 0;
              while (col + tokens3[idx].value.length < from) {
                col += tokens3[idx].value.length;
                idx++;
                if (idx == tokens3.length)
                  return;
              }
              if (col != from) {
                var value = tokens3[idx].value.substring(from - col);
                if (value.length > to - from)
                  value = value.substring(0, to - from);
                renderTokens.push({
                  type: tokens3[idx].type,
                  value
                });
                col = from + value.length;
                idx += 1;
              }
              while (col < to && idx < tokens3.length) {
                var value = tokens3[idx].value;
                if (value.length + col > to) {
                  renderTokens.push({
                    type: tokens3[idx].type,
                    value: value.substring(0, to - col)
                  });
                } else
                  renderTokens.push(tokens3[idx]);
                col += value.length;
                idx += 1;
              }
            }
            var tokens2 = session.getTokens(row);
            foldLine.walk(function(placeholder, row2, column, lastColumn, isNewRow) {
              if (placeholder != null) {
                renderTokens.push({
                  type: "fold",
                  value: placeholder
                });
              } else {
                if (isNewRow)
                  tokens2 = session.getTokens(row2);
                if (tokens2.length)
                  addTokens(tokens2, lastColumn, column);
              }
            }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
            return renderTokens;
          };
          Text2.prototype.$useLineGroups = function() {
            return this.session.getUseWrapMode();
          };
          return Text2;
        }()
      );
      Text.prototype.EOF_CHAR = "";
      Text.prototype.EOL_CHAR_LF = "";
      Text.prototype.EOL_CHAR_CRLF = "";
      Text.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;
      Text.prototype.TAB_CHAR = "";
      Text.prototype.SPACE_CHAR = "";
      Text.prototype.$padding = 0;
      Text.prototype.MAX_LINE_LENGTH = 1e4;
      Text.prototype.showInvisibles = false;
      Text.prototype.showSpaces = false;
      Text.prototype.showTabs = false;
      Text.prototype.showEOL = false;
      Text.prototype.displayIndentGuides = true;
      Text.prototype.$highlightIndentGuides = true;
      Text.prototype.$tabStrings = [];
      Text.prototype.destroy = {};
      Text.prototype.onChangeTabSize = Text.prototype.$computeTabString;
      oop.implement(Text.prototype, EventEmitter);
      exports2.Text = Text;
    });
    ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var Cursor = (
        /** @class */
        function() {
          function Cursor2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_cursor-layer";
            parentEl.appendChild(this.element);
            this.isVisible = false;
            this.isBlinking = true;
            this.blinkInterval = 1e3;
            this.smoothBlinking = false;
            this.cursors = [];
            this.cursor = this.addCursor();
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.$updateCursors = this.$updateOpacity.bind(this);
          }
          Cursor2.prototype.$updateOpacity = function(val) {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
              dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
          };
          Cursor2.prototype.$startCssAnimation = function() {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
              cursors[i].style.animationDuration = this.blinkInterval + "ms";
            this.$isAnimating = true;
            setTimeout(function() {
              if (this.$isAnimating) {
                dom.addCssClass(this.element, "ace_animate-blinking");
              }
            }.bind(this));
          };
          Cursor2.prototype.$stopCssAnimation = function() {
            this.$isAnimating = false;
            dom.removeCssClass(this.element, "ace_animate-blinking");
          };
          Cursor2.prototype.setPadding = function(padding) {
            this.$padding = padding;
          };
          Cursor2.prototype.setSession = function(session) {
            this.session = session;
          };
          Cursor2.prototype.setBlinking = function(blinking) {
            if (blinking != this.isBlinking) {
              this.isBlinking = blinking;
              this.restartTimer();
            }
          };
          Cursor2.prototype.setBlinkInterval = function(blinkInterval) {
            if (blinkInterval != this.blinkInterval) {
              this.blinkInterval = blinkInterval;
              this.restartTimer();
            }
          };
          Cursor2.prototype.setSmoothBlinking = function(smoothBlinking) {
            if (smoothBlinking != this.smoothBlinking) {
              this.smoothBlinking = smoothBlinking;
              dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
              this.$updateCursors(true);
              this.restartTimer();
            }
          };
          Cursor2.prototype.addCursor = function() {
            var el = dom.createElement("div");
            el.className = "ace_cursor";
            this.element.appendChild(el);
            this.cursors.push(el);
            return el;
          };
          Cursor2.prototype.removeCursor = function() {
            if (this.cursors.length > 1) {
              var el = this.cursors.pop();
              el.parentNode.removeChild(el);
              return el;
            }
          };
          Cursor2.prototype.hideCursor = function() {
            this.isVisible = false;
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          Cursor2.prototype.showCursor = function() {
            this.isVisible = true;
            dom.removeCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          Cursor2.prototype.restartTimer = function() {
            var update = this.$updateCursors;
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
            this.$stopCssAnimation();
            if (this.smoothBlinking) {
              this.$isSmoothBlinking = false;
              dom.removeCssClass(this.element, "ace_smooth-blinking");
            }
            update(true);
            if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
              this.$stopCssAnimation();
              return;
            }
            if (this.smoothBlinking) {
              this.$isSmoothBlinking = true;
              setTimeout(function() {
                if (this.$isSmoothBlinking) {
                  dom.addCssClass(this.element, "ace_smooth-blinking");
                }
              }.bind(this));
            }
            if (dom.HAS_CSS_ANIMATION) {
              this.$startCssAnimation();
            } else {
              var blink = (
                /**@this{Cursor}*/
                function() {
                  this.timeoutId = setTimeout(function() {
                    update(false);
                  }, 0.6 * this.blinkInterval);
                }.bind(this)
              );
              this.intervalId = setInterval(function() {
                update(true);
                blink();
              }, this.blinkInterval);
              blink();
            }
          };
          Cursor2.prototype.getPixelPosition = function(position2, onScreen) {
            if (!this.config || !this.session)
              return { left: 0, top: 0 };
            if (!position2)
              position2 = this.session.selection.getCursor();
            var pos = this.session.documentToScreenPosition(position2);
            var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position2.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
            var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
            return { left: cursorLeft, top: cursorTop };
          };
          Cursor2.prototype.isCursorInView = function(pixelPos, config2) {
            return pixelPos.top >= 0 && pixelPos.top < config2.maxHeight;
          };
          Cursor2.prototype.update = function(config2) {
            this.config = config2;
            var selections = this.session.$selectionMarkers;
            var i = 0, cursorIndex = 0;
            if (selections === void 0 || selections.length === 0) {
              selections = [{ cursor: null }];
            }
            for (var i = 0, n = selections.length; i < n; i++) {
              var pixelPos = this.getPixelPosition(selections[i].cursor, true);
              if ((pixelPos.top > config2.height + config2.offset || pixelPos.top < 0) && i > 1) {
                continue;
              }
              var element = this.cursors[cursorIndex++] || this.addCursor();
              var style = element.style;
              if (!this.drawCursor) {
                if (!this.isCursorInView(pixelPos, config2)) {
                  dom.setStyle(style, "display", "none");
                } else {
                  dom.setStyle(style, "display", "block");
                  dom.translate(element, pixelPos.left, pixelPos.top);
                  dom.setStyle(style, "width", Math.round(config2.characterWidth) + "px");
                  dom.setStyle(style, "height", config2.lineHeight + "px");
                }
              } else {
                this.drawCursor(element, pixelPos, config2, selections[i], this.session);
              }
            }
            while (this.cursors.length > cursorIndex)
              this.removeCursor();
            var overwrite = this.session.getOverwrite();
            this.$setOverwrite(overwrite);
            this.$pixelPos = pixelPos;
            this.restartTimer();
          };
          Cursor2.prototype.$setOverwrite = function(overwrite) {
            if (overwrite != this.overwrite) {
              this.overwrite = overwrite;
              if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
              else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
            }
          };
          Cursor2.prototype.destroy = function() {
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
          };
          return Cursor2;
        }()
      );
      Cursor.prototype.$padding = 0;
      Cursor.prototype.drawCursor = null;
      exports2.Cursor = Cursor;
    });
    ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var event = require2("./lib/event");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var MAX_SCROLL_H = 32768;
      var Scrollbar = (
        /** @class */
        function() {
          function Scrollbar2(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "ace_scrollbar-inner";
            this.inner.textContent = "";
            this.element.appendChild(this.inner);
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addListener(this.element, "scroll", this.onScroll.bind(this));
            event.addListener(this.element, "mousedown", event.preventDefault);
          }
          Scrollbar2.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
          return Scrollbar2;
        }()
      );
      oop.implement(Scrollbar.prototype, EventEmitter);
      var VScrollBar = (
        /** @class */
        function(_super) {
          __extends(VScrollBar2, _super);
          function VScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            renderer.$scrollbarWidth = _this.width = dom.scrollbarWidth(parent.ownerDocument);
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + 5 + "px";
            _this.$minWidth = 0;
            return _this;
          }
          VScrollBar2.prototype.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollTop = this.element.scrollTop;
              if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
              }
              this._emit("scroll", { data: this.scrollTop });
            }
            this.skipEvent = false;
          };
          VScrollBar2.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          VScrollBar2.prototype.setHeight = function(height) {
            this.element.style.height = height + "px";
          };
          VScrollBar2.prototype.setScrollHeight = function(height) {
            this.scrollHeight = height;
            if (height > MAX_SCROLL_H) {
              this.coeff = MAX_SCROLL_H / height;
              height = MAX_SCROLL_H;
            } else if (this.coeff != 1) {
              this.coeff = 1;
            }
            this.inner.style.height = height + "px";
          };
          VScrollBar2.prototype.setScrollTop = function(scrollTop) {
            if (this.scrollTop != scrollTop) {
              this.skipEvent = true;
              this.scrollTop = scrollTop;
              this.element.scrollTop = scrollTop * this.coeff;
            }
          };
          return VScrollBar2;
        }(Scrollbar)
      );
      VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
      var HScrollBar = (
        /** @class */
        function(_super) {
          __extends(HScrollBar2, _super);
          function HScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.height = renderer.$scrollbarWidth;
            _this.inner.style.height = _this.element.style.height = (_this.height || 15) + 5 + "px";
            return _this;
          }
          HScrollBar2.prototype.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollLeft = this.element.scrollLeft;
              this._emit("scroll", { data: this.scrollLeft });
            }
            this.skipEvent = false;
          };
          HScrollBar2.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          HScrollBar2.prototype.setWidth = function(width) {
            this.element.style.width = width + "px";
          };
          HScrollBar2.prototype.setInnerWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          HScrollBar2.prototype.setScrollWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
            if (this.scrollLeft != scrollLeft) {
              this.skipEvent = true;
              this.scrollLeft = this.element.scrollLeft = scrollLeft;
            }
          };
          return HScrollBar2;
        }(Scrollbar)
      );
      exports2.ScrollBar = VScrollBar;
      exports2.ScrollBarV = VScrollBar;
      exports2.ScrollBarH = HScrollBar;
      exports2.VScrollBar = VScrollBar;
      exports2.HScrollBar = HScrollBar;
    });
    ace.define("ace/scrollbar_custom", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var event = require2("./lib/event");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      dom.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", false);
      var ScrollBar = (
        /** @class */
        function() {
          function ScrollBar2(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_sb" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "";
            this.element.appendChild(this.inner);
            this.VScrollWidth = 12;
            this.HScrollHeight = 12;
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
          }
          ScrollBar2.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
          return ScrollBar2;
        }()
      );
      oop.implement(ScrollBar.prototype, EventEmitter);
      var VScrollBar = (
        /** @class */
        function(_super) {
          __extends(VScrollBar2, _super);
          function VScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            _this.parent = parent;
            _this.width = _this.VScrollWidth;
            _this.renderer = renderer;
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + "px";
            _this.$minWidth = 0;
            return _this;
          }
          VScrollBar2.prototype.onMouseDown = function(eType, e75) {
            if (eType !== "mousedown")
              return;
            if (event.getButton(e75) !== 0 || e75.detail === 2) {
              return;
            }
            if (e75.target === this.inner) {
              var self2 = this;
              var mousePageY = e75.clientY;
              var onMouseMove = function(e76) {
                mousePageY = e76.clientY;
              };
              var onMouseUp = function() {
                clearInterval(timerId);
              };
              var startY = e75.clientY;
              var startTop = this.thumbTop;
              var onScrollInterval = function() {
                if (mousePageY === void 0)
                  return;
                var scrollTop = self2.scrollTopFromThumbTop(startTop + mousePageY - startY);
                if (scrollTop === self2.scrollTop)
                  return;
                self2._emit("scroll", { data: scrollTop });
              };
              event.capture(this.inner, onMouseMove, onMouseUp);
              var timerId = setInterval(onScrollInterval, 20);
              return event.preventDefault(e75);
            }
            var top = e75.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
            this._emit("scroll", { data: this.scrollTopFromThumbTop(top) });
            return event.preventDefault(e75);
          };
          VScrollBar2.prototype.getHeight = function() {
            return this.height;
          };
          VScrollBar2.prototype.scrollTopFromThumbTop = function(thumbTop) {
            var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
            scrollTop = scrollTop >> 0;
            if (scrollTop < 0) {
              scrollTop = 0;
            } else if (scrollTop > this.pageHeight - this.viewHeight) {
              scrollTop = this.pageHeight - this.viewHeight;
            }
            return scrollTop;
          };
          VScrollBar2.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          VScrollBar2.prototype.setHeight = function(height) {
            this.height = Math.max(0, height);
            this.slideHeight = this.height;
            this.viewHeight = this.height;
            this.setScrollHeight(this.pageHeight, true);
          };
          VScrollBar2.prototype.setScrollHeight = function(height, force) {
            if (this.pageHeight === height && !force)
              return;
            this.pageHeight = height;
            this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
            if (this.thumbHeight > this.slideHeight)
              this.thumbHeight = this.slideHeight;
            if (this.thumbHeight < 15)
              this.thumbHeight = 15;
            this.inner.style.height = this.thumbHeight + "px";
            if (this.scrollTop > this.pageHeight - this.viewHeight) {
              this.scrollTop = this.pageHeight - this.viewHeight;
              if (this.scrollTop < 0)
                this.scrollTop = 0;
              this._emit("scroll", { data: this.scrollTop });
            }
          };
          VScrollBar2.prototype.setScrollTop = function(scrollTop) {
            this.scrollTop = scrollTop;
            if (scrollTop < 0)
              scrollTop = 0;
            this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
            this.inner.style.top = this.thumbTop + "px";
          };
          return VScrollBar2;
        }(ScrollBar)
      );
      VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
      var HScrollBar = (
        /** @class */
        function(_super) {
          __extends(HScrollBar2, _super);
          function HScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.scrollWidth = 0;
            _this.height = _this.HScrollHeight;
            _this.inner.style.height = _this.element.style.height = (_this.height || 12) + "px";
            _this.renderer = renderer;
            return _this;
          }
          HScrollBar2.prototype.onMouseDown = function(eType, e75) {
            if (eType !== "mousedown")
              return;
            if (event.getButton(e75) !== 0 || e75.detail === 2) {
              return;
            }
            if (e75.target === this.inner) {
              var self2 = this;
              var mousePageX = e75.clientX;
              var onMouseMove = function(e76) {
                mousePageX = e76.clientX;
              };
              var onMouseUp = function() {
                clearInterval(timerId);
              };
              var startX = e75.clientX;
              var startLeft = this.thumbLeft;
              var onScrollInterval = function() {
                if (mousePageX === void 0)
                  return;
                var scrollLeft = self2.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                if (scrollLeft === self2.scrollLeft)
                  return;
                self2._emit("scroll", { data: scrollLeft });
              };
              event.capture(this.inner, onMouseMove, onMouseUp);
              var timerId = setInterval(onScrollInterval, 20);
              return event.preventDefault(e75);
            }
            var left = e75.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
            this._emit("scroll", { data: this.scrollLeftFromThumbLeft(left) });
            return event.preventDefault(e75);
          };
          HScrollBar2.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          HScrollBar2.prototype.scrollLeftFromThumbLeft = function(thumbLeft) {
            var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
            scrollLeft = scrollLeft >> 0;
            if (scrollLeft < 0) {
              scrollLeft = 0;
            } else if (scrollLeft > this.pageWidth - this.viewWidth) {
              scrollLeft = this.pageWidth - this.viewWidth;
            }
            return scrollLeft;
          };
          HScrollBar2.prototype.setWidth = function(width) {
            this.width = Math.max(0, width);
            this.element.style.width = this.width + "px";
            this.slideWidth = this.width;
            this.viewWidth = this.width;
            this.setScrollWidth(this.pageWidth, true);
          };
          HScrollBar2.prototype.setScrollWidth = function(width, force) {
            if (this.pageWidth === width && !force)
              return;
            this.pageWidth = width;
            this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
            if (this.thumbWidth > this.slideWidth)
              this.thumbWidth = this.slideWidth;
            if (this.thumbWidth < 15)
              this.thumbWidth = 15;
            this.inner.style.width = this.thumbWidth + "px";
            if (this.scrollLeft > this.pageWidth - this.viewWidth) {
              this.scrollLeft = this.pageWidth - this.viewWidth;
              if (this.scrollLeft < 0)
                this.scrollLeft = 0;
              this._emit("scroll", { data: this.scrollLeft });
            }
          };
          HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
            this.scrollLeft = scrollLeft;
            if (scrollLeft < 0)
              scrollLeft = 0;
            this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
            this.inner.style.left = this.thumbLeft + "px";
          };
          return HScrollBar2;
        }(ScrollBar)
      );
      HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;
      exports2.ScrollBar = VScrollBar;
      exports2.ScrollBarV = VScrollBar;
      exports2.ScrollBarH = HScrollBar;
      exports2.VScrollBar = VScrollBar;
      exports2.HScrollBar = HScrollBar;
    });
    ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(require2, exports2, module2) {
      "use strict";
      var event = require2("./lib/event");
      var RenderLoop = (
        /** @class */
        function() {
          function RenderLoop2(onRender, win) {
            this.onRender = onRender;
            this.pending = false;
            this.changes = 0;
            this.$recursionLimit = 2;
            this.window = win || window;
            var _self = this;
            this._flush = function(ts) {
              _self.pending = false;
              var changes = _self.changes;
              if (changes) {
                event.blockIdle(100);
                _self.changes = 0;
                _self.onRender(changes);
              }
              if (_self.changes) {
                if (_self.$recursionLimit-- < 0)
                  return;
                _self.schedule();
              } else {
                _self.$recursionLimit = 2;
              }
            };
          }
          RenderLoop2.prototype.schedule = function(change) {
            this.changes = this.changes | change;
            if (this.changes && !this.pending) {
              event.nextFrame(this._flush);
              this.pending = true;
            }
          };
          RenderLoop2.prototype.clear = function(change) {
            var changes = this.changes;
            this.changes = 0;
            return changes;
          };
          return RenderLoop2;
        }()
      );
      exports2.RenderLoop = RenderLoop;
    });
    ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/lib/useragent", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      var oop = require2("../lib/oop");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var CHAR_COUNT = 512;
      var USE_OBSERVER = typeof ResizeObserver == "function";
      var L = 200;
      var FontMetrics = (
        /** @class */
        function() {
          function FontMetrics2(parentEl) {
            this.el = dom.createElement("div");
            this.$setMeasureNodeStyles(this.el.style, true);
            this.$main = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$main.style);
            this.$measureNode = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$measureNode.style);
            this.el.appendChild(this.$main);
            this.el.appendChild(this.$measureNode);
            parentEl.appendChild(this.el);
            this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
            this.$characterSize = { width: 0, height: 0 };
            if (USE_OBSERVER)
              this.$addObserver();
            else
              this.checkForSizeChanges();
          }
          FontMetrics2.prototype.$setMeasureNodeStyles = function(style, isRoot) {
            style.width = style.height = "auto";
            style.left = style.top = "0px";
            style.visibility = "hidden";
            style.position = "absolute";
            style.whiteSpace = "pre";
            if (useragent.isIE < 8) {
              style["font-family"] = "inherit";
            } else {
              style.font = "inherit";
            }
            style.overflow = isRoot ? "hidden" : "visible";
          };
          FontMetrics2.prototype.checkForSizeChanges = function(size) {
            if (size === void 0)
              size = this.$measureSizes();
            if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
              this.$measureNode.style.fontWeight = "bold";
              var boldSize = this.$measureSizes();
              this.$measureNode.style.fontWeight = "";
              this.$characterSize = size;
              this.charSizes = /* @__PURE__ */ Object.create(null);
              this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
              this._emit("changeCharacterSize", { data: size });
            }
          };
          FontMetrics2.prototype.$addObserver = function() {
            var self2 = this;
            this.$observer = new window.ResizeObserver(function(e75) {
              self2.checkForSizeChanges();
            });
            this.$observer.observe(this.$measureNode);
          };
          FontMetrics2.prototype.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer || this.$observer)
              return this.$pollSizeChangesTimer;
            var self2 = this;
            return this.$pollSizeChangesTimer = event.onIdle(function cb() {
              self2.checkForSizeChanges();
              event.onIdle(cb, 500);
            }, 500);
          };
          FontMetrics2.prototype.setPolling = function(val) {
            if (val) {
              this.$pollSizeChanges();
            } else if (this.$pollSizeChangesTimer) {
              clearInterval(this.$pollSizeChangesTimer);
              this.$pollSizeChangesTimer = 0;
            }
          };
          FontMetrics2.prototype.$measureSizes = function(node) {
            var size = {
              height: (node || this.$measureNode).clientHeight,
              width: (node || this.$measureNode).clientWidth / CHAR_COUNT
            };
            if (size.width === 0 || size.height === 0)
              return null;
            return size;
          };
          FontMetrics2.prototype.$measureCharWidth = function(ch) {
            this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
            var rect = this.$main.getBoundingClientRect();
            return rect.width / CHAR_COUNT;
          };
          FontMetrics2.prototype.getCharacterWidth = function(ch) {
            var w = this.charSizes[ch];
            if (w === void 0) {
              w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
            }
            return w;
          };
          FontMetrics2.prototype.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer);
            if (this.$observer)
              this.$observer.disconnect();
            if (this.el && this.el.parentNode)
              this.el.parentNode.removeChild(this.el);
          };
          FontMetrics2.prototype.$getZoom = function(element) {
            if (!element || !element.parentElement)
              return 1;
            return (Number(window.getComputedStyle(element)["zoom"]) || 1) * this.$getZoom(element.parentElement);
          };
          FontMetrics2.prototype.$initTransformMeasureNodes = function() {
            var t2 = function(t3, l) {
              return ["div", {
                style: "position: absolute;top:" + t3 + "px;left:" + l + "px;"
              }];
            };
            this.els = dom.buildDom([t2(0, 0), t2(L, 0), t2(0, L), t2(L, L)], this.el);
          };
          FontMetrics2.prototype.transformCoordinates = function(clientPos, elPos) {
            if (clientPos) {
              var zoom = this.$getZoom(this.el);
              clientPos = mul(1 / zoom, clientPos);
            }
            function solve(l1, l2, r) {
              var det = l1[1] * l2[0] - l1[0] * l2[1];
              return [
                (-l2[1] * r[0] + l2[0] * r[1]) / det,
                (+l1[1] * r[0] - l1[0] * r[1]) / det
              ];
            }
            function sub(a2, b2) {
              return [a2[0] - b2[0], a2[1] - b2[1]];
            }
            function add(a2, b2) {
              return [a2[0] + b2[0], a2[1] + b2[1]];
            }
            function mul(a2, b2) {
              return [a2 * b2[0], a2 * b2[1]];
            }
            if (!this.els)
              this.$initTransformMeasureNodes();
            function p(el) {
              var r = el.getBoundingClientRect();
              return [r.left, r.top];
            }
            var a = p(this.els[0]);
            var b = p(this.els[1]);
            var c = p(this.els[2]);
            var d = p(this.els[3]);
            var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));
            var m1 = mul(1 + h[0], sub(b, a));
            var m2 = mul(1 + h[1], sub(c, a));
            if (elPos) {
              var x = elPos;
              var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
              var ut = add(mul(x[0], m1), mul(x[1], m2));
              return add(mul(1 / k / L, ut), a);
            }
            var u = sub(clientPos, a);
            var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
            return mul(L, f);
          };
          return FontMetrics2;
        }()
      );
      FontMetrics.prototype.$characterSize = { width: 0, height: 0 };
      oop.implement(FontMetrics.prototype, EventEmitter);
      exports2.FontMetrics = FontMetrics;
    });
    ace.define("ace/css/editor-css", ["require", "exports", "module"], function(require2, exports2, module2) {
      module2.exports = `
.ace_br1 {border-top-left-radius    : 3px;}
.ace_br2 {border-top-right-radius   : 3px;}
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}
.ace_br4 {border-bottom-right-radius: 3px;}
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}
.ace_br8 {border-bottom-left-radius : 3px;}
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}


.ace_editor {
    position: relative;
    overflow: hidden;
    padding: 0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    forced-color-adjust: none;
}

.ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
}

.ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
}
.ace_invisible {
    font-variant-ligatures: none;
}

.ace_keyboard-focus:focus {
    box-shadow: inset 0 0 0 2px #5E9ED6;
    outline: none;
}

.ace_dragging .ace_scroller:before{
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
}
.ace_dragging.ace_dark .ace_scroller:before{
    background: rgba(0, 0, 0, 0.01);
}

.ace_gutter {
    position: absolute;
    overflow : hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 4;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
}

.ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
}

.ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
}

.ace_gutter-cell, .ace_gutter-cell_svg-icons {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
}

.ace_gutter-cell_svg-icons .ace_gutter_annotation {
    margin-left: -14px;
    float: left;
}

.ace_gutter-cell .ace_gutter_annotation {
    margin-left: -19px;
    float: left;
}

.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold, .ace_gutter-cell.ace_security, .ace_icon.ace_security, .ace_icon.ace_security_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_info, .ace_icon.ace_info, .ace_gutter-cell.ace_hint, .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info, .ace_dark .ace_gutter-cell.ace_hint, .ace_dark .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");
}

.ace_icon_svg.ace_error {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_security {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0iZGFya29yYW5nZSIgZmlsbD0ibm9uZSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgogICAgICAgIDxwYXRoIGNsYXNzPSJzdHJva2UtbGluZWpvaW4tcm91bmQiIGQ9Ik04IDE0LjgzMDdDOCAxNC44MzA3IDIgMTIuOTA0NyAyIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOEM3Ljk4OTk5IDEuMzQ5MTggMTAuNjkgMy4yNjU0OCAxNCAzLjI2NTQ4VjguMDg5OTJDMTQgMTIuOTA0NyA4IDE0LjgzMDcgOCAxNC44MzA3WiIvPgogICAgICAgIDxwYXRoIGQ9Ik0yIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOCIvPgogICAgICAgIDxwYXRoIGQ9Ik0xMy45OSA4LjA4OTkyVjMuMjY1NDhDMTAuNjggMy4yNjU0OCA4IDEuMzQ5MTggOCAxLjM0OTE4Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggNFY5Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggMTBWMTIiLz4KICAgIDwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_warning {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: darkorange;
}
.ace_icon_svg.ace_info {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: royalblue;
}
.ace_icon_svg.ace_hint {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0ic2lsdmVyIiBmaWxsPSJub25lIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTYgMTRIMTAiLz4KICAgICAgICA8cGF0aCBkPSJNOCAxMUg5QzkgOS40NzAwMiAxMiA4LjU0MDAyIDEyIDUuNzYwMDJDMTIuMDIgNC40MDAwMiAxMS4zOSAzLjM2MDAyIDEwLjQzIDIuNjcwMDJDOSAxLjY0MDAyIDcuMDAwMDEgMS42NDAwMiA1LjU3MDAxIDIuNjcwMDJDNC42MTAwMSAzLjM2MDAyIDMuOTggNC40MDAwMiA0IDUuNzYwMDJDNCA4LjU0MDAyIDcuMDAwMDEgOS40NzAwMiA3LjAwMDAxIDExSDhaIi8+CiAgICA8L2c+Cjwvc3ZnPg==");
    background-color: silver;
}

.ace_icon_svg.ace_error_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_security_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTcgMTQiIGZpbGw9Im5vbmUiPgogICAgPHBhdGggZD0iTTEwLjAwMDEgMTMuNjk5MkMxMC4wMDAxIDEzLjY5OTIgMTEuOTI0MSAxMy40NzYzIDEzIDEyLjY5OTJDMTQuNDEzOSAxMS42NzgxIDE2IDEwLjUgMTYuMTI1MSA2LjgxMTI2VjIuNTg5ODdDMTYuMTI1MSAyLjU0NzY4IDE2LjEyMjEgMi41MDYxOSAxNi4xMTY0IDIuNDY1NTlWMS43MTQ4NUgxNS4yNDE0TDE1LjIzMDcgMS43MTQ4NEwxNC42MjUxIDEuNjk5MjJWNi44MTEyM0MxNC42MjUxIDguNTEwNjEgMTQuNjI1MSA5LjQ2NDYxIDEyLjc4MjQgMTEuNzIxQzEyLjE1ODYgMTIuNDg0OCAxMC4wMDAxIDEzLjY5OTIgMTAuMDAwMSAxMy42OTkyWiIgZmlsbD0iY3JpbXNvbiIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuMzM2MDkgMC4zNjc0NzVDNy4wMzIxNCAwLjE1MjY1MiA2LjYyNTQ4IDAuMTUzNjE0IDYuMzIyNTMgMC4zNjk5OTdMNi4zMDg2OSAwLjM3OTU1NEM2LjI5NTUzIDAuMzg4NTg4IDYuMjczODggMC40MDMyNjYgNi4yNDQxNyAwLjQyMjc4OUM2LjE4NDcxIDAuNDYxODYgNi4wOTMyMSAwLjUyMDE3MSA1Ljk3MzEzIDAuNTkxMzczQzUuNzMyNTEgMC43MzQwNTkgNS4zNzk5IDAuOTI2ODY0IDQuOTQyNzkgMS4xMjAwOUM0LjA2MTQ0IDEuNTA5NyAyLjg3NTQxIDEuODgzNzcgMS41ODk4NCAxLjg4Mzc3SDAuNzE0ODQ0VjIuNzU4NzdWNi45ODAxNUMwLjcxNDg0NCA5LjQ5Mzc0IDIuMjg4NjYgMTEuMTk3MyAzLjcwMjU0IDEyLjIxODVDNC40MTg0NSAxMi43MzU1IDUuMTI4NzQgMTMuMTA1MyA1LjY1NzMzIDEzLjM0NTdDNS45MjI4NCAxMy40NjY0IDYuMTQ1NjYgMTMuNTU1OSA2LjMwNDY1IDEzLjYxNjFDNi4zODQyMyAxMy42NDYyIDYuNDQ4MDUgMTMuNjY5IDYuNDkzNDkgMTMuNjg0OEM2LjUxNjIyIDEzLjY5MjcgNi41MzQzOCAxMy42OTg5IDYuNTQ3NjQgMTMuNzAzM0w2LjU2MzgyIDEzLjcwODdMNi41NjkwOCAxMy43MTA0TDYuNTcwOTkgMTMuNzExTDYuODM5ODQgMTMuNzUzM0w2LjU3MjQyIDEzLjcxMTVDNi43NDYzMyAxMy43NjczIDYuOTMzMzUgMTMuNzY3MyA3LjEwNzI3IDEzLjcxMTVMNy4xMDg3IDEzLjcxMUw3LjExMDYxIDEzLjcxMDRMNy4xMTU4NyAxMy43MDg3TDcuMTMyMDUgMTMuNzAzM0M3LjE0NTMxIDEzLjY5ODkgNy4xNjM0NiAxMy42OTI3IDcuMTg2MTkgMTMuNjg0OEM3LjIzMTY0IDEzLjY2OSA3LjI5NTQ2IDEzLjY0NjIgNy4zNzUwMyAxMy42MTYxQzcuNTM0MDMgMTMuNTU1OSA3Ljc1Njg1IDEzLjQ2NjQgOC4wMjIzNiAxMy4zNDU3QzguNTUwOTUgMTMuMTA1MyA5LjI2MTIzIDEyLjczNTUgOS45NzcxNSAxMi4yMTg1QzExLjM5MSAxMS4xOTczIDEyLjk2NDggOS40OTM3NyAxMi45NjQ4IDYuOTgwMThWMi43NTg4QzEyLjk2NDggMi43MTY2IDEyLjk2MTkgMi42NzUxMSAxMi45NTYxIDIuNjM0NTFWMS44ODM3N0gxMi4wODExQzEyLjA3NzUgMS44ODM3NyAxMi4wNzQgMS44ODM3NyAxMi4wNzA0IDEuODgzNzdDMTAuNzk3OSAxLjg4MDA0IDkuNjE5NjIgMS41MTEwMiA4LjczODk0IDEuMTI0ODZDOC43MzUzNCAxLjEyMzI3IDguNzMxNzQgMS4xMjE2OCA4LjcyODE0IDEuMTIwMDlDOC4yOTEwMyAwLjkyNjg2NCA3LjkzODQyIDAuNzM0MDU5IDcuNjk3NzkgMC41OTEzNzNDNy41Nzc3MiAwLjUyMDE3MSA3LjQ4NjIyIDAuNDYxODYgNy40MjY3NiAwLjQyMjc4OUM3LjM5NzA1IDAuNDAzMjY2IDcuMzc1MzkgMC4zODg1ODggNy4zNjIyNCAwLjM3OTU1NEw3LjM0ODk2IDAuMzcwMzVDNy4zNDg5NiAwLjM3MDM1IDcuMzQ4NDcgMC4zNzAwMiA3LjM0NTYzIDAuMzc0MDU0TDcuMzM3NzkgMC4zNjg2NTlMNy4zMzYwOSAwLjM2NzQ3NVpNOC4wMzQ3MSAyLjcyNjkxQzguODYwNCAzLjA5MDYzIDkuOTYwNjYgMy40NjMwOSAxMS4yMDYxIDMuNTg5MDdWNi45ODAxNUgxMS4yMTQ4QzExLjIxNDggOC42Nzk1MyAxMC4xNjM3IDkuOTI1MDcgOC45NTI1NCAxMC43OTk4QzguMzU1OTUgMTEuMjMwNiA3Ljc1Mzc0IDExLjU0NTQgNy4yOTc5NiAxMS43NTI3QzcuMTE2NzEgMTEuODM1MSA2Ljk2MDYyIDExLjg5OTYgNi44Mzk4NCAxMS45NDY5QzYuNzE5MDYgMTEuODk5NiA2LjU2Mjk3IDExLjgzNTEgNi4zODE3MyAxMS43NTI3QzUuOTI1OTUgMTEuNTQ1NCA1LjMyMzczIDExLjIzMDYgNC43MjcxNSAxMC43OTk4QzMuNTE2MDMgOS45MjUwNyAyLjQ2NDg0IDguNjc5NTUgMi40NjQ4NCA2Ljk4MDE4VjMuNTg5MDlDMy43MTczOCAzLjQ2MjM5IDQuODIzMDggMy4wODYzOSA1LjY1MDMzIDIuNzIwNzFDNi4xNDIyOCAyLjUwMzI0IDYuNTQ0ODUgMi4yODUzNyA2LjgzMjU0IDIuMTE2MjRDNy4xMjE4MSAyLjI4NTM1IDcuNTI3IDIuNTAzNTIgOC4wMjE5NiAyLjcyMTMxQzguMDI2MiAyLjcyMzE3IDguMDMwNDUgMi43MjUwNCA4LjAzNDcxIDIuNzI2OTFaTTUuOTY0ODQgMy40MDE0N1Y3Ljc3NjQ3SDcuNzE0ODRWMy40MDE0N0g1Ljk2NDg0Wk01Ljk2NDg0IDEwLjQwMTVWOC42NTE0N0g3LjcxNDg0VjEwLjQwMTVINS45NjQ4NFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_warning_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");
    background-color: darkorange;
}

.ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
}

.ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
}

.ace_scrollbar-v{
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
}

.ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
}

.ace_print-margin {
    position: absolute;
    height: 100%;
}

.ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre!important;
}
.ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
}
.ace_composition_placeholder { color: transparent }
.ace_composition_marker { 
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
}

[ace_nocontext=true] {
    transform: none!important;
    filter: none!important;
    clip-path: none!important;
    mask : none!important;
    contain: none!important;
    perspective: none!important;
    mix-blend-mode: initial!important;
    z-index: auto;
}

.ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
        during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
}

.ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
}

.ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
}

.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}

.ace_hidpi .ace_text-layer,
.ace_hidpi .ace_gutter-layer,
.ace_hidpi .ace_content,
.ace_hidpi .ace_gutter {
    contain: strict;
}
.ace_hidpi .ace_text-layer > .ace_line, 
.ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
}

.ace_cjk {
    display: inline-block;
    text-align: center;
}

.ace_cursor-layer {
    z-index: 4;
}

.ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
}

.ace_multiselect .ace_cursor {
    border-left-width: 1px;
}

.ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
}

.ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
}

.ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
}

.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
}

.ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
}

.ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
}

.ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
}
    
@keyframes blink-ace-animate {
    from, to { opacity: 1; }
    60% { opacity: 0; }
}

@keyframes blink-ace-animate-smooth {
    from, to { opacity: 1; }
    45% { opacity: 1; }
    60% { opacity: 0; }
    85% { opacity: 0; }
}

.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
}

.ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
}

.ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
}

.ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
}

.ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
}

.ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
}

.ace_line .ace_fold {
    box-sizing: border-box;

    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;

    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;

    border: 1px solid black;
    border-radius: 2px;

    cursor: pointer;
    pointer-events: auto;
}

.ace_dark .ace_fold {
}

.ace_fold:hover{
    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");
}

.ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    padding: 3px 4px;
    position: fixed;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
    overflow: auto;
    max-width: min(33em, 66vw);
    overscroll-behavior: contain;
}
.ace_tooltip pre {
    white-space: pre-wrap;
}

.ace_tooltip.ace_dark {
    background-color: #636363;
    color: #fff;
}

.ace_tooltip:focus {
    outline: 1px solid #5E9ED6;
}

.ace_icon {
    display: inline-block;
    width: 18px;
    vertical-align: top;
}

.ace_icon_svg {
    display: inline-block;
    width: 12px;
    vertical-align: top;
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-size: 12px;
    -webkit-mask-position: center;
}

.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {
    padding-right: 13px;
}

.ace_fold-widget, .ace_custom-widget {
    box-sizing: border-box;

    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;

    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: center;

    border-radius: 3px;
    
    border: 1px solid transparent;
    cursor: pointer;
}

.ace_custom-widget {
    background: none;
}

.ace_folding-enabled .ace_fold-widget {
    display: inline-block;   
}

.ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");
}

.ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");
}

.ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
}

.ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
}
/**
 * Dark version for fold widgets
 */
.ace_dark .ace_fold-widget {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");
}
.ace_dark .ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
}
.ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
}

.ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
}
.ace_inline_button:hover {
    border-color: gray;
    background: rgba(200,200,200,0.2);
    display: inline-block;
    pointer-events: auto;
}

.ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
}

.ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
}

.ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity:1;
}

.ace_underline {
    text-decoration: underline;
}

.ace_bold {
    font-weight: bold;
}

.ace_nobold .ace_bold {
    font-weight: normal;
}

.ace_italic {
    font-style: italic;
}


.ace_error-marker {
    background-color: rgba(255, 0, 0,0.2);
    position: absolute;
    z-index: 9;
}

.ace_highlight-marker {
    background-color: rgba(255, 255, 0,0.2);
    position: absolute;
    z-index: 8;
}

.ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
}
.ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;

}
.ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
}
.ace_mobile-button:hover {
    background-color: #eee;
    opacity:1;
}
.ace_mobile-button:active {
    background-color: #ddd;
}

.ace_placeholder {
    position: relative;
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
    z-index: 1;
}

.ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
}

.ace_ghost_text_container > div {
    white-space: pre;
}

.ghost_text_line_wrapped::after {
    content: "";
    position: absolute;
}

.ace_lineWidgetContainer.ace_ghost_text {
    margin: 0px 4px
}

.ace_screenreader-only {
    position:absolute;
    left:-10000px;
    top:auto;
    width:1px;
    height:1px;
    overflow:hidden;
}

.ace_hidden_token {
    display: none;
}`;
    });
    ace.define("ace/layer/decorators", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var oop = require2("../lib/oop");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var Decorator = (
        /** @class */
        function() {
          function Decorator2(parent, renderer) {
            this.parentEl = parent;
            this.canvas = dom.createElement("canvas");
            this.renderer = renderer;
            this.pixelRatio = 1;
            this.maxHeight = renderer.layerConfig.maxHeight;
            this.lineHeight = renderer.layerConfig.lineHeight;
            this.minDecorationHeight = 2 * this.pixelRatio | 0;
            this.halfMinDecorationHeight = this.minDecorationHeight / 2 | 0;
            this.canvas.style.top = "0px";
            this.canvas.style.right = "0px";
            this.canvas.style.zIndex = "7px";
            this.canvas.style.position = "absolute";
            this.colors = {};
            this.colors.dark = {
              "error": "rgba(255, 18, 18, 1)",
              "warning": "rgba(18, 136, 18, 1)",
              "info": "rgba(18, 18, 136, 1)"
            };
            this.colors.light = {
              "error": "rgb(255,51,51)",
              "warning": "rgb(32,133,72)",
              "info": "rgb(35,68,138)"
            };
            this.setDimensions();
            parent.element.appendChild(this.canvas);
          }
          Decorator2.prototype.$updateDecorators = function(config2) {
            var colors = this.renderer.theme.isDark === true ? this.colors.dark : this.colors.light;
            this.setDimensions(config2);
            var ctx = this.canvas.getContext("2d");
            function compare(a, b) {
              if (a.priority < b.priority)
                return -1;
              if (a.priority > b.priority)
                return 1;
              return 0;
            }
            var annotations = this.renderer.session.$annotations;
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (annotations) {
              var priorities = {
                "info": 1,
                "warning": 2,
                "error": 3
              };
              annotations.forEach(function(item) {
                item.priority = priorities[item.type] || null;
              });
              annotations = annotations.sort(compare);
              for (var i = 0; i < annotations.length; i++) {
                var row = annotations[i].row;
                var compensateFold = this.compensateFoldRows(row);
                var currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                var y1 = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                var y2 = Math.round(((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio);
                var height = y2 - y1;
                if (height < this.minDecorationHeight) {
                  var yCenter = (y1 + y2) / 2 | 0;
                  if (yCenter < this.halfMinDecorationHeight) {
                    yCenter = this.halfMinDecorationHeight;
                  } else if (yCenter + this.halfMinDecorationHeight > this.canvasHeight) {
                    yCenter = this.canvasHeight - this.halfMinDecorationHeight;
                  }
                  y1 = Math.round(yCenter - this.halfMinDecorationHeight);
                  y2 = Math.round(yCenter + this.halfMinDecorationHeight);
                }
                ctx.fillStyle = colors[annotations[i].type] || null;
                ctx.fillRect(0, currentY, this.canvasWidth, y2 - y1);
              }
            }
            var cursor = this.renderer.session.selection.getCursor();
            if (cursor) {
              var compensateFold = this.compensateFoldRows(cursor.row);
              var currentY = Math.round((cursor.row - compensateFold) * this.lineHeight * this.heightRatio);
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.fillRect(0, currentY, this.canvasWidth, 2);
            }
          };
          Decorator2.prototype.compensateFoldRows = function(row) {
            var foldData = this.renderer.session.$foldData;
            var compensateFold = 0;
            if (foldData && foldData.length > 0) {
              for (var j = 0; j < foldData.length; j++) {
                if (row > foldData[j].start.row && row < foldData[j].end.row) {
                  compensateFold += row - foldData[j].start.row;
                } else if (row >= foldData[j].end.row) {
                  compensateFold += foldData[j].end.row - foldData[j].start.row;
                }
              }
            }
            return compensateFold;
          };
          Decorator2.prototype.compensateLineWidgets = function(row) {
            var widgetManager = this.renderer.session.widgetManager;
            if (widgetManager) {
              var delta_1 = 0;
              widgetManager.lineWidgets.forEach(function(el, index) {
                if (row > index) {
                  delta_1 += el.rowCount || 0;
                }
              });
              return delta_1 - 1;
            }
            return 0;
          };
          Decorator2.prototype.setDimensions = function(config2) {
            if (config2) {
              this.maxHeight = config2.maxHeight;
              this.lineHeight = config2.lineHeight;
              this.canvasHeight = config2.height;
              if (this.maxHeight < this.canvasHeight) {
                this.heightRatio = 1;
              } else {
                this.heightRatio = this.canvasHeight / this.maxHeight;
              }
            } else {
              this.canvasHeight = this.parentEl.parent.scrollHeight || this.canvasHeight;
              this.canvasWidth = this.parentEl.width || this.canvasWidth;
              this.heightRatio = this.canvasHeight / this.maxHeight;
              this.canvas.width = this.canvasWidth;
              this.canvas.height = this.canvasHeight;
            }
          };
          return Decorator2;
        }()
      );
      oop.implement(Decorator.prototype, EventEmitter);
      exports2.Decorator = Decorator;
    });
    ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/config", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/scrollbar_custom", "ace/scrollbar_custom", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter", "ace/css/editor-css", "ace/layer/decorators", "ace/lib/useragent", "ace/layer/text_util"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var lang = require2("./lib/lang");
      var config2 = require2("./config");
      var GutterLayer = require2("./layer/gutter").Gutter;
      var MarkerLayer = require2("./layer/marker").Marker;
      var TextLayer = require2("./layer/text").Text;
      var CursorLayer = require2("./layer/cursor").Cursor;
      var HScrollBar = require2("./scrollbar").HScrollBar;
      var VScrollBar = require2("./scrollbar").VScrollBar;
      var HScrollBarCustom = require2("./scrollbar_custom").HScrollBar;
      var VScrollBarCustom = require2("./scrollbar_custom").VScrollBar;
      var RenderLoop = require2("./renderloop").RenderLoop;
      var FontMetrics = require2("./layer/font_metrics").FontMetrics;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var editorCss = require2("./css/editor-css");
      var Decorator = require2("./layer/decorators").Decorator;
      var useragent = require2("./lib/useragent");
      var isTextToken = require2("./layer/text_util").isTextToken;
      dom.importCssString(editorCss, "ace_editor.css", false);
      var VirtualRenderer = (
        /** @class */
        function() {
          function VirtualRenderer2(container, theme) {
            var _self = this;
            this.container = container || dom.createElement("div");
            dom.addCssClass(this.container, "ace_editor");
            if (dom.HI_DPI)
              dom.addCssClass(this.container, "ace_hidpi");
            this.setTheme(theme);
            if (config2.get("useStrictCSP") == null)
              config2.set("useStrictCSP", false);
            this.$gutter = dom.createElement("div");
            this.$gutter.className = "ace_gutter";
            this.container.appendChild(this.$gutter);
            this.$gutter.setAttribute("aria-hidden", "true");
            this.scroller = dom.createElement("div");
            this.scroller.className = "ace_scroller";
            this.container.appendChild(this.scroller);
            this.content = dom.createElement("div");
            this.content.className = "ace_content";
            this.scroller.appendChild(this.content);
            this.$gutterLayer = new GutterLayer(this.$gutter);
            this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
            this.$markerBack = new MarkerLayer(this.content);
            var textLayer = this.$textLayer = new TextLayer(this.content);
            this.canvas = textLayer.element;
            this.$markerFront = new MarkerLayer(this.content);
            this.$cursorLayer = new CursorLayer(this.content);
            this.$horizScroll = false;
            this.$vScroll = false;
            this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.on("scroll", function(e75) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e75.data - _self.scrollMargin.top);
            });
            this.scrollBarH.on("scroll", function(e75) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e75.data - _self.scrollMargin.left);
            });
            this.scrollTop = 0;
            this.scrollLeft = 0;
            this.cursorPos = {
              row: 0,
              column: 0
            };
            this.$fontMetrics = new FontMetrics(this.container);
            this.$textLayer.$setFontMetrics(this.$fontMetrics);
            this.$textLayer.on("changeCharacterSize", function(e75) {
              _self.updateCharacterSize();
              _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
              _self._signal("changeCharacterSize", e75);
            });
            this.$size = {
              width: 0,
              height: 0,
              scrollerHeight: 0,
              scrollerWidth: 0,
              $dirty: true
            };
            this.layerConfig = {
              width: 1,
              padding: 0,
              firstRow: 0,
              firstRowScreen: 0,
              lastRow: 0,
              lineHeight: 0,
              characterWidth: 0,
              minHeight: 1,
              maxHeight: 1,
              offset: 0,
              height: 1,
              gutterOffset: 1
            };
            this.scrollMargin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
            };
            this.margin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
            };
            this.$keepTextAreaAtCursor = !useragent.isIOS;
            this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
            this.$loop.schedule(this.CHANGE_FULL);
            this.updateCharacterSize();
            this.setPadding(4);
            this.$addResizeObserver();
            config2.resetOptions(this);
            config2._signal("renderer", this);
          }
          VirtualRenderer2.prototype.updateCharacterSize = function() {
            if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
              this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
              this.setStyle("ace_nobold", !this.$allowBoldFonts);
            }
            this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
            this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
            this.$updatePrintMargin();
            dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
          };
          VirtualRenderer2.prototype.setSession = function(session) {
            if (this.session)
              this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            this.session = session;
            if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
              session.setScrollTop(-this.scrollMargin.top);
            this.$cursorLayer.setSession(session);
            this.$markerBack.setSession(session);
            this.$markerFront.setSession(session);
            this.$gutterLayer.setSession(session);
            this.$textLayer.setSession(session);
            if (!session)
              return;
            this.$loop.schedule(this.CHANGE_FULL);
            this.session.$setFontMetrics(this.$fontMetrics);
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
            this.onChangeNewLineMode();
            this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
          };
          VirtualRenderer2.prototype.updateLines = function(firstRow, lastRow, force) {
            if (lastRow === void 0)
              lastRow = Infinity;
            if (!this.$changedLines) {
              this.$changedLines = {
                firstRow,
                lastRow
              };
            } else {
              if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;
              if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
            }
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
              if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
              else
                return;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow)
              return;
            this.$loop.schedule(this.CHANGE_LINES);
          };
          VirtualRenderer2.prototype.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
            this.$textLayer.$updateEolChar();
            this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
          };
          VirtualRenderer2.prototype.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
            this.$textLayer.onChangeTabSize();
          };
          VirtualRenderer2.prototype.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
          };
          VirtualRenderer2.prototype.updateFull = function(force) {
            if (force)
              this.$renderChanges(this.CHANGE_FULL, true);
            else
              this.$loop.schedule(this.CHANGE_FULL);
          };
          VirtualRenderer2.prototype.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
          };
          VirtualRenderer2.prototype.$updateSizeAsync = function() {
            if (this.$loop.pending)
              this.$size.$dirty = true;
            else
              this.onResize();
          };
          VirtualRenderer2.prototype.onResize = function(force, gutterWidth, width, height) {
            if (this.resizing > 2)
              return;
            else if (this.resizing > 0)
              this.resizing++;
            else
              this.resizing = force ? 1 : 0;
            var el = this.container;
            if (!height)
              height = el.clientHeight || el.scrollHeight;
            if (!height && this.$maxLines && this.lineHeight > 1) {
              if (!el.style.height || el.style.height == "0px") {
                el.style.height = "1px";
                height = el.clientHeight || el.scrollHeight;
              }
            }
            if (!width)
              width = el.clientWidth || el.scrollWidth;
            var changes = this.$updateCachedSize(force, gutterWidth, width, height);
            if (this.$resizeTimer)
              this.$resizeTimer.cancel();
            if (!this.$size.scrollerHeight || !width && !height)
              return this.resizing = 0;
            if (force)
              this.$gutterLayer.$padding = null;
            if (force)
              this.$renderChanges(changes | this.$changes, true);
            else
              this.$loop.schedule(changes | this.$changes);
            if (this.resizing)
              this.resizing = 0;
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            if (this.$customScrollbar) {
              this.$updateCustomScrollbar(true);
            }
          };
          VirtualRenderer2.prototype.$updateCachedSize = function(force, gutterWidth, width, height) {
            height -= this.$extraHeight || 0;
            var changes = 0;
            var size = this.$size;
            var oldSize = {
              width: size.width,
              height: size.height,
              scrollerHeight: size.scrollerHeight,
              scrollerWidth: size.scrollerWidth
            };
            if (height && (force || size.height != height)) {
              size.height = height;
              changes |= this.CHANGE_SIZE;
              size.scrollerHeight = size.height;
              if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
              this.scrollBarV.setHeight(size.scrollerHeight);
              this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
              changes = changes | this.CHANGE_SCROLL;
            }
            if (width && (force || size.width != width)) {
              changes |= this.CHANGE_SIZE;
              size.width = width;
              if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
              this.gutterWidth = gutterWidth;
              dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
              dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
              size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
              dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
              var right = this.scrollBarV.getWidth() + "px";
              dom.setStyle(this.scrollBarH.element.style, "right", right);
              dom.setStyle(this.scroller.style, "right", right);
              dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
              this.scrollBarH.setWidth(size.scrollerWidth);
              if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                changes |= this.CHANGE_FULL;
              }
            }
            size.$dirty = !width || !height;
            if (changes)
              this._signal("resize", oldSize);
            return changes;
          };
          VirtualRenderer2.prototype.onGutterResize = function(width) {
            var gutterWidth = this.$showGutter ? width : 0;
            if (gutterWidth != this.gutterWidth)
              this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
            if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else if (this.$size.$dirty) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else {
              this.$computeLayerConfig();
            }
          };
          VirtualRenderer2.prototype.adjustWrapLimit = function() {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit2 = Math.floor(availableWidth / this.characterWidth);
            return this.session.adjustWrapLimit(limit2, this.$showPrintMargin && this.$printMarginColumn);
          };
          VirtualRenderer2.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.setOption("animatedScroll", shouldAnimate);
          };
          VirtualRenderer2.prototype.getAnimatedScroll = function() {
            return this.$animatedScroll;
          };
          VirtualRenderer2.prototype.setShowInvisibles = function(showInvisibles) {
            this.setOption("showInvisibles", showInvisibles);
            this.session.$bidiHandler.setShowInvisibles(showInvisibles);
          };
          VirtualRenderer2.prototype.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
          };
          VirtualRenderer2.prototype.getDisplayIndentGuides = function() {
            return this.getOption("displayIndentGuides");
          };
          VirtualRenderer2.prototype.setDisplayIndentGuides = function(display) {
            this.setOption("displayIndentGuides", display);
          };
          VirtualRenderer2.prototype.getHighlightIndentGuides = function() {
            return this.getOption("highlightIndentGuides");
          };
          VirtualRenderer2.prototype.setHighlightIndentGuides = function(highlight) {
            this.setOption("highlightIndentGuides", highlight);
          };
          VirtualRenderer2.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.setOption("showPrintMargin", showPrintMargin);
          };
          VirtualRenderer2.prototype.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
          };
          VirtualRenderer2.prototype.setPrintMarginColumn = function(printMarginColumn) {
            this.setOption("printMarginColumn", printMarginColumn);
          };
          VirtualRenderer2.prototype.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
          };
          VirtualRenderer2.prototype.getShowGutter = function() {
            return this.getOption("showGutter");
          };
          VirtualRenderer2.prototype.setShowGutter = function(show) {
            return this.setOption("showGutter", show);
          };
          VirtualRenderer2.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          VirtualRenderer2.prototype.setFadeFoldWidgets = function(show) {
            this.setOption("fadeFoldWidgets", show);
          };
          VirtualRenderer2.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          VirtualRenderer2.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          VirtualRenderer2.prototype.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl)
              return;
            if (!this.$printMarginEl) {
              var containerEl = dom.createElement("div");
              containerEl.className = "ace_layer ace_print-margin-layer";
              this.$printMarginEl = dom.createElement("div");
              this.$printMarginEl.className = "ace_print-margin";
              containerEl.appendChild(this.$printMarginEl);
              this.content.insertBefore(containerEl, this.content.firstChild);
            }
            var style = this.$printMarginEl.style;
            style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
            style.visibility = this.$showPrintMargin ? "visible" : "hidden";
            if (this.session && this.session.$wrap == -1)
              this.adjustWrapLimit();
          };
          VirtualRenderer2.prototype.getContainerElement = function() {
            return this.container;
          };
          VirtualRenderer2.prototype.getMouseEventTarget = function() {
            return this.scroller;
          };
          VirtualRenderer2.prototype.getTextAreaContainer = function() {
            return this.container;
          };
          VirtualRenderer2.prototype.$moveTextAreaToCursor = function() {
            if (this.$isMousePressed)
              return;
            var style = this.textarea.style;
            var composition = this.$composition;
            if (!this.$keepTextAreaAtCursor && !composition) {
              dom.translate(this.textarea, -100, 0);
              return;
            }
            var pixelPos = this.$cursorLayer.$pixelPos;
            if (!pixelPos)
              return;
            if (composition && composition.markerRange)
              pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
            var config3 = this.layerConfig;
            var posTop = pixelPos.top;
            var posLeft = pixelPos.left;
            posTop -= config3.offset;
            var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
            if (posTop < 0 || posTop > config3.height - h) {
              dom.translate(this.textarea, 0, 0);
              return;
            }
            var w = 1;
            var maxTop = this.$size.height - h;
            if (!composition) {
              posTop += this.lineHeight;
            } else {
              if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w = this.characterWidth * this.session.$getStringScreenWidth(val)[0];
              } else {
                posTop += this.lineHeight + 2;
              }
            }
            posLeft -= this.scrollLeft;
            if (posLeft > this.$size.scrollerWidth - w)
              posLeft = this.$size.scrollerWidth - w;
            posLeft += this.gutterWidth + this.margin.left;
            dom.setStyle(style, "height", h + "px");
            dom.setStyle(style, "width", w + "px");
            dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
          };
          VirtualRenderer2.prototype.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
          };
          VirtualRenderer2.prototype.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
          };
          VirtualRenderer2.prototype.getLastFullyVisibleRow = function() {
            var config3 = this.layerConfig;
            var lastRow = config3.lastRow;
            var top = this.session.documentToScreenRow(lastRow, 0) * config3.lineHeight;
            if (top - this.session.getScrollTop() > config3.height - config3.lineHeight)
              return lastRow - 1;
            return lastRow;
          };
          VirtualRenderer2.prototype.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
          };
          VirtualRenderer2.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.$textLayer.setPadding(padding);
            this.$cursorLayer.setPadding(padding);
            this.$markerFront.setPadding(padding);
            this.$markerBack.setPadding(padding);
            this.$loop.schedule(this.CHANGE_FULL);
            this.$updatePrintMargin();
          };
          VirtualRenderer2.prototype.setScrollMargin = function(top, bottom, left, right) {
            var sm = this.scrollMargin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            if (sm.top && this.scrollTop <= 0 && this.session)
              this.session.setScrollTop(-sm.top);
            this.updateFull();
          };
          VirtualRenderer2.prototype.setMargin = function(top, bottom, left, right) {
            var sm = this.margin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
            this.updateFull();
          };
          VirtualRenderer2.prototype.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
          };
          VirtualRenderer2.prototype.setHScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
          };
          VirtualRenderer2.prototype.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
          };
          VirtualRenderer2.prototype.setVScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
          };
          VirtualRenderer2.prototype.$updateScrollBarV = function() {
            var scrollHeight = this.layerConfig.maxHeight;
            var scrollerHeight = this.$size.scrollerHeight;
            if (!this.$maxLines && this.$scrollPastEnd) {
              scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
              if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
              }
            }
            this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
            this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
          };
          VirtualRenderer2.prototype.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
            this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
          };
          VirtualRenderer2.prototype.freeze = function() {
            this.$frozen = true;
          };
          VirtualRenderer2.prototype.unfreeze = function() {
            this.$frozen = false;
          };
          VirtualRenderer2.prototype.$renderChanges = function(changes, force) {
            if (this.$changes) {
              changes |= this.$changes;
              this.$changes = 0;
            }
            if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
              this.$changes |= changes;
              return;
            }
            if (this.$size.$dirty) {
              this.$changes |= changes;
              return this.onResize(true);
            }
            if (!this.lineHeight) {
              this.$textLayer.checkForSizeChanges();
            }
            this._signal("beforeRender", changes);
            if (this.session && this.session.$bidiHandler)
              this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
            var config3 = this.layerConfig;
            if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
              changes |= this.$computeLayerConfig() | this.$loop.clear();
              if (config3.firstRow != this.layerConfig.firstRow && config3.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config3.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
                if (st > 0) {
                  this.scrollTop = st;
                  changes = changes | this.CHANGE_SCROLL;
                  changes |= this.$computeLayerConfig() | this.$loop.clear();
                }
              }
              config3 = this.layerConfig;
              this.$updateScrollBarV();
              if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
              dom.translate(this.content, -this.scrollLeft, -config3.offset);
              var width = config3.width + 2 * this.$padding + "px";
              var height = config3.minHeight + "px";
              dom.setStyle(this.content.style, "width", width);
              dom.setStyle(this.content.style, "height", height);
            }
            if (changes & this.CHANGE_H_SCROLL) {
              dom.translate(this.content, -this.scrollLeft, -config3.offset);
              this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ";
              if (this.enableKeyboardAccessibility)
                this.scroller.className += this.keyboardFocusClassName;
            }
            if (changes & this.CHANGE_FULL) {
              this.$changedLines = null;
              this.$textLayer.update(config3);
              if (this.$showGutter)
                this.$gutterLayer.update(config3);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config3);
              }
              this.$markerBack.update(config3);
              this.$markerFront.update(config3);
              this.$cursorLayer.update(config3);
              this.$moveTextAreaToCursor();
              this._signal("afterRender", changes);
              return;
            }
            if (changes & this.CHANGE_SCROLL) {
              this.$changedLines = null;
              if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config3);
              else
                this.$textLayer.scrollLines(config3);
              if (this.$showGutter) {
                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                  this.$gutterLayer.update(config3);
                else
                  this.$gutterLayer.scrollLines(config3);
              }
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config3);
              }
              this.$markerBack.update(config3);
              this.$markerFront.update(config3);
              this.$cursorLayer.update(config3);
              this.$moveTextAreaToCursor();
              this._signal("afterRender", changes);
              return;
            }
            if (changes & this.CHANGE_TEXT) {
              this.$changedLines = null;
              this.$textLayer.update(config3);
              if (this.$showGutter)
                this.$gutterLayer.update(config3);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config3);
              }
            } else if (changes & this.CHANGE_LINES) {
              if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter)
                this.$gutterLayer.update(config3);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config3);
              }
            } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
              if (this.$showGutter)
                this.$gutterLayer.update(config3);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config3);
              }
            } else if (changes & this.CHANGE_CURSOR) {
              if (this.$highlightGutterLine)
                this.$gutterLayer.updateLineHighlight(config3);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config3);
              }
            }
            if (changes & this.CHANGE_CURSOR) {
              this.$cursorLayer.update(config3);
              this.$moveTextAreaToCursor();
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
              this.$markerFront.update(config3);
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
              this.$markerBack.update(config3);
            }
            this._signal("afterRender", changes);
          };
          VirtualRenderer2.prototype.$autosize = function() {
            var height = this.session.getScreenLength() * this.lineHeight;
            var maxHeight = this.$maxLines * this.lineHeight;
            var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
            if (this.$horizScroll)
              desiredHeight += this.scrollBarH.getHeight();
            if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
              desiredHeight = this.$maxPixelHeight;
            var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
            var vScroll = !hideScrollbars && height > maxHeight;
            if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
              if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
              }
              var w = this.container.clientWidth;
              this.container.style.height = desiredHeight + "px";
              this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
              this.desiredHeight = desiredHeight;
              this._signal("autosize");
            }
          };
          VirtualRenderer2.prototype.$computeLayerConfig = function() {
            var session = this.session;
            var size = this.$size;
            var hideScrollbars = size.height <= 2 * this.lineHeight;
            var screenLines = this.session.getScreenLength();
            var maxHeight = screenLines * this.lineHeight;
            var longestLine = this.$getLongestLine();
            var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
            var hScrollChanged = this.$horizScroll !== horizScroll;
            if (hScrollChanged) {
              this.$horizScroll = horizScroll;
              this.scrollBarH.setVisible(horizScroll);
            }
            var vScrollBefore = this.$vScroll;
            if (this.$maxLines && this.lineHeight > 1) {
              this.$autosize();
              hideScrollbars = size.height <= 2 * this.lineHeight;
            }
            var minHeight = size.scrollerHeight + this.lineHeight;
            var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
            maxHeight += scrollPastEnd;
            var sm = this.scrollMargin;
            this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
            this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
            var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
            var vScrollChanged = vScrollBefore !== vScroll;
            if (vScrollChanged) {
              this.$vScroll = vScroll;
              this.scrollBarV.setVisible(vScroll);
            }
            var offset = this.scrollTop % this.lineHeight;
            var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
            var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
            var lastRow = firstRow + lineCount;
            var firstRowScreen, firstRowHeight;
            var lineHeight = this.lineHeight;
            firstRow = session.screenToDocumentRow(firstRow, 0);
            var foldLine = session.getFoldLine(firstRow);
            if (foldLine) {
              firstRow = foldLine.start.row;
            }
            firstRowScreen = session.documentToScreenRow(firstRow, 0);
            firstRowHeight = session.getRowLength(firstRow) * lineHeight;
            lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
            minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
            offset = this.scrollTop - firstRowScreen * lineHeight;
            var changes = 0;
            if (this.layerConfig.width != longestLine || hScrollChanged)
              changes = this.CHANGE_H_SCROLL;
            if (hScrollChanged || vScrollChanged) {
              changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
              this._signal("scrollbarVisibilityChanged");
              if (vScrollChanged)
                longestLine = this.$getLongestLine();
            }
            this.layerConfig = {
              width: longestLine,
              padding: this.$padding,
              firstRow,
              firstRowScreen,
              lastRow,
              lineHeight,
              characterWidth: this.characterWidth,
              minHeight,
              maxHeight,
              offset,
              gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
              height: this.$size.scrollerHeight
            };
            if (this.session.$bidiHandler)
              this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
            return changes;
          };
          VirtualRenderer2.prototype.$updateLines = function() {
            if (!this.$changedLines)
              return;
            var firstRow = this.$changedLines.firstRow;
            var lastRow = this.$changedLines.lastRow;
            this.$changedLines = null;
            var layerConfig = this.layerConfig;
            if (firstRow > layerConfig.lastRow + 1) {
              return;
            }
            if (lastRow < layerConfig.firstRow) {
              return;
            }
            if (lastRow === Infinity) {
              if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
              this.$textLayer.update(layerConfig);
              return;
            }
            this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
            return true;
          };
          VirtualRenderer2.prototype.$getLongestLine = function() {
            var charCount = this.session.getScreenWidth();
            if (this.showInvisibles && !this.session.$useWrapMode)
              charCount += 1;
            if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
              charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
            return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
          };
          VirtualRenderer2.prototype.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(true));
            this.$loop.schedule(this.CHANGE_MARKER_FRONT);
          };
          VirtualRenderer2.prototype.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers());
            this.$loop.schedule(this.CHANGE_MARKER_BACK);
          };
          VirtualRenderer2.prototype.addGutterDecoration = function(row, className) {
            this.$gutterLayer.addGutterDecoration(row, className);
          };
          VirtualRenderer2.prototype.removeGutterDecoration = function(row, className) {
            this.$gutterLayer.removeGutterDecoration(row, className);
          };
          VirtualRenderer2.prototype.updateBreakpoints = function(rows) {
            this._rows = rows;
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          VirtualRenderer2.prototype.setAnnotations = function(annotations) {
            this.$gutterLayer.setAnnotations(annotations);
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          VirtualRenderer2.prototype.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
          };
          VirtualRenderer2.prototype.hideCursor = function() {
            this.$cursorLayer.hideCursor();
          };
          VirtualRenderer2.prototype.showCursor = function() {
            this.$cursorLayer.showCursor();
          };
          VirtualRenderer2.prototype.scrollSelectionIntoView = function(anchor, lead, offset) {
            this.scrollCursorIntoView(anchor, offset);
            this.scrollCursorIntoView(lead, offset);
          };
          VirtualRenderer2.prototype.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
            if (this.$size.scrollerHeight === 0)
              return;
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var newLeft = pos.left;
            var newTop = pos.top;
            var topMargin = $viewMargin && $viewMargin.top || 0;
            var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
            if (this.$scrollAnimation) {
              this.$stopAnimation = true;
            }
            var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            if (currentTop + topMargin > newTop) {
              if (offset && currentTop + topMargin > newTop + this.lineHeight)
                newTop -= offset * this.$size.scrollerHeight;
              if (newTop === 0)
                newTop = -this.scrollMargin.top;
              this.session.setScrollTop(newTop);
            } else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
              if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight)
                newTop += offset * this.$size.scrollerHeight;
              this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
            }
            var currentLeft = this.scrollLeft;
            var twoCharsWidth = 2 * this.layerConfig.characterWidth;
            if (newLeft - twoCharsWidth < currentLeft) {
              newLeft -= twoCharsWidth;
              if (newLeft < this.$padding + twoCharsWidth) {
                newLeft = -this.scrollMargin.left;
              }
              this.session.setScrollLeft(newLeft);
            } else {
              newLeft += twoCharsWidth;
              if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
              } else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
                this.session.setScrollLeft(0);
              }
            }
          };
          VirtualRenderer2.prototype.getScrollTop = function() {
            return this.session.getScrollTop();
          };
          VirtualRenderer2.prototype.getScrollLeft = function() {
            return this.session.getScrollLeft();
          };
          VirtualRenderer2.prototype.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
          };
          VirtualRenderer2.prototype.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
          };
          VirtualRenderer2.prototype.scrollToRow = function(row) {
            this.session.setScrollTop(row * this.lineHeight);
          };
          VirtualRenderer2.prototype.alignCursor = function(cursor, alignment) {
            if (typeof cursor == "number")
              cursor = { row: cursor, column: 0 };
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var h = this.$size.scrollerHeight - this.lineHeight;
            var offset = pos.top - h * (alignment || 0);
            this.session.setScrollTop(offset);
            return offset;
          };
          VirtualRenderer2.prototype.$calcSteps = function(fromValue, toValue) {
            var i = 0;
            var l = this.STEPS;
            var steps = [];
            var func = function(t2, x_min, dx) {
              return dx * (Math.pow(t2 - 1, 3) + 1) + x_min;
            };
            for (i = 0; i < l; ++i)
              steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
            return steps;
          };
          VirtualRenderer2.prototype.scrollToLine = function(line, center, animate, callback) {
            var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
            var offset = pos.top;
            if (center)
              offset -= this.$size.scrollerHeight / 2;
            var initialScroll = this.scrollTop;
            this.session.setScrollTop(offset);
            if (animate !== false)
              this.animateScrolling(initialScroll, callback);
          };
          VirtualRenderer2.prototype.animateScrolling = function(fromValue, callback) {
            var toValue = this.scrollTop;
            if (!this.$animatedScroll)
              return;
            var _self = this;
            if (fromValue == toValue)
              return;
            if (this.$scrollAnimation) {
              var oldSteps = this.$scrollAnimation.steps;
              if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                  return;
              }
            }
            var steps = _self.$calcSteps(fromValue, toValue);
            this.$scrollAnimation = { from: fromValue, to: toValue, steps };
            clearInterval(this.$timer);
            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
            function endAnimation() {
              _self.$timer = clearInterval(_self.$timer);
              _self.$scrollAnimation = null;
              _self.$stopAnimation = false;
              callback && callback();
            }
            this.$timer = setInterval(function() {
              if (_self.$stopAnimation) {
                endAnimation();
                return;
              }
              if (!_self.session)
                return clearInterval(_self.$timer);
              if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
              } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
              } else {
                endAnimation();
              }
            }, 10);
          };
          VirtualRenderer2.prototype.scrollToY = function(scrollTop) {
            if (this.scrollTop !== scrollTop) {
              this.$loop.schedule(this.CHANGE_SCROLL);
              this.scrollTop = scrollTop;
            }
          };
          VirtualRenderer2.prototype.scrollToX = function(scrollLeft) {
            if (this.scrollLeft !== scrollLeft)
              this.scrollLeft = scrollLeft;
            this.$loop.schedule(this.CHANGE_H_SCROLL);
          };
          VirtualRenderer2.prototype.scrollTo = function(x, y) {
            this.session.setScrollTop(y);
            this.session.setScrollLeft(x);
          };
          VirtualRenderer2.prototype.scrollBy = function(deltaX, deltaY) {
            deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
            deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
          };
          VirtualRenderer2.prototype.isScrollableBy = function(deltaX, deltaY) {
            if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
              return true;
            if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
              return true;
            if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
              return true;
            if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
              return true;
          };
          VirtualRenderer2.prototype.pixelToScreenCoordinates = function(x, y) {
            var canvasPos;
            if (this.$hasCssTransforms) {
              canvasPos = { top: 0, left: 0 };
              var p = this.$fontMetrics.transformCoordinates([x, y]);
              x = p[1] - this.gutterWidth - this.margin.left;
              y = p[0];
            } else {
              canvasPos = this.scroller.getBoundingClientRect();
            }
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            return { row, column: col, side: offset - col > 0 ? 1 : -1, offsetX };
          };
          VirtualRenderer2.prototype.screenToTextCoordinates = function(x, y) {
            var canvasPos;
            if (this.$hasCssTransforms) {
              canvasPos = { top: 0, left: 0 };
              var p = this.$fontMetrics.transformCoordinates([x, y]);
              x = p[1] - this.gutterWidth - this.margin.left;
              y = p[0];
            } else {
              canvasPos = this.scroller.getBoundingClientRect();
            }
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
            return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
          };
          VirtualRenderer2.prototype.textToScreenCoordinates = function(row, column) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var pos = this.session.documentToScreenPosition(row, column);
            var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
            var y = pos.row * this.lineHeight;
            return {
              pageX: canvasPos.left + x - this.scrollLeft,
              pageY: canvasPos.top + y - this.scrollTop
            };
          };
          VirtualRenderer2.prototype.visualizeFocus = function() {
            dom.addCssClass(this.container, "ace_focus");
          };
          VirtualRenderer2.prototype.visualizeBlur = function() {
            dom.removeCssClass(this.container, "ace_focus");
          };
          VirtualRenderer2.prototype.showComposition = function(composition) {
            this.$composition = composition;
            if (!composition.cssText) {
              composition.cssText = this.textarea.style.cssText;
            }
            if (composition.useTextareaForIME == void 0)
              composition.useTextareaForIME = this.$useTextareaForIME;
            if (this.$useTextareaForIME) {
              dom.addCssClass(this.textarea, "ace_composition");
              this.textarea.style.cssText = "";
              this.$moveTextAreaToCursor();
              this.$cursorLayer.element.style.display = "none";
            } else {
              composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
            }
          };
          VirtualRenderer2.prototype.setCompositionText = function(text) {
            var cursor = this.session.selection.cursor;
            this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
            this.$moveTextAreaToCursor();
          };
          VirtualRenderer2.prototype.hideComposition = function() {
            if (!this.$composition)
              return;
            if (this.$composition.markerId)
              this.session.removeMarker(this.$composition.markerId);
            dom.removeCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = this.$composition.cssText;
            var cursor = this.session.selection.cursor;
            this.removeExtraToken(cursor.row, cursor.column);
            this.$composition = null;
            this.$cursorLayer.element.style.display = "";
          };
          VirtualRenderer2.prototype.setGhostText = function(text, position2) {
            var cursor = this.session.selection.cursor;
            var insertPosition = position2 || { row: cursor.row, column: cursor.column };
            this.removeGhostText();
            var textChunks = this.$calculateWrappedTextChunks(text, insertPosition);
            this.addToken(textChunks[0].text, "ghost_text", insertPosition.row, insertPosition.column);
            this.$ghostText = {
              text,
              position: {
                row: insertPosition.row,
                column: insertPosition.column
              }
            };
            var widgetDiv = dom.createElement("div");
            if (textChunks.length > 1) {
              var hiddenTokens = this.hideTokensAfterPosition(insertPosition.row, insertPosition.column);
              var lastLineDiv;
              textChunks.slice(1).forEach(function(el2) {
                var chunkDiv = dom.createElement("div");
                var chunkSpan = dom.createElement("span");
                chunkSpan.className = "ace_ghost_text";
                if (el2.wrapped)
                  chunkDiv.className = "ghost_text_line_wrapped";
                if (el2.text.length === 0)
                  el2.text = " ";
                chunkSpan.appendChild(dom.createTextNode(el2.text));
                chunkDiv.appendChild(chunkSpan);
                widgetDiv.appendChild(chunkDiv);
                lastLineDiv = chunkDiv;
              });
              hiddenTokens.forEach(function(token) {
                var element = dom.createElement("span");
                if (!isTextToken(token.type))
                  element.className = "ace_" + token.type.replace(/\./g, " ace_");
                element.appendChild(dom.createTextNode(token.value));
                lastLineDiv.appendChild(element);
              });
              this.$ghostTextWidget = {
                el: widgetDiv,
                row: insertPosition.row,
                column: insertPosition.column,
                className: "ace_ghost_text_container"
              };
              this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
              var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);
              var el = this.container;
              var height = el.getBoundingClientRect().height;
              var ghostTextHeight = textChunks.length * this.lineHeight;
              var fitsY = ghostTextHeight < height - pixelPosition.top;
              if (fitsY)
                return;
              if (ghostTextHeight < height) {
                this.scrollBy(0, (textChunks.length - 1) * this.lineHeight);
              } else {
                this.scrollToRow(insertPosition.row);
              }
            }
          };
          VirtualRenderer2.prototype.$calculateWrappedTextChunks = function(text, position2) {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit2 = Math.floor(availableWidth / this.characterWidth) - 2;
            limit2 = limit2 <= 0 ? 60 : limit2;
            var textLines = text.split(/\r?\n/);
            var textChunks = [];
            for (var i = 0; i < textLines.length; i++) {
              var displayTokens = this.session.$getDisplayTokens(textLines[i], position2.column);
              var wrapSplits = this.session.$computeWrapSplits(displayTokens, limit2, this.session.$tabSize);
              if (wrapSplits.length > 0) {
                var start = 0;
                wrapSplits.push(textLines[i].length);
                for (var j = 0; j < wrapSplits.length; j++) {
                  var textSlice = textLines[i].slice(start, wrapSplits[j]);
                  textChunks.push({ text: textSlice, wrapped: true });
                  start = wrapSplits[j];
                }
              } else {
                textChunks.push({ text: textLines[i], wrapped: false });
              }
            }
            return textChunks;
          };
          VirtualRenderer2.prototype.removeGhostText = function() {
            if (!this.$ghostText)
              return;
            var position2 = this.$ghostText.position;
            this.removeExtraToken(position2.row, position2.column);
            if (this.$ghostTextWidget) {
              this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
              this.$ghostTextWidget = null;
            }
            this.$ghostText = null;
          };
          VirtualRenderer2.prototype.addToken = function(text, type2, row, column) {
            var session = this.session;
            session.bgTokenizer.lines[row] = null;
            var newToken = { type: type2, value: text };
            var tokens2 = session.getTokens(row);
            if (column == null || !tokens2.length) {
              tokens2.push(newToken);
            } else {
              var l = 0;
              for (var i = 0; i < tokens2.length; i++) {
                var token = tokens2[i];
                l += token.value.length;
                if (column <= l) {
                  var diff = token.value.length - (l - column);
                  var before = token.value.slice(0, diff);
                  var after = token.value.slice(diff);
                  tokens2.splice(i, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });
                  break;
                }
              }
            }
            this.updateLines(row, row);
          };
          VirtualRenderer2.prototype.hideTokensAfterPosition = function(row, column) {
            var tokens2 = this.session.getTokens(row);
            var l = 0;
            var hasPassedCursor = false;
            var hiddenTokens = [];
            for (var i = 0; i < tokens2.length; i++) {
              var token = tokens2[i];
              l += token.value.length;
              if (token.type === "ghost_text")
                continue;
              if (hasPassedCursor) {
                hiddenTokens.push({ type: token.type, value: token.value });
                token.type = "hidden_token";
                continue;
              }
              if (l === column) {
                hasPassedCursor = true;
              }
            }
            this.updateLines(row, row);
            return hiddenTokens;
          };
          VirtualRenderer2.prototype.removeExtraToken = function(row, column) {
            this.session.bgTokenizer.lines[row] = null;
            this.updateLines(row, row);
          };
          VirtualRenderer2.prototype.setTheme = function(theme, cb) {
            var _self = this;
            this.$themeId = theme;
            _self._dispatchEvent("themeChange", { theme });
            if (!theme || typeof theme == "string") {
              var moduleName = theme || this.$options.theme.initialValue;
              config2.loadModule(["theme", moduleName], afterLoad);
            } else {
              afterLoad(theme);
            }
            function afterLoad(module3) {
              if (_self.$themeId != theme)
                return cb && cb();
              if (!module3 || !module3.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
              if (module3.$id)
                _self.$themeId = module3.$id;
              dom.importCssString(module3.cssText, module3.cssClass, _self.container);
              if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);
              var padding = "padding" in module3 ? module3.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
              if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
              _self.$theme = module3.cssClass;
              _self.theme = module3;
              dom.addCssClass(_self.container, module3.cssClass);
              dom.setCssClass(_self.container, "ace_dark", module3.isDark);
              if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
              }
              _self._dispatchEvent("themeLoaded", { theme: module3 });
              cb && cb();
              if (useragent.isSafari && _self.scroller) {
                _self.scroller.style.background = "red";
                _self.scroller.style.background = "";
              }
            }
          };
          VirtualRenderer2.prototype.getTheme = function() {
            return this.$themeId;
          };
          VirtualRenderer2.prototype.setStyle = function(style, include) {
            dom.setCssClass(this.container, style, include !== false);
          };
          VirtualRenderer2.prototype.unsetStyle = function(style) {
            dom.removeCssClass(this.container, style);
          };
          VirtualRenderer2.prototype.setCursorStyle = function(style) {
            dom.setStyle(this.scroller.style, "cursor", style);
          };
          VirtualRenderer2.prototype.setMouseCursor = function(cursorStyle) {
            dom.setStyle(this.scroller.style, "cursor", cursorStyle);
          };
          VirtualRenderer2.prototype.attachToShadowRoot = function() {
            dom.importCssString(editorCss, "ace_editor.css", this.container);
          };
          VirtualRenderer2.prototype.destroy = function() {
            this.freeze();
            this.$fontMetrics.destroy();
            this.$cursorLayer.destroy();
            this.removeAllListeners();
            this.container.textContent = "";
            this.setOption("useResizeObserver", false);
          };
          VirtualRenderer2.prototype.$updateCustomScrollbar = function(val) {
            var _self = this;
            this.$horizScroll = this.$vScroll = null;
            this.scrollBarV.element.remove();
            this.scrollBarH.element.remove();
            if (this.$scrollDecorator) {
              delete this.$scrollDecorator;
            }
            if (val === true) {
              this.scrollBarV = new VScrollBarCustom(this.container, this);
              this.scrollBarH = new HScrollBarCustom(this.container, this);
              this.scrollBarV.setHeight(this.$size.scrollerHeight);
              this.scrollBarH.setWidth(this.$size.scrollerWidth);
              this.scrollBarV.addEventListener("scroll", function(e75) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e75.data - _self.scrollMargin.top);
              });
              this.scrollBarH.addEventListener("scroll", function(e75) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e75.data - _self.scrollMargin.left);
              });
              this.$scrollDecorator = new Decorator(this.scrollBarV, this);
              this.$scrollDecorator.$updateDecorators();
            } else {
              this.scrollBarV = new VScrollBar(this.container, this);
              this.scrollBarH = new HScrollBar(this.container, this);
              this.scrollBarV.addEventListener("scroll", function(e75) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e75.data - _self.scrollMargin.top);
              });
              this.scrollBarH.addEventListener("scroll", function(e75) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e75.data - _self.scrollMargin.left);
              });
            }
          };
          VirtualRenderer2.prototype.$addResizeObserver = function() {
            if (!window.ResizeObserver || this.$resizeObserver)
              return;
            var self2 = this;
            this.$resizeTimer = lang.delayedCall(function() {
              if (!self2.destroyed)
                self2.onResize();
            }, 50);
            this.$resizeObserver = new window.ResizeObserver(function(e75) {
              var w = e75[0].contentRect.width;
              var h = e75[0].contentRect.height;
              if (Math.abs(self2.$size.width - w) > 1 || Math.abs(self2.$size.height - h) > 1) {
                self2.$resizeTimer.delay();
              } else {
                self2.$resizeTimer.cancel();
              }
            });
            this.$resizeObserver.observe(this.container);
          };
          return VirtualRenderer2;
        }()
      );
      VirtualRenderer.prototype.CHANGE_CURSOR = 1;
      VirtualRenderer.prototype.CHANGE_MARKER = 2;
      VirtualRenderer.prototype.CHANGE_GUTTER = 4;
      VirtualRenderer.prototype.CHANGE_SCROLL = 8;
      VirtualRenderer.prototype.CHANGE_LINES = 16;
      VirtualRenderer.prototype.CHANGE_TEXT = 32;
      VirtualRenderer.prototype.CHANGE_SIZE = 64;
      VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
      VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
      VirtualRenderer.prototype.CHANGE_FULL = 512;
      VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
      VirtualRenderer.prototype.$changes = 0;
      VirtualRenderer.prototype.$padding = null;
      VirtualRenderer.prototype.$frozen = false;
      VirtualRenderer.prototype.STEPS = 8;
      oop.implement(VirtualRenderer.prototype, EventEmitter);
      config2.defineOptions(VirtualRenderer.prototype, "renderer", {
        useResizeObserver: {
          set: function(value) {
            if (!value && this.$resizeObserver) {
              this.$resizeObserver.disconnect();
              this.$resizeTimer.cancel();
              this.$resizeTimer = this.$resizeObserver = null;
            } else if (value && !this.$resizeObserver) {
              this.$addResizeObserver();
            }
          }
        },
        animatedScroll: { initialValue: false },
        showInvisibles: {
          set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: false
        },
        showPrintMargin: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: true
        },
        printMarginColumn: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: 80
        },
        printMargin: {
          set: function(val) {
            if (typeof val == "number")
              this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
          },
          get: function() {
            return this.$showPrintMargin && this.$printMarginColumn;
          }
        },
        showGutter: {
          set: function(show) {
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
          },
          initialValue: true
        },
        useSvgGutterIcons: {
          set: function(value) {
            this.$gutterLayer.$useSvgGutterIcons = value;
          },
          initialValue: false
        },
        showFoldedAnnotations: {
          set: function(value) {
            this.$gutterLayer.$showFoldedAnnotations = value;
          },
          initialValue: false
        },
        fadeFoldWidgets: {
          set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
          },
          initialValue: false
        },
        showFoldWidgets: {
          set: function(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        displayIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: true
        },
        highlightIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
              this.$textLayer.$highlightIndentGuide();
            } else {
              this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            }
          },
          initialValue: true
        },
        highlightGutterLine: {
          set: function(shouldHighlight) {
            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        hScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        vScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        fontSize: {
          set: function(size) {
            if (typeof size == "number")
              size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
          },
          initialValue: 12
        },
        fontFamily: {
          set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
          }
        },
        maxLines: {
          set: function(val) {
            this.updateFull();
          }
        },
        minLines: {
          set: function(val) {
            if (!(this.$minLines < 562949953421311))
              this.$minLines = 0;
            this.updateFull();
          }
        },
        maxPixelHeight: {
          set: function(val) {
            this.updateFull();
          },
          initialValue: 0
        },
        scrollPastEnd: {
          set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
              return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: 0,
          handlesSet: true
        },
        fixedWidthGutter: {
          set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
          }
        },
        customScrollbar: {
          set: function(val) {
            this.$updateCustomScrollbar(val);
          },
          initialValue: false
        },
        theme: {
          set: function(val) {
            this.setTheme(val);
          },
          get: function() {
            return this.$themeId || this.theme;
          },
          initialValue: "./theme/textmate",
          handlesSet: true
        },
        hasCssTransforms: {},
        useTextareaForIME: {
          initialValue: !useragent.isMobile && !useragent.isIE
        }
      });
      exports2.VirtualRenderer = VirtualRenderer;
    });
    ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      var oop = require2("../lib/oop");
      var net = require2("../lib/net");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var config2 = require2("../config");
      function $workerBlob(workerUrl) {
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
          return new Blob([script], { "type": "application/javascript" });
        } catch (e75) {
          var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
          var blobBuilder = new BlobBuilder();
          blobBuilder.append(script);
          return blobBuilder.getBlob("application/javascript");
        }
      }
      function createWorker(workerUrl) {
        if (typeof Worker == "undefined")
          return { postMessage: function() {
          }, terminate: function() {
          } };
        if (config2.get("loadWorkerFromBlob")) {
          var blob = $workerBlob(workerUrl);
          var URL2 = window.URL || window.webkitURL;
          var blobURL = URL2.createObjectURL(blob);
          return new Worker(blobURL);
        }
        return new Worker(workerUrl);
      }
      var WorkerClient = function(worker) {
        if (!worker.postMessage)
          worker = this.$createWorkerFromOldConfig.apply(this, arguments);
        this.$worker = worker;
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);
        this.callbackId = 1;
        this.callbacks = {};
        this.$worker.onmessage = this.onMessage;
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts2) {
          if (require2.nameToUrl && !require2.toUrl)
            require2.toUrl = require2.nameToUrl;
          if (config2.get("packaged") || !require2.toUrl) {
            workerUrl = workerUrl || config2.moduleUrl(mod, "worker");
          } else {
            var normalizePath = this.$normalizePath;
            workerUrl = workerUrl || normalizePath(require2.toUrl("ace/worker/worker.js", null, "_"));
            var tlns = {};
            topLevelNamespaces.forEach(function(ns) {
              tlns[ns] = normalizePath(require2.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
            });
          }
          this.$worker = createWorker(workerUrl);
          if (importScripts2) {
            this.send("importScripts", importScripts2);
          }
          this.$worker.postMessage({
            init: true,
            tlns,
            module: mod,
            classname
          });
          return this.$worker;
        };
        this.onMessage = function(e75) {
          var msg = e75.data;
          switch (msg.type) {
            case "event":
              this._signal(msg.name, { data: msg.data });
              break;
            case "call":
              var callback = this.callbacks[msg.id];
              if (callback) {
                callback(msg.data);
                delete this.callbacks[msg.id];
              }
              break;
            case "error":
              this.reportError(msg.data);
              break;
            case "log":
              window.console && console.log && console.log.apply(console, msg.data);
              break;
          }
        };
        this.reportError = function(err) {
          window.console && console.error && console.error(err);
        };
        this.$normalizePath = function(path2) {
          return net.qualifyURL(path2);
        };
        this.terminate = function() {
          this._signal("terminate", {});
          this.deltaQueue = null;
          this.$worker.terminate();
          this.$worker.onerror = function(e75) {
            e75.preventDefault();
          };
          this.$worker = null;
          if (this.$doc)
            this.$doc.off("change", this.changeListener);
          this.$doc = null;
        };
        this.send = function(cmd, args) {
          this.$worker.postMessage({ command: cmd, args });
        };
        this.call = function(cmd, args, callback) {
          if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
          }
          this.send(cmd, args);
        };
        this.emit = function(event, data) {
          try {
            if (data.data && data.data.err)
              data.data.err = { message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code };
            this.$worker && this.$worker.postMessage({ event, data: { data: data.data } });
          } catch (ex) {
            console.error(ex.stack);
          }
        };
        this.attachToDocument = function(doc2) {
          if (this.$doc)
            this.terminate();
          this.$doc = doc2;
          this.call("setValue", [doc2.getValue()]);
          doc2.on("change", this.changeListener, true);
        };
        this.changeListener = function(delta) {
          if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
          }
          if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
          else
            this.deltaQueue.push(delta.start, delta.end);
        };
        this.$sendDeltaQueue = function() {
          var q = this.deltaQueue;
          if (!q) return;
          this.deltaQueue = null;
          if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
          } else
            this.emit("change", { data: q });
        };
      }).call(WorkerClient.prototype);
      var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);
        var messageBuffer = [];
        var workerClient = new WorkerClient({
          messageBuffer,
          terminate: function() {
          },
          postMessage: function(e75) {
            messageBuffer.push(e75);
            if (!main) return;
            if (emitSync)
              setTimeout(processNext);
            else
              processNext();
          }
        });
        workerClient.setEmitSync = function(val) {
          emitSync = val;
        };
        var processNext = function() {
          var msg = messageBuffer.shift();
          if (msg.command)
            main[msg.command].apply(main, msg.args);
          else if (msg.event)
            sender._signal(msg.event, msg.data);
        };
        sender.postMessage = function(msg) {
          workerClient.onMessage({ data: msg });
        };
        sender.callback = function(data, callbackId) {
          this.postMessage({ type: "call", id: callbackId, data });
        };
        sender.emit = function(name, data) {
          this.postMessage({ type: "event", name, data });
        };
        config2.loadModule(["worker", mod], function(Main) {
          main = new Main[classname](sender);
          while (messageBuffer.length)
            processNext();
        });
        return workerClient;
      };
      exports2.UIWorkerClient = UIWorkerClient;
      exports2.WorkerClient = WorkerClient;
      exports2.createWorker = createWorker;
    });
    ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(require2, exports2, module2) {
      "use strict";
      var Range2 = require2("./range").Range;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var oop = require2("./lib/oop");
      var PlaceHolder = (
        /** @class */
        function() {
          function PlaceHolder2(session, length, pos, others, mainClass, othersClass) {
            var _self = this;
            this.length = length;
            this.session = session;
            this.doc = session.getDocument();
            this.mainClass = mainClass;
            this.othersClass = othersClass;
            this.$onUpdate = this.onUpdate.bind(this);
            this.doc.on("change", this.$onUpdate, true);
            this.$others = others;
            this.$onCursorChange = function() {
              setTimeout(function() {
                _self.onCursorChange();
              });
            };
            this.$pos = pos;
            var undoStack = session.getUndoManager().$undoStack || session.getUndoManager()["$undostack"] || { length: -1 };
            this.$undoStackDepth = undoStack.length;
            this.setup();
            session.selection.on("changeCursor", this.$onCursorChange);
          }
          PlaceHolder2.prototype.setup = function() {
            var _self = this;
            var doc2 = this.doc;
            var session = this.session;
            this.selectionBefore = session.selection.toJSON();
            if (session.selection.inMultiSelectMode)
              session.selection.toSingleRange();
            this.pos = doc2.createAnchor(this.$pos.row, this.$pos.column);
            var pos = this.pos;
            pos.$insertRight = true;
            pos.detach();
            pos.markerId = session.addMarker(new Range2(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
            this.others = [];
            this.$others.forEach(function(other) {
              var anchor = doc2.createAnchor(other.row, other.column);
              anchor.$insertRight = true;
              anchor.detach();
              _self.others.push(anchor);
            });
            session.setUndoSelect(false);
          };
          PlaceHolder2.prototype.showOtherMarkers = function() {
            if (this.othersActive)
              return;
            var session = this.session;
            var _self = this;
            this.othersActive = true;
            this.others.forEach(function(anchor) {
              anchor.markerId = session.addMarker(new Range2(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
            });
          };
          PlaceHolder2.prototype.hideOtherMarkers = function() {
            if (!this.othersActive)
              return;
            this.othersActive = false;
            for (var i = 0; i < this.others.length; i++) {
              this.session.removeMarker(this.others[i].markerId);
            }
          };
          PlaceHolder2.prototype.onUpdate = function(delta) {
            if (this.$updating)
              return this.updateAnchors(delta);
            var range = delta;
            if (range.start.row !== range.end.row)
              return;
            if (range.start.row !== this.pos.row)
              return;
            this.$updating = true;
            var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
            var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
            var distanceFromStart = range.start.column - this.pos.column;
            this.updateAnchors(delta);
            if (inMainRange)
              this.length += lengthDiff;
            if (inMainRange && !this.session.$fromUndo) {
              if (delta.action === "insert") {
                for (var i = this.others.length - 1; i >= 0; i--) {
                  var otherPos = this.others[i];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.insertMergedLines(newPos, delta.lines);
                }
              } else if (delta.action === "remove") {
                for (var i = this.others.length - 1; i >= 0; i--) {
                  var otherPos = this.others[i];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.remove(new Range2(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
              }
            }
            this.$updating = false;
            this.updateMarkers();
          };
          PlaceHolder2.prototype.updateAnchors = function(delta) {
            this.pos.onChange(delta);
            for (var i = this.others.length; i--; )
              this.others[i].onChange(delta);
            this.updateMarkers();
          };
          PlaceHolder2.prototype.updateMarkers = function() {
            if (this.$updating)
              return;
            var _self = this;
            var session = this.session;
            var updateMarker = function(pos, className) {
              session.removeMarker(pos.markerId);
              pos.markerId = session.addMarker(new Range2(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
            };
            updateMarker(this.pos, this.mainClass);
            for (var i = this.others.length; i--; )
              updateMarker(this.others[i], this.othersClass);
          };
          PlaceHolder2.prototype.onCursorChange = function(event) {
            if (this.$updating || !this.session)
              return;
            var pos = this.session.selection.getCursor();
            if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
              this.showOtherMarkers();
              this._emit("cursorEnter", event);
            } else {
              this.hideOtherMarkers();
              this._emit("cursorLeave", event);
            }
          };
          PlaceHolder2.prototype.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId);
            this.hideOtherMarkers();
            this.doc.off("change", this.$onUpdate);
            this.session.selection.off("changeCursor", this.$onCursorChange);
            this.session.setUndoSelect(true);
            this.session = null;
          };
          PlaceHolder2.prototype.cancel = function() {
            if (this.$undoStackDepth === -1)
              return;
            var undoManager = this.session.getUndoManager();
            var undosRequired = (undoManager.$undoStack || undoManager["$undostack"]).length - this.$undoStackDepth;
            for (var i = 0; i < undosRequired; i++) {
              undoManager.undo(this.session, true);
            }
            if (this.selectionBefore)
              this.session.selection.fromJSON(this.selectionBefore);
          };
          return PlaceHolder2;
        }()
      );
      oop.implement(PlaceHolder.prototype, EventEmitter);
      exports2.PlaceHolder = PlaceHolder;
    });
    ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      function onMouseDown(e75) {
        var ev = e75.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e75.getAccelKey();
        var button = e75.getButton();
        if (ctrl && useragent.isMac)
          button = ev.button;
        if (e75.editor.inMultiSelectMode && button == 2) {
          e75.editor.textInput.onContextMenu(e75.domEvent);
          return;
        }
        if (!ctrl && !alt && !accel) {
          if (button === 0 && e75.editor.inMultiSelectMode)
            e75.editor.exitMultiSelectMode();
          return;
        }
        if (button !== 0)
          return;
        var editor2 = e75.editor;
        var selection = editor2.selection;
        var isMultiSelect = editor2.inMultiSelectMode;
        var pos = e75.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e75.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
        var mouseX = e75.x, mouseY = e75.y;
        var onMouseSelection = function(e76) {
          mouseX = e76.clientX;
          mouseY = e76.clientY;
        };
        var session = editor2.session;
        var screenAnchor = editor2.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        var selectionMode;
        if (editor2.$mouseHandler.$enableJumpToDef) {
          if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
          else if (alt && editor2.$blockSelectEnabled)
            selectionMode = "block";
        } else {
          if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
              return;
          } else if (alt && editor2.$blockSelectEnabled) {
            selectionMode = "block";
          }
        }
        if (selectionMode && useragent.isMac && ev.ctrlKey) {
          editor2.$mouseHandler.cancelContextMenu();
        }
        if (selectionMode == "add") {
          if (!isMultiSelect && inSelection)
            return;
          if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor2.addSelectionMarker(range);
          }
          var oldRange = selection.rangeList.rangeAtPoint(pos);
          editor2.inVirtualSelectionMode = true;
          if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor2.removeSelectionMarker(range);
          }
          editor2.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();
            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
              selection.substractPoint(tmpSel.cursor);
            else {
              if (shift) {
                selection.substractPoint(range.cursor);
              } else if (range) {
                editor2.removeSelectionMarker(range);
                selection.addRange(range);
              }
              selection.addRange(tmpSel);
            }
            editor2.inVirtualSelectionMode = false;
          });
        } else if (selectionMode == "block") {
          e75.stop();
          editor2.inVirtualSelectionMode = true;
          var initialRange;
          var rectSel = [];
          var blockSelect = function() {
            var newCursor = editor2.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor2 = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor2, selection.lead))
              return;
            screenCursor = newCursor;
            editor2.selection.moveToPosition(cursor2);
            editor2.renderer.scrollCursorIntoView();
            editor2.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor2.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
              rectSel[0] = editor2.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor2.addSelectionMarker, editor2);
            editor2.updateSelectionMarkers();
          };
          if (isMultiSelect && !accel) {
            selection.toSingleRange();
          } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor2.addSelectionMarker(initialRange);
          }
          if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);
          else
            selection.moveToPosition(pos);
          screenCursor = { row: -1, column: -1 };
          var onMouseSelectionEnd = function(e76) {
            blockSelect();
            clearInterval(timerId);
            editor2.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
              rectSel = [selection.toOrientedRange()];
            if (initialRange) {
              editor2.removeSelectionMarker(initialRange);
              selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
              selection.addRange(rectSel[i]);
            editor2.inVirtualSelectionMode = false;
            editor2.$mouseHandler.$clickSelection = null;
          };
          var onSelectionInterval = blockSelect;
          event.capture(editor2.container, onMouseSelection, onMouseSelectionEnd);
          var timerId = setInterval(function() {
            onSelectionInterval();
          }, 20);
          return e75.preventDefault();
        }
      }
      exports2.onMouseDown = onMouseDown;
    });
    ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(require2, exports2, module2) {
      exports2.defaultCommands = [{
        name: "addCursorAbove",
        description: "Add cursor above",
        exec: function(editor2) {
          editor2.selectMoreLines(-1);
        },
        bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelow",
        description: "Add cursor below",
        exec: function(editor2) {
          editor2.selectMoreLines(1);
        },
        bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorAboveSkipCurrent",
        description: "Add cursor above (skip current)",
        exec: function(editor2) {
          editor2.selectMoreLines(-1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelowSkipCurrent",
        description: "Add cursor below (skip current)",
        exec: function(editor2) {
          editor2.selectMoreLines(1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreBefore",
        description: "Select more before",
        exec: function(editor2) {
          editor2.selectMore(-1);
        },
        bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreAfter",
        description: "Select more after",
        exec: function(editor2) {
          editor2.selectMore(1);
        },
        bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextBefore",
        description: "Select next before",
        exec: function(editor2) {
          editor2.selectMore(-1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextAfter",
        description: "Select next after",
        exec: function(editor2) {
          editor2.selectMore(1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "toggleSplitSelectionIntoLines",
        description: "Split selection into lines",
        exec: function(editor2) {
          if (editor2.multiSelect.rangeCount > 1)
            editor2.multiSelect.joinSelections();
          else
            editor2.multiSelect.splitIntoLines();
        },
        bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
        readOnly: true
      }, {
        name: "splitSelectionIntoLines",
        description: "Split into lines",
        exec: function(editor2) {
          editor2.multiSelect.splitIntoLines();
        },
        readOnly: true
      }, {
        name: "alignCursors",
        description: "Align cursors",
        exec: function(editor2) {
          editor2.alignCursors();
        },
        bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
        scrollIntoView: "cursor"
      }, {
        name: "findAll",
        description: "Find all",
        exec: function(editor2) {
          editor2.findAll();
        },
        bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
        scrollIntoView: "cursor",
        readOnly: true
      }];
      exports2.multiSelectCommands = [{
        name: "singleSelection",
        description: "Single selection",
        bindKey: "esc",
        exec: function(editor2) {
          editor2.exitMultiSelectMode();
        },
        scrollIntoView: "cursor",
        readOnly: true,
        isAvailable: function(editor2) {
          return editor2 && editor2.inMultiSelectMode;
        }
      }];
      var HashHandler = require2("../keyboard/hash_handler").HashHandler;
      exports2.keyboardHandler = new HashHandler(exports2.multiSelectCommands);
    });
    ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(require2, exports2, module2) {
      var RangeList = require2("./range_list").RangeList;
      var Range2 = require2("./range").Range;
      var Selection = require2("./selection").Selection;
      var onMouseDown = require2("./mouse/multi_select_handler").onMouseDown;
      var event = require2("./lib/event");
      var lang = require2("./lib/lang");
      var commands = require2("./commands/multi_select_commands");
      exports2.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
      var Search = require2("./search").Search;
      var search = new Search();
      function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
      }
      var EditSession = require2("./edit_session").EditSession;
      (function() {
        this.getSelectionMarkers = function() {
          return this.$selectionMarkers;
        };
      }).call(EditSession.prototype);
      (function() {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function(range, $blockChangeEvents) {
          if (!range)
            return;
          if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
              this.rangeList.removeAll();
              return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
          }
          if (!range.cursor)
            range.cursor = range.end;
          var removed = this.rangeList.add(range);
          this.$onAddRange(range);
          if (removed.length)
            this.$onRemoveRange(removed);
          if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
          }
          return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function(range) {
          range = range || this.ranges[0];
          var removed = this.rangeList.removeAll();
          if (removed.length)
            this.$onRemoveRange(removed);
          range && this.fromOrientedRange(range);
        };
        this.substractPoint = function(pos) {
          var removed = this.rangeList.substractPoint(pos);
          if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
          }
        };
        this.mergeOverlappingRanges = function() {
          var removed = this.rangeList.merge();
          if (removed.length)
            this.$onRemoveRange(removed);
        };
        this.$onAddRange = function(range) {
          this.rangeCount = this.rangeList.ranges.length;
          this.ranges.unshift(range);
          this._signal("addRange", { range });
        };
        this.$onRemoveRange = function(removed) {
          this.rangeCount = this.rangeList.ranges.length;
          if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
          }
          for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
          }
          this._signal("removeRange", { ranges: removed });
          if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
          }
          lastRange = lastRange || this.ranges[0];
          if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function() {
          if (this.rangeList)
            return;
          this.rangeList = new RangeList();
          this.ranges = [];
          this.rangeCount = 0;
        };
        this.getAllRanges = function() {
          return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
        };
        this.splitIntoLines = function() {
          var ranges = this.ranges.length ? this.ranges : [this.getRange()];
          var newRanges = [];
          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            var row = range.start.row;
            var endRow = range.end.row;
            if (row === endRow) {
              newRanges.push(range.clone());
            } else {
              newRanges.push(new Range2(row, range.start.column, row, this.session.getLine(row).length));
              while (++row < endRow)
                newRanges.push(this.getLineRange(row, true));
              newRanges.push(new Range2(endRow, 0, endRow, range.end.column));
            }
            if (i == 0 && !this.isBackwards())
              newRanges = newRanges.reverse();
          }
          this.toSingleRange();
          for (var i = newRanges.length; i--; )
            this.addRange(newRanges[i]);
        };
        this.joinSelections = function() {
          var ranges = this.rangeList.ranges;
          var lastRange = ranges[ranges.length - 1];
          var range = Range2.fromPoints(ranges[0].start, lastRange.end);
          this.toSingleRange();
          this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        };
        this.toggleBlockSelection = function() {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range2.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var cursor = this.session.documentToScreenPosition(this.cursor);
            var anchor = this.session.documentToScreenPosition(this.anchor);
            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
          var rectSel = [];
          var xBackwards = screenCursor.column < screenAnchor.column;
          if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
          } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
          }
          var yBackwards = screenCursor.row < screenAnchor.row;
          if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
          } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
          }
          if (startColumn < 0)
            startColumn = 0;
          if (startRow < 0)
            startRow = 0;
          if (startRow == endRow)
            includeEmptyLines = true;
          var docEnd;
          for (var row = startRow; row <= endRow; row++) {
            var range = Range2.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
            if (range.isEmpty()) {
              if (docEnd && isSamePoint(range.end, docEnd))
                break;
              docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
          }
          if (yBackwards)
            rectSel.reverse();
          if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
              end--;
            if (end > 0) {
              var start = 0;
              while (rectSel[start].isEmpty())
                start++;
            }
            for (var i = end; i >= start; i--) {
              if (rectSel[i].isEmpty())
                rectSel.splice(i, 1);
            }
          }
          return rectSel;
        };
      }).call(Selection.prototype);
      var Editor = require2("./editor").Editor;
      (function() {
        this.updateSelectionMarkers = function() {
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function(orientedRange) {
          if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;
          var style = this.getSelectionStyle();
          orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
          this.session.$selectionMarkers.push(orientedRange);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          return orientedRange;
        };
        this.removeSelectionMarker = function(range) {
          if (!range.marker)
            return;
          this.session.removeMarker(range.marker);
          var index = this.session.$selectionMarkers.indexOf(range);
          if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };
        this.removeSelectionMarkers = function(ranges) {
          var markerList = this.session.$selectionMarkers;
          for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
              continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
              markerList.splice(index, 1);
          }
          this.session.selectionMarkerCount = markerList.length;
        };
        this.$onAddRange = function(e75) {
          this.addSelectionMarker(e75.range);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onRemoveRange = function(e75) {
          this.removeSelectionMarkers(e75.ranges);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onMultiSelect = function(e75) {
          if (this.inMultiSelectMode)
            return;
          this.inMultiSelectMode = true;
          this.setStyle("ace_multiselect");
          this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
          this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onSingleSelect = function(e75) {
          if (this.session.multiSelect.inVirtualMode)
            return;
          this.inMultiSelectMode = false;
          this.unsetStyle("ace_multiselect");
          this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
          this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
          this._emit("changeSelection");
        };
        this.$onMultiSelectExec = function(e75) {
          var command = e75.command;
          var editor2 = e75.editor;
          if (!editor2.multiSelect)
            return;
          if (!command.multiSelectAction) {
            var result = command.exec(editor2, e75.args || {});
            editor2.multiSelect.addRange(editor2.multiSelect.toOrientedRange());
            editor2.multiSelect.mergeOverlappingRanges();
          } else if (command.multiSelectAction == "forEach") {
            result = editor2.forEachSelection(command, e75.args);
          } else if (command.multiSelectAction == "forEachLine") {
            result = editor2.forEachSelection(command, e75.args, true);
          } else if (command.multiSelectAction == "single") {
            editor2.exitMultiSelectMode();
            result = command.exec(editor2, e75.args || {});
          } else {
            result = command.multiSelectAction(editor2, e75.args || {});
          }
          return result;
        };
        this.forEachSelection = function(cmd, args, options) {
          if (this.inVirtualSelectionMode)
            return;
          var keepOrder = options && options.keepOrder;
          var $byLines = options == true || options && options.$byLines;
          var session = this.session;
          var selection = this.selection;
          var rangeList = selection.rangeList;
          var ranges = (keepOrder ? selection : rangeList).ranges;
          var result;
          if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
          var reg = selection._eventRegistry;
          selection._eventRegistry = {};
          var tmpSel = new Selection(session);
          this.inVirtualSelectionMode = true;
          for (var i = ranges.length; i--; ) {
            if ($byLines) {
              while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== void 0)
              result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
          }
          tmpSel.detach();
          this.selection = session.selection = selection;
          this.inVirtualSelectionMode = false;
          selection._eventRegistry = reg;
          selection.mergeOverlappingRanges();
          if (selection.ranges[0])
            selection.fromOrientedRange(selection.ranges[0]);
          var anim = this.renderer.$scrollAnimation;
          this.onCursorChange();
          this.onSelectionChange();
          if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
          return result;
        };
        this.exitMultiSelectMode = function() {
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
          this.multiSelect.toSingleRange();
        };
        this.getSelectedText = function() {
          var text = "";
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
              buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
              text = "";
          } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
          }
          return text;
        };
        this.$checkMultiselectChange = function(e75, anchor) {
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
              return;
            var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
            if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
              this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            else
              this.multiSelect.mergeOverlappingRanges();
          }
        };
        this.findAll = function(needle, options, additive) {
          options = options || {};
          options.needle = needle || options.needle;
          if (options.needle == void 0) {
            var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
          }
          this.$search.set(options);
          var ranges = this.$search.findAll(this.session);
          if (!ranges.length)
            return 0;
          var selection = this.multiSelect;
          if (!additive)
            selection.toSingleRange(ranges[0]);
          for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);
          if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
          return ranges.length;
        };
        this.selectMoreLines = function(dir, skip) {
          var range = this.selection.toOrientedRange();
          var isBackwards = range.cursor == range.end;
          var screenLead = this.session.documentToScreenPosition(range.cursor);
          if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;
          var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
          if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
          } else {
            var anchor = lead;
          }
          if (isBackwards) {
            var newRange = Range2.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
          } else {
            var newRange = Range2.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
          }
          newRange.desiredColumn = screenLead.column;
          if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
          } else {
            if (skip)
              var toRemove = range.cursor;
          }
          this.selection.addRange(newRange);
          if (toRemove)
            this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function(dir) {
          var session = this.session;
          var sel = session.multiSelect;
          var all = sel.ranges;
          for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
              var tmp_1 = session.getWordRange(range.start.row, range.start.column);
              range.start.row = tmp_1.start.row;
              range.start.column = tmp_1.start.column;
              range.end.row = tmp_1.end.row;
              range.end.column = tmp_1.end.column;
            }
          }
          sel.mergeOverlappingRanges();
          var words = [];
          for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
          }
          if (dir < 0)
            words.unshift(words.pop());
          else
            words.push(words.shift());
          for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
          }
          sel.fromOrientedRange(sel.ranges[0]);
        };
        this.selectMore = function(dir, skip, stopAtFirst) {
          var session = this.session;
          var sel = session.multiSelect;
          var range = sel.toOrientedRange();
          if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
              return;
          }
          var needle = session.getTextRange(range);
          var newRange = find(session, needle, dir);
          if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.renderer.scrollCursorIntoView(null, 0.5);
          }
          if (skip)
            this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function() {
          var session = this.session;
          var sel = session.multiSelect;
          var ranges = sel.ranges;
          var row = -1;
          var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
              return true;
            row = r.cursor.row;
          });
          if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
              var max = this.session.getLength();
              var line;
              do {
                line = this.session.getLine(lr);
              } while (/[=:]/.test(line) && ++lr < max);
              do {
                line = this.session.getLine(fr);
              } while (/[=:]/.test(line) && --fr > 0);
              if (fr < 0)
                fr = 0;
              if (lr >= max)
                lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
            if (!guessRange) {
              range.start.column = 0;
              range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
          } else {
            sameRowRanges.forEach(function(r) {
              sel.substractPoint(r.cursor);
            });
            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
              var p = r.cursor;
              var line2 = session.getLine(p.row);
              var spaceOffset = line2.substr(p.column).search(/\S/g);
              if (spaceOffset == -1)
                spaceOffset = 0;
              if (p.column > maxCol)
                maxCol = p.column;
              if (spaceOffset < minSpace)
                minSpace = spaceOffset;
              return spaceOffset;
            });
            ranges.forEach(function(r, i) {
              var p = r.cursor;
              var l = maxCol - p.column;
              var d = spaceOffsets[i] - minSpace;
              if (l > d)
                session.insert(p, lang.stringRepeat(" ", l - d));
              else
                session.remove(new Range2(p.row, p.column, p.row, p.column - l + d));
              r.start.column = r.end.column = maxCol;
              r.start.row = r.end.row = p.row;
              r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          }
        };
        this.$reAlignText = function(lines, forceLeft) {
          var isLeftAligned = true, isRightAligned = true;
          var startW, textW, endW;
          return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
              return [line];
            if (startW == null) {
              startW = m[1].length;
              textW = m[2].length;
              endW = m[3].length;
              return m;
            }
            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
              isRightAligned = false;
            if (startW != m[1].length)
              isLeftAligned = false;
            if (startW > m[1].length)
              startW = m[1].length;
            if (textW < m[2].length)
              textW = m[2].length;
            if (endW > m[3].length)
              endW = m[3].length;
            return m;
          }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
          function spaces(n) {
            return lang.stringRepeat(" ", n);
          }
          function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
        };
      }).call(Editor.prototype);
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      exports2.onSessionChange = function(e75) {
        var session = e75.session;
        if (session && !session.multiSelect) {
          session.$selectionMarkers = [];
          session.selection.$initRangeList();
          session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;
        var oldSession = e75.oldSession;
        if (oldSession) {
          oldSession.multiSelect.off("addRange", this.$onAddRange);
          oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
          oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
          oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
          oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
          oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }
        if (session) {
          session.multiSelect.on("addRange", this.$onAddRange);
          session.multiSelect.on("removeRange", this.$onRemoveRange);
          session.multiSelect.on("multiSelect", this.$onMultiSelect);
          session.multiSelect.on("singleSelect", this.$onSingleSelect);
          session.multiSelect.lead.on("change", this.$checkMultiselectChange);
          session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }
        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
          if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
          else
            this.$onSingleSelect();
        }
      };
      function MultiSelect(editor2) {
        if (editor2.$multiselectOnSessionChange)
          return;
        editor2.$onAddRange = editor2.$onAddRange.bind(editor2);
        editor2.$onRemoveRange = editor2.$onRemoveRange.bind(editor2);
        editor2.$onMultiSelect = editor2.$onMultiSelect.bind(editor2);
        editor2.$onSingleSelect = editor2.$onSingleSelect.bind(editor2);
        editor2.$multiselectOnSessionChange = exports2.onSessionChange.bind(editor2);
        editor2.$checkMultiselectChange = editor2.$checkMultiselectChange.bind(editor2);
        editor2.$multiselectOnSessionChange(editor2);
        editor2.on("changeSession", editor2.$multiselectOnSessionChange);
        editor2.on("mousedown", onMouseDown);
        editor2.commands.addCommands(commands.defaultCommands);
        addAltCursorListeners(editor2);
      }
      function addAltCursorListeners(editor2) {
        if (!editor2.textInput)
          return;
        var el = editor2.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function(e75) {
          var altDown = e75.keyCode == 18 && !(e75.ctrlKey || e75.shiftKey || e75.metaKey);
          if (editor2.$blockSelectEnabled && altDown) {
            if (!altCursor) {
              editor2.renderer.setMouseCursor("crosshair");
              altCursor = true;
            }
          } else if (altCursor) {
            reset();
          }
        }, editor2);
        event.addListener(el, "keyup", reset, editor2);
        event.addListener(el, "blur", reset, editor2);
        function reset(e75) {
          if (altCursor) {
            editor2.renderer.setMouseCursor("");
            altCursor = false;
          }
        }
      }
      exports2.MultiSelect = MultiSelect;
      require2("./config").defineOptions(Editor.prototype, "editor", {
        enableMultiselect: {
          set: function(val) {
            MultiSelect(this);
            if (val) {
              this.on("mousedown", onMouseDown);
            } else {
              this.off("mousedown", onMouseDown);
            }
          },
          value: true
        },
        enableBlockSelect: {
          set: function(val) {
            this.$blockSelectEnabled = val;
          },
          value: true
        }
      });
    });
    ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
      "use strict";
      var Range2 = require2("../../range").Range;
      var FoldMode = exports2.FoldMode = function() {
      };
      (function() {
        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function(session, foldStyle, row) {
          var line = session.getLine(row);
          if (this.foldingStartMarker.test(line))
            return "start";
          if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line))
            return "end";
          return "";
        };
        this.getFoldWidgetRange = function(session, foldStyle, row) {
          return null;
        };
        this.indentationBlock = function(session, row, column) {
          var re = /\S/;
          var line = session.getLine(row);
          var startLevel = line.search(re);
          if (startLevel == -1)
            return;
          var startColumn = column || line.length;
          var maxRow = session.getLength();
          var startRow = row;
          var endRow = row;
          while (++row < maxRow) {
            var level = session.getLine(row).search(re);
            if (level == -1)
              continue;
            if (level <= startLevel) {
              var token = session.getTokenAt(row, 0);
              if (!token || token.type !== "string")
                break;
            }
            endRow = row;
          }
          if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range2(startRow, startColumn, endRow, endColumn);
          }
        };
        this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
          var start = { row, column: column + 1 };
          var end = session.$findClosingBracket(bracket, start, typeRe);
          if (!end)
            return;
          var fw = session.foldWidgets[end.row];
          if (fw == null)
            fw = session.getFoldWidget(end.row);
          if (fw == "start" && end.row > start.row) {
            end.row--;
            end.column = session.getLine(end.row).length;
          }
          return Range2.fromPoints(start, end);
        };
        this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
          var end = { row, column };
          var start = session.$findOpeningBracket(bracket, end);
          if (!start)
            return;
          start.column++;
          end.column--;
          return Range2.fromPoints(start, end);
        };
      }).call(FoldMode.prototype);
    });
    ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/config"], function(require2, exports2, module2) {
      "use strict";
      var dom = require2("../lib/dom");
      var Range2 = require2("../range").Range;
      var nls = require2("../config").nls;
      function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;
        while (first <= last) {
          var mid = first + last >> 1;
          var c = comparator(needle, array[mid]);
          if (c > 0)
            first = mid + 1;
          else if (c < 0)
            last = mid - 1;
          else
            return mid;
        }
        return -(first + 1);
      }
      function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range2.comparePoints);
        if (!annotations.length)
          return;
        var i = binarySearch(annotations, { row, column: -1 }, Range2.comparePoints);
        if (i < 0)
          i = -i - 1;
        if (i >= annotations.length)
          i = dir > 0 ? 0 : annotations.length - 1;
        else if (i === 0 && dir < 0)
          i = annotations.length - 1;
        var annotation = annotations[i];
        if (!annotation || !dir)
          return;
        if (annotation.row === row) {
          do {
            annotation = annotations[i += dir];
          } while (annotation && annotation.row === row);
          if (!annotation)
            return annotations.slice();
        }
        var matched = [];
        row = annotation.row;
        do {
          matched[dir < 0 ? "unshift" : "push"](annotation);
          annotation = annotations[i += dir];
        } while (annotation && annotation.row == row);
        return matched.length && matched;
      }
      exports2.showErrorMarker = function(editor2, dir) {
        var session = editor2.session;
        var pos = editor2.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w2) {
          return w2.type == "errorMarker";
        })[0];
        if (oldWidget) {
          oldWidget.destroy();
        } else {
          row -= dir;
        }
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
          var annotation = annotations[0];
          pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
          pos.row = annotation.row;
          gutterAnno = editor2.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) {
          return;
        } else {
          gutterAnno = {
            displayText: [nls("error-marker.good-state", "Looks good!")],
            className: "ace_ok"
          };
        }
        editor2.session.unfold(pos.row);
        editor2.selection.moveToPosition(pos);
        var w = {
          row: pos.row,
          fixedWidth: true,
          coverGutter: true,
          el: dom.createElement("div"),
          type: "errorMarker"
        };
        var el = w.el.appendChild(dom.createElement("div"));
        var arrow = w.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        var left = editor2.renderer.$cursorLayer.getPixelPosition(pos).left;
        arrow.style.left = left + editor2.renderer.gutterWidth - 5 + "px";
        w.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        gutterAnno.displayText.forEach(function(annoTextLine, i) {
          el.appendChild(dom.createTextNode(annoTextLine));
          if (i < gutterAnno.displayText.length - 1) {
            el.appendChild(dom.createElement("br"));
          }
        });
        el.appendChild(dom.createElement("div"));
        var kb = function(_, hashId, keyString) {
          if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return { command: "null" };
          }
        };
        w.destroy = function() {
          if (editor2.$mouseHandler.isMousePressed)
            return;
          editor2.keyBinding.removeKeyboardHandler(kb);
          session.widgetManager.removeLineWidget(w);
          editor2.off("changeSelection", w.destroy);
          editor2.off("changeSession", w.destroy);
          editor2.off("mouseup", w.destroy);
          editor2.off("change", w.destroy);
        };
        editor2.keyBinding.addKeyboardHandler(kb);
        editor2.on("changeSelection", w.destroy);
        editor2.on("changeSession", w.destroy);
        editor2.on("mouseup", w.destroy);
        editor2.on("change", w.destroy);
        editor2.session.widgetManager.addLineWidget(w);
        w.el.onmousedown = editor2.focus.bind(editor2);
        editor2.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
      };
      dom.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", false);
    });
    ace.define("ace/ace", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config", "ace/loader_build"], function(require2, exports2, module2) {
      "use strict";
      require2("./loader_build")(exports2);
      var dom = require2("./lib/dom");
      var Range2 = require2("./range").Range;
      var Editor = require2("./editor").Editor;
      var EditSession = require2("./edit_session").EditSession;
      var UndoManager = require2("./undomanager").UndoManager;
      var Renderer = require2("./virtual_renderer").VirtualRenderer;
      require2("./worker/worker_client");
      require2("./keyboard/hash_handler");
      require2("./placeholder");
      require2("./multi_select");
      require2("./mode/folding/fold_mode");
      require2("./theme/textmate");
      require2("./ext/error_marker");
      exports2.config = require2("./config");
      exports2.edit = function(el, options) {
        if (typeof el == "string") {
          var _id = el;
          el = document.getElementById(_id);
          if (!el)
            throw new Error("ace.edit can't find div #" + _id);
        }
        if (el && el.env && el.env.editor instanceof Editor)
          return el.env.editor;
        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
          var oldNode = el;
          value = oldNode.value;
          el = dom.createElement("pre");
          oldNode.parentNode.replaceChild(el, oldNode);
        } else if (el) {
          value = el.textContent;
          el.innerHTML = "";
        }
        var doc2 = exports2.createEditSession(value);
        var editor2 = new Editor(new Renderer(el), doc2, options);
        var env = {
          document: doc2,
          editor: editor2,
          onResize: editor2.resize.bind(editor2, null)
        };
        if (oldNode)
          env.textarea = oldNode;
        editor2.on("destroy", function() {
          env.editor.container.env = null;
        });
        editor2.container.env = editor2.env = env;
        return editor2;
      };
      exports2.createEditSession = function(text, mode) {
        var doc2 = new EditSession(text, mode);
        doc2.setUndoManager(new UndoManager());
        return doc2;
      };
      exports2.Range = Range2;
      exports2.Editor = Editor;
      exports2.EditSession = EditSession;
      exports2.UndoManager = UndoManager;
      exports2.VirtualRenderer = Renderer;
      var version2 = exports2.config.version;
      exports2.version = version2;
    });
    (function() {
      ace.require(["ace/ace"], function(a) {
        if (a) {
          a.config.init(true);
          a.define = ace.define;
        }
        var global2 = /* @__PURE__ */ function() {
          return this;
        }();
        if (!global2 && typeof window != "undefined") global2 = window;
        if (!global2 && typeof self != "undefined") global2 = self;
        if (!global2.ace)
          global2.ace = a;
        for (var key in a) if (a.hasOwnProperty(key))
          global2.ace[key] = a[key];
        global2.ace["default"] = global2.ace;
        if (typeof module == "object" && typeof exports == "object" && module) {
          module.exports = global2.ace;
        }
      });
    })();
  }
});

// node_modules/.pnpm/vanilla@https+++codeload.github.com+dragoncoder047+vanilla+tar.gz+400e4ce789aebdcb53c7250a2d4ad6c94f1b193c/node_modules/vanilla/vanilla.ts
function make(nameAndClasses, properties, ...children) {
  const [name, ...classes] = nameAndClasses.split(".");
  const el = document.createElement(name);
  if (classes.length > 0)
    el.classList.add(...classes);
  for (var [k, v] of Object.entries(properties ?? {})) {
    el.setAttribute(k, v);
  }
  el.append(...children);
  return el;
}
function get(id) {
  return document.querySelector(id);
}
function bind(selector, event, handler, capture = false) {
  get(selector)?.addEventListener(event, handler, { capture });
}
var init_vanilla = __esm({
  "node_modules/.pnpm/vanilla@https+++codeload.github.com+dragoncoder047+vanilla+tar.gz+400e4ce789aebdcb53c7250a2d4ad6c94f1b193c/node_modules/vanilla/vanilla.ts"() {
  }
});

// node_modules/.pnpm/@jcubic+lips@https+++codeload.github.com+jcubic+lips+tar.gz+876af5394f85e7b720f9a62545c19864bc1fe409/node_modules/@jcubic/lips/dist/lips.esm.min.js
function _isNativeReflectConstruct$1() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct$1 = function e75() {
    return !!t2;
  })();
}
function _setPrototypeOf(e75, t2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e76, t3) {
    return e76.__proto__ = t3, e76;
  }, _setPrototypeOf(e75, t2);
}
function _construct(e75, t2, r) {
  if (_isNativeReflectConstruct$1()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, t2);
  var i = new (e75.bind.apply(e75, n))();
  return r && _setPrototypeOf(i, r.prototype), i;
}
function _arrayWithHoles(e75) {
  if (Array.isArray(e75)) return e75;
}
function _iterableToArray(e75) {
  if ("undefined" != typeof Symbol && null != e75[Symbol.iterator] || null != e75["@@iterator"]) return Array.from(e75);
}
function _arrayLikeToArray$1(e75, t2) {
  (null == t2 || t2 > e75.length) && (t2 = e75.length);
  for (var r = 0, n = Array(t2); r < t2; r++) n[r] = e75[r];
  return n;
}
function _unsupportedIterableToArray$1(e75, t2) {
  if (e75) {
    if ("string" == typeof e75) return _arrayLikeToArray$1(e75, t2);
    var r = {}.toString.call(e75).slice(8, -1);
    return "Object" === r && e75.constructor && (r = e75.constructor.name), "Map" === r || "Set" === r ? Array.from(e75) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? _arrayLikeToArray$1(e75, t2) : void 0;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toArray(e75) {
  return _arrayWithHoles(e75) || _iterableToArray(e75) || _unsupportedIterableToArray$1(e75) || _nonIterableRest();
}
function _typeof$1(e75) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e76) {
    return typeof e76;
  } : function(e76) {
    return e76 && "function" == typeof Symbol && e76.constructor === Symbol && e76 !== Symbol.prototype ? "symbol" : typeof e76;
  }, _typeof$1(e75);
}
function _assertThisInitialized(e75) {
  if (void 0 === e75) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e75;
}
function _possibleConstructorReturn(e75, t2) {
  if (t2 && ("object" == _typeof$1(t2) || "function" == typeof t2)) return t2;
  if (void 0 !== t2) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(e75);
}
function _getPrototypeOf(e75) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e76) {
    return e76.__proto__ || Object.getPrototypeOf(e76);
  }, _getPrototypeOf(e75);
}
function _inherits(e75, t2) {
  if ("function" != typeof t2 && null !== t2) throw new TypeError("Super expression must either be null or a function");
  e75.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e75, writable: true, configurable: true } }), Object.defineProperty(e75, "prototype", { writable: false }), t2 && _setPrototypeOf(e75, t2);
}
function _isNativeFunction(t2) {
  try {
    return -1 !== Function.toString.call(t2).indexOf("[native code]");
  } catch (e75) {
    return "function" == typeof t2;
  }
}
function _wrapNativeSuper(e75) {
  var n = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function e76(t2) {
    if (null === t2 || !_isNativeFunction(t2)) return t2;
    if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== n) {
      if (n.has(t2)) return n.get(t2);
      n.set(t2, r);
    }
    function r() {
      return _construct(t2, arguments, _getPrototypeOf(this).constructor);
    }
    return r.prototype = Object.create(t2.prototype, { constructor: { value: r, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(r, t2);
  }, _wrapNativeSuper(e75);
}
function asyncGeneratorStep(e75, t2, r, n, i, a, o) {
  try {
    var u = e75[a](o), s = u.value;
  } catch (e76) {
    return void r(e76);
  }
  u.done ? t2(s) : Promise.resolve(s).then(n, i);
}
function _asyncToGenerator(u) {
  return function() {
    var e75 = this, o = arguments;
    return new Promise(function(t2, r) {
      var n = u.apply(e75, o);
      function i(e76) {
        asyncGeneratorStep(n, t2, r, i, a, "next", e76);
      }
      function a(e76) {
        asyncGeneratorStep(n, t2, r, i, a, "throw", e76);
      }
      i(void 0);
    });
  };
}
function _classCallCheck(e75, t2) {
  if (!(e75 instanceof t2)) throw new TypeError("Cannot call a class as a function");
}
function toPrimitive(e75, t2) {
  if ("object" != _typeof$1(e75) || !e75) return e75;
  var r = e75[Symbol.toPrimitive];
  if (void 0 !== r) {
    var n = r.call(e75, t2 || "default");
    if ("object" != _typeof$1(n)) return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === t2 ? String : Number)(e75);
}
function toPropertyKey(e75) {
  var t2 = toPrimitive(e75, "string");
  return "symbol" == _typeof$1(t2) ? t2 : t2 + "";
}
function _defineProperties(e75, t2) {
  for (var r = 0; r < t2.length; r++) {
    var n = t2[r];
    n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e75, toPropertyKey(n.key), n);
  }
}
function _createClass(e75, t2, r) {
  return t2 && _defineProperties(e75.prototype, t2), Object.defineProperty(e75, "prototype", { writable: false }), e75;
}
function _defineProperty(e75, t2, r) {
  return (t2 = toPropertyKey(t2)) in e75 ? Object.defineProperty(e75, t2, { value: r, enumerable: true, configurable: true, writable: true }) : e75[t2] = r, e75;
}
function _objectWithoutPropertiesLoose(e75, t2) {
  if (null == e75) return {};
  var r = {};
  for (var n in e75) if ({}.hasOwnProperty.call(e75, n)) {
    if (t2.includes(n)) continue;
    r[n] = e75[n];
  }
  return r;
}
function _objectWithoutProperties(e75, t2) {
  if (null == e75) return {};
  var r, n, i = _objectWithoutPropertiesLoose(e75, t2);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e75);
    for (n = 0; n < a.length; n++) r = a[n], t2.includes(r) || {}.propertyIsEnumerable.call(e75, r) && (i[r] = e75[r]);
  }
  return i;
}
function _iterableToArrayLimit(e75, t2) {
  var r = null == e75 ? null : "undefined" != typeof Symbol && e75[Symbol.iterator] || e75["@@iterator"];
  if (null != r) {
    var n, i, a, o, u = [], s = true, c = false;
    try {
      if (a = (r = r.call(e75)).next, 0 === t2) {
        if (Object(r) !== r) return;
        s = false;
      } else for (; !(s = (n = a.call(r)).done) && (u.push(n.value), u.length !== t2); s = true) ;
    } catch (e76) {
      c = true, i = e76;
    } finally {
      try {
        if (!s && null != r["return"] && (o = r["return"](), Object(o) !== o)) return;
      } finally {
        if (c) throw i;
      }
    }
    return u;
  }
}
function _slicedToArray(e75, t2) {
  return _arrayWithHoles(e75) || _iterableToArrayLimit(e75, t2) || _unsupportedIterableToArray$1(e75, t2) || _nonIterableRest();
}
function _arrayWithoutHoles(e75) {
  if (Array.isArray(e75)) return _arrayLikeToArray$1(e75);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(e75) {
  return _arrayWithoutHoles(e75) || _iterableToArray(e75) || _unsupportedIterableToArray$1(e75) || _nonIterableSpread();
}
function _OverloadYield(e75, t2) {
  this.v = e75, this.k = t2;
}
function _awaitAsyncGenerator(e75) {
  return new _OverloadYield(e75, 0);
}
function _wrapAsyncGenerator(e75) {
  return function() {
    return new AsyncGenerator(e75.apply(this, arguments));
  };
}
function AsyncGenerator(o) {
  var a, u;
  function s(r, e75) {
    try {
      var n = o[r](e75), i = n.value, a2 = i instanceof _OverloadYield;
      Promise.resolve(a2 ? i.v : i).then(function(e76) {
        if (a2) {
          var t2 = "return" === r ? "return" : "next";
          if (!i.k || e76.done) return s(t2, e76);
          e76 = o[t2](e76).value;
        }
        c(n.done ? "return" : "normal", e76);
      }, function(e76) {
        s("throw", e76);
      });
    } catch (e76) {
      c("throw", e76);
    }
  }
  function c(e75, t2) {
    switch (e75) {
      case "return":
        a.resolve({ value: t2, done: true });
        break;
      case "throw":
        a.reject(t2);
        break;
      default:
        a.resolve({ value: t2, done: false });
    }
    (a = a.next) ? s(a.key, a.arg) : u = null;
  }
  this._invoke = function(n, i) {
    return new Promise(function(e75, t2) {
      var r = { key: n, arg: i, resolve: e75, reject: t2, next: null };
      u ? u = u.next = r : (a = u = r, s(n, i));
    });
  }, "function" != typeof o["return"] && (this["return"] = void 0);
}
function getDefaultExportFromCjs(e75) {
  return e75 && e75.__esModule && Object.prototype.hasOwnProperty.call(e75, "default") ? e75["default"] : e75;
}
function require_typeof() {
  if (hasRequired_typeof) return _typeof.exports;
  hasRequired_typeof = 1;
  (function(t2) {
    function r(e75) {
      "@babel/helpers - typeof";
      return t2.exports = r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e76) {
        return typeof e76;
      } : function(e76) {
        return e76 && "function" == typeof Symbol && e76.constructor === Symbol && e76 !== Symbol.prototype ? "symbol" : typeof e76;
      }, t2.exports.__esModule = true, t2.exports["default"] = t2.exports, r(e75);
    }
    t2.exports = r, t2.exports.__esModule = true, t2.exports["default"] = t2.exports;
  })(_typeof);
  return _typeof.exports;
}
function requireRegeneratorRuntime() {
  if (hasRequiredRegeneratorRuntime) return regeneratorRuntime$1.exports;
  hasRequiredRegeneratorRuntime = 1;
  (function(O) {
    var N = require_typeof()["default"];
    function B() {
      O.exports = B = function e76() {
        return o;
      }, O.exports.__esModule = true, O.exports["default"] = O.exports;
      var c, o = {}, e75 = Object.prototype, l = e75.hasOwnProperty, f = Object.defineProperty || function(e76, t3, r2) {
        e76[t3] = r2.value;
      }, t2 = "function" == typeof Symbol ? Symbol : {}, i = t2.iterator || "@@iterator", r = t2.asyncIterator || "@@asyncIterator", n = t2.toStringTag || "@@toStringTag";
      function a(e76, t3, r2) {
        return Object.defineProperty(e76, t3, { value: r2, enumerable: true, configurable: true, writable: true }), e76[t3];
      }
      try {
        a({}, "");
      } catch (c2) {
        a = function e76(t3, r2, n2) {
          return t3[r2] = n2;
        };
      }
      function u(e76, t3, r2, n2) {
        var i2 = t3 && t3.prototype instanceof s ? t3 : s, a2 = Object.create(i2.prototype), o2 = new C(n2 || []);
        return f(a2, "_invoke", { value: S(e76, r2, o2) }), a2;
      }
      function _(e76, t3, r2) {
        try {
          return { type: "normal", arg: e76.call(t3, r2) };
        } catch (e77) {
          return { type: "throw", arg: e77 };
        }
      }
      o.wrap = u;
      var p = "suspendedStart", d = "suspendedYield", h = "executing", m = "completed", y = {};
      function s() {
      }
      function v() {
      }
      function b() {
      }
      var g = {};
      a(g, i, function() {
        return this;
      });
      var w = Object.getPrototypeOf, D = w && w(w(P([])));
      D && D !== e75 && l.call(D, i) && (g = D);
      var x = b.prototype = s.prototype = Object.create(g);
      function L(e76) {
        ["next", "throw", "return"].forEach(function(t3) {
          a(e76, t3, function(e77) {
            return this._invoke(t3, e77);
          });
        });
      }
      function E(u2, s2) {
        function c2(e76, t3, r2, n2) {
          var i3 = _(u2[e76], u2, t3);
          if ("throw" !== i3.type) {
            var a2 = i3.arg, o2 = a2.value;
            return o2 && "object" == N(o2) && l.call(o2, "__await") ? s2.resolve(o2.__await).then(function(e77) {
              c2("next", e77, r2, n2);
            }, function(e77) {
              c2("throw", e77, r2, n2);
            }) : s2.resolve(o2).then(function(e77) {
              a2.value = e77, r2(a2);
            }, function(e77) {
              return c2("throw", e77, r2, n2);
            });
          }
          n2(i3.arg);
        }
        var i2;
        f(this, "_invoke", { value: function e76(r2, n2) {
          function t3() {
            return new s2(function(e77, t4) {
              c2(r2, n2, e77, t4);
            });
          }
          return i2 = i2 ? i2.then(t3, t3) : t3();
        } });
      }
      function S(a2, o2, u2) {
        var s2 = p;
        return function(e76, t3) {
          if (s2 === h) throw Error("Generator is already running");
          if (s2 === m) {
            if ("throw" === e76) throw t3;
            return { value: c, done: true };
          }
          for (u2.method = e76, u2.arg = t3; ; ) {
            var r2 = u2.delegate;
            if (r2) {
              var n2 = A(r2, u2);
              if (n2) {
                if (n2 === y) continue;
                return n2;
              }
            }
            if ("next" === u2.method) u2.sent = u2._sent = u2.arg;
            else if ("throw" === u2.method) {
              if (s2 === p) throw s2 = m, u2.arg;
              u2.dispatchException(u2.arg);
            } else "return" === u2.method && u2.abrupt("return", u2.arg);
            s2 = h;
            var i2 = _(a2, o2, u2);
            if ("normal" === i2.type) {
              if (s2 = u2.done ? m : d, i2.arg === y) continue;
              return { value: i2.arg, done: u2.done };
            }
            "throw" === i2.type && (s2 = m, u2.method = "throw", u2.arg = i2.arg);
          }
        };
      }
      function A(e76, t3) {
        var r2 = t3.method, n2 = e76.iterator[r2];
        if (n2 === c) return t3.delegate = null, "throw" === r2 && e76.iterator["return"] && (t3.method = "return", t3.arg = c, A(e76, t3), "throw" === t3.method) || "return" !== r2 && (t3.method = "throw", t3.arg = new TypeError("The iterator does not provide a '" + r2 + "' method")), y;
        var i2 = _(n2, e76.iterator, t3.arg);
        if ("throw" === i2.type) return t3.method = "throw", t3.arg = i2.arg, t3.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (t3[e76.resultName] = a2.value, t3.next = e76.nextLoc, "return" !== t3.method && (t3.method = "next", t3.arg = c), t3.delegate = null, y) : a2 : (t3.method = "throw", t3.arg = new TypeError("iterator result is not an object"), t3.delegate = null, y);
      }
      function F(e76) {
        var t3 = { tryLoc: e76[0] };
        1 in e76 && (t3.catchLoc = e76[1]), 2 in e76 && (t3.finallyLoc = e76[2], t3.afterLoc = e76[3]), this.tryEntries.push(t3);
      }
      function k(e76) {
        var t3 = e76.completion || {};
        t3.type = "normal", delete t3.arg, e76.completion = t3;
      }
      function C(e76) {
        this.tryEntries = [{ tryLoc: "root" }], e76.forEach(F, this), this.reset(true);
      }
      function P(t3) {
        if (t3 || "" === t3) {
          var e76 = t3[i];
          if (e76) return e76.call(t3);
          if ("function" == typeof t3.next) return t3;
          if (!isNaN(t3.length)) {
            var r2 = -1, n2 = function e77() {
              for (; ++r2 < t3.length; ) if (l.call(t3, r2)) return e77.value = t3[r2], e77.done = false, e77;
              return e77.value = c, e77.done = true, e77;
            };
            return n2.next = n2;
          }
        }
        throw new TypeError(N(t3) + " is not iterable");
      }
      return v.prototype = b, f(x, "constructor", { value: b, configurable: true }), f(b, "constructor", { value: v, configurable: true }), v.displayName = a(b, n, "GeneratorFunction"), o.isGeneratorFunction = function(e76) {
        var t3 = "function" == typeof e76 && e76.constructor;
        return !!t3 && (t3 === v || "GeneratorFunction" === (t3.displayName || t3.name));
      }, o.mark = function(e76) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e76, b) : (e76.__proto__ = b, a(e76, n, "GeneratorFunction")), e76.prototype = Object.create(x), e76;
      }, o.awrap = function(e76) {
        return { __await: e76 };
      }, L(E.prototype), a(E.prototype, r, function() {
        return this;
      }), o.AsyncIterator = E, o.async = function(e76, t3, r2, n2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new E(u(e76, t3, r2, n2), i2);
        return o.isGeneratorFunction(t3) ? a2 : a2.next().then(function(e77) {
          return e77.done ? e77.value : a2.next();
        });
      }, L(x), a(x, n, "Generator"), a(x, i, function() {
        return this;
      }), a(x, "toString", function() {
        return "[object Generator]";
      }), o.keys = function(e76) {
        var r2 = Object(e76), n2 = [];
        for (var t3 in r2) n2.push(t3);
        return n2.reverse(), function e77() {
          for (; n2.length; ) {
            var t4 = n2.pop();
            if (t4 in r2) return e77.value = t4, e77.done = false, e77;
          }
          return e77.done = true, e77;
        };
      }, o.values = P, C.prototype = { constructor: C, reset: function e76(t3) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = c, this.done = false, this.delegate = null, this.method = "next", this.arg = c, this.tryEntries.forEach(k), !t3) for (var r2 in this) "t" === r2.charAt(0) && l.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = c);
      }, stop: function e76() {
        this.done = true;
        var t3 = this.tryEntries[0].completion;
        if ("throw" === t3.type) throw t3.arg;
        return this.rval;
      }, dispatchException: function e76(r2) {
        if (this.done) throw r2;
        var n2 = this;
        function t3(e77, t4) {
          return o2.type = "throw", o2.arg = r2, n2.next = e77, t4 && (n2.method = "next", n2.arg = c), !!t4;
        }
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var a2 = this.tryEntries[i2], o2 = a2.completion;
          if ("root" === a2.tryLoc) return t3("end");
          if (a2.tryLoc <= this.prev) {
            var u2 = l.call(a2, "catchLoc"), s2 = l.call(a2, "finallyLoc");
            if (u2 && s2) {
              if (this.prev < a2.catchLoc) return t3(a2.catchLoc, true);
              if (this.prev < a2.finallyLoc) return t3(a2.finallyLoc);
            } else if (u2) {
              if (this.prev < a2.catchLoc) return t3(a2.catchLoc, true);
            } else {
              if (!s2) throw Error("try statement without catch or finally");
              if (this.prev < a2.finallyLoc) return t3(a2.finallyLoc);
            }
          }
        }
      }, abrupt: function e76(t3, r2) {
        for (var n2 = this.tryEntries.length - 1; n2 >= 0; --n2) {
          var i2 = this.tryEntries[n2];
          if (i2.tryLoc <= this.prev && l.call(i2, "finallyLoc") && this.prev < i2.finallyLoc) {
            var a2 = i2;
            break;
          }
        }
        a2 && ("break" === t3 || "continue" === t3) && a2.tryLoc <= r2 && r2 <= a2.finallyLoc && (a2 = null);
        var o2 = a2 ? a2.completion : {};
        return o2.type = t3, o2.arg = r2, a2 ? (this.method = "next", this.next = a2.finallyLoc, y) : this.complete(o2);
      }, complete: function e76(t3, r2) {
        if ("throw" === t3.type) throw t3.arg;
        return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && r2 && (this.next = r2), y;
      }, finish: function e76(t3) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var n2 = this.tryEntries[r2];
          if (n2.finallyLoc === t3) return this.complete(n2.completion, n2.afterLoc), k(n2), y;
        }
      }, catch: function e76(t3) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var n2 = this.tryEntries[r2];
          if (n2.tryLoc === t3) {
            var i2 = n2.completion;
            if ("throw" === i2.type) {
              var a2 = i2.arg;
              k(n2);
            }
            return a2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function e76(t3, r2, n2) {
        return this.delegate = { iterator: P(t3), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = c), y;
      } }, o;
    }
    O.exports = B, O.exports.__esModule = true, O.exports["default"] = O.exports;
  })(regeneratorRuntime$1);
  return regeneratorRuntime$1.exports;
}
function requireRegenerator() {
  if (hasRequiredRegenerator) return regenerator;
  hasRequiredRegenerator = 1;
  var t2 = requireRegeneratorRuntime()();
  regenerator = t2;
  try {
    regeneratorRuntime = t2;
  } catch (e75) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = t2;
    } else {
      Function("r", "regeneratorRuntime = r")(t2);
    }
  }
  return regenerator;
}
function checkedRead() {
  try {
    let e75 = read();
    if (bundledStrings$1) {
      if (position$1 >= bundledStrings$1.postBundlePosition) {
        let e76 = new Error("Unexpected bundle position");
        e76.incomplete = true;
        throw e76;
      }
      position$1 = bundledStrings$1.postBundlePosition;
      bundledStrings$1 = null;
    }
    if (position$1 == srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap) referenceMap = null;
    } else if (position$1 > srcEnd) {
      let e76 = new Error("Unexpected end of CBOR data");
      e76.incomplete = true;
      throw e76;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    return e75;
  } catch (e75) {
    clearSource();
    if (e75 instanceof RangeError || e75.message.startsWith("Unexpected end of buffer")) {
      e75.incomplete = true;
    }
    throw e75;
  }
}
function read() {
  let n = src[position$1++];
  let i = n >> 5;
  n = n & 31;
  if (n > 23) {
    switch (n) {
      case 24:
        n = src[position$1++];
        break;
      case 25:
        if (i == 7) {
          return getFloat16();
        }
        n = dataView.getUint16(position$1);
        position$1 += 2;
        break;
      case 26:
        if (i == 7) {
          let t2 = dataView.getFloat32(position$1);
          if (currentDecoder.useFloat32 > 2) {
            let e75 = mult10[(src[position$1] & 127) << 1 | src[position$1 + 1] >> 7];
            position$1 += 4;
            return (e75 * t2 + (t2 > 0 ? 0.5 : -0.5) >> 0) / e75;
          }
          position$1 += 4;
          return t2;
        }
        n = dataView.getUint32(position$1);
        position$1 += 4;
        break;
      case 27:
        if (i == 7) {
          let e75 = dataView.getFloat64(position$1);
          position$1 += 8;
          return e75;
        }
        if (i > 1) {
          if (dataView.getUint32(position$1) > 0) throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          n = dataView.getUint32(position$1 + 4);
        } else if (currentDecoder.int64AsNumber) {
          n = dataView.getUint32(position$1) * 4294967296;
          n += dataView.getUint32(position$1 + 4);
        } else n = dataView.getBigUint64(position$1);
        position$1 += 8;
        break;
      case 31:
        switch (i) {
          case 2:
          case 3:
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            let e75 = [];
            let t2, r = 0;
            while ((t2 = read()) != STOP_CODE) {
              if (r >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`);
              e75[r++] = t2;
            }
            return i == 4 ? e75 : i == 3 ? e75.join("") : Buffer.concat(e75);
          case 5:
            let n2;
            if (currentDecoder.mapsAsObjects) {
              let e76 = {};
              let t3 = 0;
              if (currentDecoder.keyMap) {
                while ((n2 = read()) != STOP_CODE) {
                  if (t3++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`);
                  e76[safeKey(currentDecoder.decodeKey(n2))] = read();
                }
              } else {
                while ((n2 = read()) != STOP_CODE) {
                  if (t3++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`);
                  e76[safeKey(n2)] = read();
                }
              }
              return e76;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let t3 = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap) {
                let e76 = 0;
                while ((n2 = read()) != STOP_CODE) {
                  if (e76++ >= maxMapSize) {
                    throw new Error(`Map size exceeds ${maxMapSize}`);
                  }
                  t3.set(currentDecoder.decodeKey(n2), read());
                }
              } else {
                let e76 = 0;
                while ((n2 = read()) != STOP_CODE) {
                  if (e76++ >= maxMapSize) {
                    throw new Error(`Map size exceeds ${maxMapSize}`);
                  }
                  t3.set(n2, read());
                }
              }
              return t3;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + i);
        }
      default:
        throw new Error("Unknown token " + n);
    }
  }
  switch (i) {
    case 0:
      return n;
    case 1:
      return ~n;
    case 2:
      return readBin(n);
    case 3:
      if (srcStringEnd >= position$1) {
        return srcString.slice(position$1 - srcStringStart, (position$1 += n) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && n < 32) {
        let e76 = n < 16 ? shortStringInJS(n) : longStringInJS(n);
        if (e76 != null) return e76;
      }
      return readFixedString(n);
    case 4:
      if (n >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`);
      let t2 = new Array(n);
      for (let e76 = 0; e76 < n; e76++) t2[e76] = read();
      return t2;
    case 5:
      if (n >= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`);
      if (currentDecoder.mapsAsObjects) {
        let t3 = {};
        if (currentDecoder.keyMap) for (let e76 = 0; e76 < n; e76++) t3[safeKey(currentDecoder.decodeKey(read()))] = read();
        else for (let e76 = 0; e76 < n; e76++) t3[safeKey(read())] = read();
        return t3;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let t3 = /* @__PURE__ */ new Map();
        if (currentDecoder.keyMap) for (let e76 = 0; e76 < n; e76++) t3.set(currentDecoder.decodeKey(read()), read());
        else for (let e76 = 0; e76 < n; e76++) t3.set(read(), read());
        return t3;
      }
    case 6:
      if (n >= BUNDLED_STRINGS_ID) {
        let e76 = currentStructures[n & 8191];
        if (e76) {
          if (!e76.read) e76.read = createStructureReader(e76);
          return e76.read();
        }
        if (n < 65536) {
          if (n == RECORD_INLINE_ID) {
            let e77 = readJustLength();
            let t3 = read();
            let r = read();
            recordDefinition(t3, r);
            let n2 = {};
            if (currentDecoder.keyMap) for (let t4 = 2; t4 < e77; t4++) {
              let e78 = currentDecoder.decodeKey(r[t4 - 2]);
              n2[safeKey(e78)] = read();
            }
            else for (let t4 = 2; t4 < e77; t4++) {
              let e78 = r[t4 - 2];
              n2[safeKey(e78)] = read();
            }
            return n2;
          } else if (n == RECORD_DEFINITIONS_ID) {
            let t3 = readJustLength();
            let r = read();
            for (let e77 = 2; e77 < t3; e77++) {
              recordDefinition(r++, read());
            }
            return read();
          } else if (n == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            e76 = currentStructures[n & 8191];
            if (e76) {
              if (!e76.read) e76.read = createStructureReader(e76);
              return e76.read();
            }
          }
        }
      }
      let e75 = currentExtensions[n];
      if (e75) {
        if (e75.handlesRead) return e75(read);
        else return e75(read());
      } else {
        let r = read();
        for (let t3 = 0; t3 < currentExtensionRanges.length; t3++) {
          let e76 = currentExtensionRanges[t3](n, r);
          if (e76 !== void 0) return e76;
        }
        return new Tag(r, n);
      }
    case 7:
      switch (n) {
        case 20:
          return false;
        case 21:
          return true;
        case 22:
          return null;
        case 23:
          return;
        case 31:
        default:
          let e76 = (packedValues || getPackedValues())[n];
          if (e76 !== void 0) return e76;
          throw new Error("Unknown token " + n);
      }
    default:
      if (isNaN(n)) {
        let e76 = new Error("Unexpected end of CBOR data");
        e76.incomplete = true;
        throw e76;
      }
      throw new Error("Unknown CBOR token " + n);
  }
}
function createStructureReader(e75) {
  if (!e75) throw new Error("Structure is required in record definition");
  function t2() {
    let t3 = src[position$1++];
    t3 = t3 & 31;
    if (t3 > 23) {
      switch (t3) {
        case 24:
          t3 = src[position$1++];
          break;
        case 25:
          t3 = dataView.getUint16(position$1);
          position$1 += 2;
          break;
        case 26:
          t3 = dataView.getUint32(position$1);
          position$1 += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src[position$1 - 1]);
      }
    }
    let r = this.compiledReader;
    while (r) {
      if (r.propertyCount === t3) return r(read);
      r = r.next;
    }
    if (this.slowReads++ >= inlineObjectReadThreshold) {
      let e76 = this.length == t3 ? this : this.slice(0, t3);
      r = currentDecoder.keyMap ? new Function("r", "return {" + e76.map((e77) => currentDecoder.decodeKey(e77)).map((e77) => validName.test(e77) ? safeKey(e77) + ":r()" : "[" + JSON.stringify(e77) + "]:r()").join(",") + "}") : new Function("r", "return {" + e76.map((e77) => validName.test(e77) ? safeKey(e77) + ":r()" : "[" + JSON.stringify(e77) + "]:r()").join(",") + "}");
      if (this.compiledReader) r.next = this.compiledReader;
      r.propertyCount = t3;
      this.compiledReader = r;
      return r(read);
    }
    let n = {};
    if (currentDecoder.keyMap) for (let e76 = 0; e76 < t3; e76++) n[safeKey(currentDecoder.decodeKey(this[e76]))] = read();
    else for (let e76 = 0; e76 < t3; e76++) {
      n[safeKey(this[e76])] = read();
    }
    return n;
  }
  e75.slowReads = 0;
  return t2;
}
function safeKey(e75) {
  if (typeof e75 === "string") return e75 === "__proto__" ? "__proto_" : e75;
  if (typeof e75 === "number" || typeof e75 === "boolean" || typeof e75 === "bigint") return e75.toString();
  if (e75 == null) return e75 + "";
  throw new Error("Invalid property name type " + typeof e75);
}
function readStringJS(e75) {
  let t2;
  if (e75 < 16) {
    if (t2 = shortStringInJS(e75)) return t2;
  }
  if (e75 > 64 && decoder) return decoder.decode(src.subarray(position$1, position$1 += e75));
  const r = position$1 + e75;
  const n = [];
  t2 = "";
  while (position$1 < r) {
    const i = src[position$1++];
    if ((i & 128) === 0) {
      n.push(i);
    } else if ((i & 224) === 192) {
      const a = src[position$1++] & 63;
      n.push((i & 31) << 6 | a);
    } else if ((i & 240) === 224) {
      const a = src[position$1++] & 63;
      const o = src[position$1++] & 63;
      n.push((i & 31) << 12 | a << 6 | o);
    } else if ((i & 248) === 240) {
      const a = src[position$1++] & 63;
      const o = src[position$1++] & 63;
      const u = src[position$1++] & 63;
      let e76 = (i & 7) << 18 | a << 12 | o << 6 | u;
      if (e76 > 65535) {
        e76 -= 65536;
        n.push(e76 >>> 10 & 1023 | 55296);
        e76 = 56320 | e76 & 1023;
      }
      n.push(e76);
    } else {
      n.push(i);
    }
    if (n.length >= 4096) {
      t2 += fromCharCode.apply(String, n);
      n.length = 0;
    }
  }
  if (n.length > 0) {
    t2 += fromCharCode.apply(String, n);
  }
  return t2;
}
function longStringInJS(t2) {
  let r = position$1;
  let n = new Array(t2);
  for (let e75 = 0; e75 < t2; e75++) {
    const i = src[position$1++];
    if ((i & 128) > 0) {
      position$1 = r;
      return;
    }
    n[e75] = i;
  }
  return fromCharCode.apply(String, n);
}
function shortStringInJS(h) {
  if (h < 4) {
    if (h < 2) {
      if (h === 0) return "";
      else {
        let e75 = src[position$1++];
        if ((e75 & 128) > 1) {
          position$1 -= 1;
          return;
        }
        return fromCharCode(e75);
      }
    } else {
      let e75 = src[position$1++];
      let t2 = src[position$1++];
      if ((e75 & 128) > 0 || (t2 & 128) > 0) {
        position$1 -= 2;
        return;
      }
      if (h < 3) return fromCharCode(e75, t2);
      let r = src[position$1++];
      if ((r & 128) > 0) {
        position$1 -= 3;
        return;
      }
      return fromCharCode(e75, t2, r);
    }
  } else {
    let f = src[position$1++];
    let _ = src[position$1++];
    let p = src[position$1++];
    let d = src[position$1++];
    if ((f & 128) > 0 || (_ & 128) > 0 || (p & 128) > 0 || (d & 128) > 0) {
      position$1 -= 4;
      return;
    }
    if (h < 6) {
      if (h === 4) return fromCharCode(f, _, p, d);
      else {
        let e75 = src[position$1++];
        if ((e75 & 128) > 0) {
          position$1 -= 5;
          return;
        }
        return fromCharCode(f, _, p, d, e75);
      }
    } else if (h < 8) {
      let e75 = src[position$1++];
      let t2 = src[position$1++];
      if ((e75 & 128) > 0 || (t2 & 128) > 0) {
        position$1 -= 6;
        return;
      }
      if (h < 7) return fromCharCode(f, _, p, d, e75, t2);
      let r = src[position$1++];
      if ((r & 128) > 0) {
        position$1 -= 7;
        return;
      }
      return fromCharCode(f, _, p, d, e75, t2, r);
    } else {
      let u = src[position$1++];
      let s = src[position$1++];
      let c = src[position$1++];
      let l = src[position$1++];
      if ((u & 128) > 0 || (s & 128) > 0 || (c & 128) > 0 || (l & 128) > 0) {
        position$1 -= 8;
        return;
      }
      if (h < 10) {
        if (h === 8) return fromCharCode(f, _, p, d, u, s, c, l);
        else {
          let e75 = src[position$1++];
          if ((e75 & 128) > 0) {
            position$1 -= 9;
            return;
          }
          return fromCharCode(f, _, p, d, u, s, c, l, e75);
        }
      } else if (h < 12) {
        let e75 = src[position$1++];
        let t2 = src[position$1++];
        if ((e75 & 128) > 0 || (t2 & 128) > 0) {
          position$1 -= 10;
          return;
        }
        if (h < 11) return fromCharCode(f, _, p, d, u, s, c, l, e75, t2);
        let r = src[position$1++];
        if ((r & 128) > 0) {
          position$1 -= 11;
          return;
        }
        return fromCharCode(f, _, p, d, u, s, c, l, e75, t2, r);
      } else {
        let n = src[position$1++];
        let i = src[position$1++];
        let a = src[position$1++];
        let o = src[position$1++];
        if ((n & 128) > 0 || (i & 128) > 0 || (a & 128) > 0 || (o & 128) > 0) {
          position$1 -= 12;
          return;
        }
        if (h < 14) {
          if (h === 12) return fromCharCode(f, _, p, d, u, s, c, l, n, i, a, o);
          else {
            let e75 = src[position$1++];
            if ((e75 & 128) > 0) {
              position$1 -= 13;
              return;
            }
            return fromCharCode(f, _, p, d, u, s, c, l, n, i, a, o, e75);
          }
        } else {
          let e75 = src[position$1++];
          let t2 = src[position$1++];
          if ((e75 & 128) > 0 || (t2 & 128) > 0) {
            position$1 -= 14;
            return;
          }
          if (h < 15) return fromCharCode(f, _, p, d, u, s, c, l, n, i, a, o, e75, t2);
          let r = src[position$1++];
          if ((r & 128) > 0) {
            position$1 -= 15;
            return;
          }
          return fromCharCode(f, _, p, d, u, s, c, l, n, i, a, o, e75, t2, r);
        }
      }
    }
  }
}
function readBin(e75) {
  return currentDecoder.copyBuffers ? Uint8Array.prototype.slice.call(src, position$1, position$1 += e75) : src.subarray(position$1, position$1 += e75);
}
function getFloat16() {
  let t2 = src[position$1++];
  let r = src[position$1++];
  let e75 = (t2 & 127) >> 2;
  if (e75 === 31) {
    if (r || t2 & 3) return NaN;
    return t2 & 128 ? -Infinity : Infinity;
  }
  if (e75 === 0) {
    let e76 = ((t2 & 3) << 8 | r) / (1 << 24);
    return t2 & 128 ? -e76 : e76;
  }
  u8Array[3] = t2 & 128 | (e75 >> 1) + 56;
  u8Array[2] = (t2 & 7) << 5 | r >> 3;
  u8Array[1] = r << 5;
  u8Array[0] = 0;
  return f32Array[0];
}
function combine(e75, t2) {
  if (typeof e75 === "string") return e75 + t2;
  if (e75 instanceof Array) return e75.concat(t2);
  return Object.assign({}, e75, t2);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared) loadShared();
    else throw new Error("No packed values available");
  }
  return packedValues;
}
function registerTypedArray(u, s) {
  let c = "get" + u.name.slice(0, -5);
  let t2;
  if (typeof u === "function") t2 = u.BYTES_PER_ELEMENT;
  else u = null;
  for (let o = 0; o < 2; o++) {
    if (!o && t2 == 1) continue;
    let a = t2 == 2 ? 1 : t2 == 4 ? 2 : t2 == 8 ? 3 : 0;
    currentExtensions[o ? s : s - 4] = t2 == 1 || o == isLittleEndianMachine$1 ? (e75) => {
      if (!u) throw new Error("Could not find typed array for code " + s);
      if (!currentDecoder.copyBuffers) {
        if (t2 === 1 || t2 === 2 && !(e75.byteOffset & 1) || t2 === 4 && !(e75.byteOffset & 3) || t2 === 8 && !(e75.byteOffset & 7)) return new u(e75.buffer, e75.byteOffset, e75.byteLength >> a);
      }
      return new u(Uint8Array.prototype.slice.call(e75, 0).buffer);
    } : (e75) => {
      if (!u) throw new Error("Could not find typed array for code " + s);
      let t3 = new DataView(e75.buffer, e75.byteOffset, e75.byteLength);
      let r = e75.length >> a;
      let n = new u(r);
      let i = t3[c];
      for (let e76 = 0; e76 < r; e76++) {
        n[e76] = i.call(t3, e76 << a, o);
      }
      return n;
    };
  }
}
function readBundleExt() {
  let t2 = readJustLength();
  let e75 = position$1 + read();
  for (let e76 = 2; e76 < t2; e76++) {
    let e77 = readJustLength();
    position$1 += e77;
  }
  let r = position$1;
  position$1 = e75;
  bundledStrings$1 = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings$1.position0 = 0;
  bundledStrings$1.position1 = 0;
  bundledStrings$1.postBundlePosition = position$1;
  position$1 = r;
  return read();
}
function readJustLength() {
  let e75 = src[position$1++] & 31;
  if (e75 > 23) {
    switch (e75) {
      case 24:
        e75 = src[position$1++];
        break;
      case 25:
        e75 = dataView.getUint16(position$1);
        position$1 += 2;
        break;
      case 26:
        e75 = dataView.getUint32(position$1);
        position$1 += 4;
        break;
    }
  }
  return e75;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let e75 = saveState(() => {
      src = null;
      return currentDecoder.getShared();
    }) || {};
    let t2 = e75.structures || [];
    currentDecoder.sharedVersion = e75.version;
    packedValues = currentDecoder.sharedValues = e75.packedValues;
    if (currentStructures === true) currentDecoder.structures = currentStructures = t2;
    else currentStructures.splice.apply(currentStructures, [0, t2.length].concat(t2));
  }
}
function saveState(e75) {
  let t2 = srcEnd;
  let r = position$1;
  let n = srcStringStart;
  let i = srcStringEnd;
  let a = srcString;
  let o = referenceMap;
  let u = bundledStrings$1;
  let s = new Uint8Array(src.slice(0, srcEnd));
  let c = currentStructures;
  let l = currentDecoder;
  let f = sequentialMode;
  let _ = e75();
  srcEnd = t2;
  position$1 = r;
  srcStringStart = n;
  srcStringEnd = i;
  srcString = a;
  referenceMap = o;
  bundledStrings$1 = u;
  src = s;
  sequentialMode = f;
  currentStructures = c;
  currentDecoder = l;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return _;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
function addExtension$1(e75) {
  currentExtensions[e75.tag] = e75.decode;
}
function writeEntityLength(e75, t2) {
  if (e75 < 24) target[position++] = t2 | e75;
  else if (e75 < 256) {
    target[position++] = t2 | 24;
    target[position++] = e75;
  } else if (e75 < 65536) {
    target[position++] = t2 | 25;
    target[position++] = e75 >> 8;
    target[position++] = e75 & 255;
  } else {
    target[position++] = t2 | 26;
    targetView.setUint32(position, e75);
    position += 4;
  }
}
function writeArrayHeader(e75) {
  if (e75 < 24) target[position++] = 128 | e75;
  else if (e75 < 256) {
    target[position++] = 152;
    target[position++] = e75;
  } else if (e75 < 65536) {
    target[position++] = 153;
    target[position++] = e75 >> 8;
    target[position++] = e75 & 255;
  } else {
    target[position++] = 154;
    targetView.setUint32(position, e75);
    position += 4;
  }
}
function isBlob(e75) {
  if (e75 instanceof BlobConstructor) return true;
  let t2 = e75[Symbol.toStringTag];
  return t2 === "Blob" || t2 === "File";
}
function findRepetitiveStrings(r, n) {
  switch (typeof r) {
    case "string":
      if (r.length > 3) {
        if (n.objectMap[r] > -1 || n.values.length >= n.maxValues) return;
        let e75 = n.get(r);
        if (e75) {
          if (++e75.count == 2) {
            n.values.push(r);
          }
        } else {
          n.set(r, { count: 1 });
          if (n.samplingPackedValues) {
            let e76 = n.samplingPackedValues.get(r);
            if (e76) e76.count++;
            else n.samplingPackedValues.set(r, { count: 1 });
          }
        }
      }
      break;
    case "object":
      if (r) {
        if (r instanceof Array) {
          for (let e75 = 0, t3 = r.length; e75 < t3; e75++) {
            findRepetitiveStrings(r[e75], n);
          }
        } else {
          let e75 = !n.encoder.useRecords;
          for (var t2 in r) {
            if (r.hasOwnProperty(t2)) {
              if (e75) findRepetitiveStrings(t2, n);
              findRepetitiveStrings(r[t2], n);
            }
          }
        }
      }
      break;
    case "function":
      console.log(r);
  }
}
function typedArrayEncoder(e75, t2) {
  if (!isLittleEndianMachine && t2 > 1) e75 -= 4;
  return { tag: e75, encode: function e76(t3, r) {
    let n = t3.byteLength;
    let i = t3.byteOffset || 0;
    let a = t3.buffer || t3;
    r(hasNodeBuffer ? Buffer$1.from(a, i, n) : new Uint8Array(a, i, n));
  } };
}
function writeBuffer(e75, t2) {
  let r = e75.byteLength;
  if (r < 24) {
    target[position++] = 64 + r;
  } else if (r < 256) {
    target[position++] = 88;
    target[position++] = r;
  } else if (r < 65536) {
    target[position++] = 89;
    target[position++] = r >> 8;
    target[position++] = r & 255;
  } else {
    target[position++] = 90;
    targetView.setUint32(position, r);
    position += 4;
  }
  if (position + r >= target.length) {
    t2(position + r);
  }
  target.set(e75.buffer ? e75 : new Uint8Array(e75), position);
  position += r;
}
function insertIds(n, e75) {
  let r;
  let i = e75.length * 2;
  let a = n.length - i;
  e75.sort((e76, t2) => e76.offset > t2.offset ? 1 : -1);
  for (let r2 = 0; r2 < e75.length; r2++) {
    let t2 = e75[r2];
    t2.id = r2;
    for (let e76 of t2.references) {
      n[e76++] = r2 >> 8;
      n[e76] = r2 & 255;
    }
  }
  while (r = e75.pop()) {
    let e76 = r.offset;
    n.copyWithin(e76 + i, e76, a);
    i -= 2;
    let t2 = e76 + i;
    n[t2++] = 216;
    n[t2++] = 28;
    a = e76;
  }
  return n;
}
function writeBundles(e75, t2) {
  targetView.setUint32(bundledStrings.position + e75, position - bundledStrings.position - e75 + 1);
  let r = bundledStrings;
  bundledStrings = null;
  t2(r[0]);
  t2(r[1]);
}
function addExtension(e75) {
  if (e75.Class) {
    if (!e75.encode) throw new Error("Extension has no encode function");
    extensionClasses.unshift(e75.Class);
    extensions.unshift(e75);
  }
  addExtension$1(e75);
}
function requireLzjbPack() {
  if (hasRequiredLzjbPack) return lzjbPack;
  hasRequiredLzjbPack = 1;
  Object.defineProperty(lzjbPack, "__esModule", { value: true });
  const p = 8, d = 6, h = 3, m = (1 << d) + (h - 1), y = (1 << 16 - d) - 1, v = 256;
  function o(e76, t3) {
    var r2 = 0, n = 0, i = 0, a = 0, o2 = 0, u2 = 1 << p - 1, s2 = 0, c2 = 0, l2 = 0, f2 = new Int32Array(v), _2 = 0;
    for (_2 = 0; _2 < v; _2++) {
      f2[_2] = -858993460;
    }
    r2 = e76.length;
    while (n < r2) {
      if ((u2 <<= 1) == 1 << p) {
        u2 = 1;
        o2 = i;
        t3[i++] = 0;
      }
      if (n > r2 - m) {
        t3[i++] = e76[n++];
        continue;
      }
      l2 = (e76[n] + 13 ^ e76[n + 1] - 13 ^ e76[n + 2]) & v - 1;
      c2 = n - f2[l2] & y;
      f2[l2] = n;
      a = n - c2;
      if (a >= 0 && a != n && e76[n] == e76[a] && e76[n + 1] == e76[a + 1] && e76[n + 2] == e76[a + 2]) {
        t3[o2] |= u2;
        for (s2 = h; s2 < m; s2++) if (e76[n + s2] != e76[a + s2]) break;
        t3[i++] = s2 - h << p - d | c2 >> p;
        t3[i++] = c2;
        n += s2;
      } else {
        t3[i++] = e76[n++];
      }
    }
    console.assert(e76.length >= n);
    return i;
  }
  function c(e76, t3, r2) {
    t3 = t3 | 0;
    var n = 0, i = 0, a = 0, o2 = 0, u2 = 1 << (p - 1 | 0), s2 = 0, c2 = 0;
    while (n < t3) {
      if ((u2 <<= 1) === 1 << p) {
        u2 = 1;
        o2 = e76[n];
        n = n + 1 | 0;
      }
      if (o2 & u2) {
        s2 = (e76[n] >> (p - d | 0)) + h | 0;
        c2 = (e76[n] << p | e76[n + 1 | 0]) & y;
        n = n + 2 | 0;
        a = i - c2 | 0;
        {
          while (s2 > 4) {
            r2[i] = r2[a];
            i = i + 1 | 0;
            a = a + 1 | 0;
            r2[i] = r2[a];
            i = i + 1 | 0;
            a = a + 1 | 0;
            r2[i] = r2[a];
            i = i + 1 | 0;
            a = a + 1 | 0;
            r2[i] = r2[a];
            i = i + 1 | 0;
            a = a + 1 | 0;
            s2 = s2 - 4 | 0;
          }
          while (s2 > 0) {
            r2[i] = r2[a];
            i = i + 1 | 0;
            a = a + 1 | 0;
            s2 = s2 - 1 | 0;
          }
        }
      } else {
        r2[i] = e76[n];
        i = i + 1 | 0;
        n = n + 1 | 0;
      }
    }
    return i;
  }
  function e75() {
    const e76 = new TextEncoder("utf-8");
    return e76.encode(l);
  }
  const l = "@lzjb";
  const f = e75();
  function u(...e76) {
    if (e76.length > 1) {
      const r2 = e76.reduce((e77, t4) => e77 + t4.length, 0);
      const n = new Uint8Array(r2);
      let t3 = 0;
      e76.forEach((e77) => {
        n.set(e77, t3);
        t3 += e77.length;
      });
      return n;
    } else if (e76.length) {
      return e76[0];
    }
  }
  function s(t3) {
    const e76 = Math.ceil(Math.log2(t3) / 8);
    const r2 = new Uint8Array(e76);
    for (let e77 = 0; e77 < r2.length; e77++) {
      const n = t3 & 255;
      r2[e77] = n;
      t3 = (t3 - n) / 256;
    }
    return r2;
  }
  function _(t3) {
    let r2 = 0;
    for (let e76 = t3.length - 1; e76 >= 0; e76--) {
      r2 = r2 * 256 + t3[e76];
    }
    return r2;
  }
  function t2(e76, { magic: t3 = true } = {}) {
    const r2 = new Uint8Array(Math.max(e76.length * 1.5 | 0, 16 * 1024));
    const n = o(e76, r2);
    const i = s(e76.length);
    const a = [Uint8Array.of(i.length), i, r2.slice(0, n)];
    if (t3) {
      a.unshift(f);
    }
    return u(...a);
  }
  function r(t3, { magic: e76 = true } = {}) {
    if (e76) {
      const e77 = new TextDecoder("utf-8");
      const s2 = e77.decode(t3.slice(0, f.length));
      if (s2 !== l) {
        throw new Error("Invalid magic value");
      }
    }
    const r2 = e76 ? f.length : 0;
    const n = t3[r2];
    const i = r2 + 1;
    const a = r2 + n + 1;
    const o2 = _(t3.slice(i, a));
    t3 = t3.slice(a);
    const u2 = new Uint8Array(o2);
    c(t3, t3.length, u2);
    return u2;
  }
  lzjbPack.pack = t2;
  lzjbPack.unpack = r;
  return lzjbPack;
}
function e(u, s) {
  return s = s || {}, new Promise(function(e75, t2) {
    var r = new XMLHttpRequest(), n = [], i = {}, a = function e76() {
      return { ok: 2 == (r.status / 100 | 0), statusText: r.statusText, status: r.status, url: r.responseURL, text: function() {
        return Promise.resolve(r.responseText);
      }, json: function() {
        return Promise.resolve(r.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([r.response]));
      }, clone: e76, headers: { keys: function() {
        return n;
      }, entries: function() {
        return n.map(function(e77) {
          return [e77, r.getResponseHeader(e77)];
        });
      }, get: function(e77) {
        return r.getResponseHeader(e77);
      }, has: function(e77) {
        return null != r.getResponseHeader(e77);
      } } };
    };
    for (var o in r.open(s.method || "get", u, true), r.onload = function() {
      r.getAllResponseHeaders().toLowerCase().replace(/^(.+?):/gm, function(e76, t3) {
        i[t3] || n.push(i[t3] = t3);
      }), e75(a());
    }, r.onerror = t2, r.withCredentials = "include" == s.credentials, s.headers) r.setRequestHeader(o, s.headers[o]);
    r.send(s.body || null);
  });
}
function _classPrivateFieldInitSpec(e75, t2, r) {
  _checkPrivateRedeclaration(e75, t2), t2.set(e75, r);
}
function _checkPrivateRedeclaration(e75, t2) {
  if (t2.has(e75)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet(e75, t2) {
  return e75.get(_assertClassBrand(e75, t2));
}
function _classPrivateFieldSet(e75, t2, r) {
  return e75.set(_assertClassBrand(e75, t2), r), r;
}
function _assertClassBrand(e75, t2, r) {
  if ("function" == typeof e75 ? e75 === t2 : e75.has(t2)) return arguments.length < 3 ? t2 : r;
  throw new TypeError("Private element is not present on this object");
}
function _callSuper(e75, t2, r) {
  return t2 = _getPrototypeOf(t2), _possibleConstructorReturn(e75, _isNativeReflectConstruct() ? Reflect.construct(t2, r || [], _getPrototypeOf(e75).constructor) : t2.apply(e75, r));
}
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = function e75() {
    return !!t2;
  })();
}
function _createForOfIteratorHelper(t2, e75) {
  var r = "undefined" != typeof Symbol && t2[Symbol.iterator] || t2["@@iterator"];
  if (!r) {
    if (Array.isArray(t2) || (r = _unsupportedIterableToArray(t2)) || e75) {
      r && (t2 = r);
      var n = 0, i = function e76() {
      };
      return { s: i, n: function e76() {
        return n >= t2.length ? { done: true } : { done: false, value: t2[n++] };
      }, e: function e76(t3) {
        throw t3;
      }, f: i };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var a, o = true, u = false;
  return { s: function e76() {
    r = r.call(t2);
  }, n: function e76() {
    var t3 = r.next();
    return o = t3.done, t3;
  }, e: function e76(t3) {
    u = true, a = t3;
  }, f: function e76() {
    try {
      o || null == r["return"] || r["return"]();
    } finally {
      if (u) throw a;
    }
  } };
}
function _unsupportedIterableToArray(e75, t2) {
  if (e75) {
    if ("string" == typeof e75) return _arrayLikeToArray(e75, t2);
    var r = {}.toString.call(e75).slice(8, -1);
    return "Object" === r && e75.constructor && (r = e75.constructor.name), "Map" === r || "Set" === r ? Array.from(e75) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? _arrayLikeToArray(e75, t2) : void 0;
  }
}
function _arrayLikeToArray(e75, t2) {
  (null == t2 || t2 > e75.length) && (t2 = e75.length);
  for (var r = 0, n = Array(t2); r < t2; r++) n[r] = e75[r];
  return n;
}
function ownKeys(t2, e75) {
  var r = Object.keys(t2);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t2);
    e75 && (n = n.filter(function(e76) {
      return Object.getOwnPropertyDescriptor(t2, e76).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function _objectSpread(t2) {
  for (var e75 = 1; e75 < arguments.length; e75++) {
    var r = null != arguments[e75] ? arguments[e75] : {};
    e75 % 2 ? ownKeys(Object(r), true).forEach(function(e76) {
      _defineProperty(t2, e76, r[e76]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r)) : ownKeys(Object(r)).forEach(function(e76) {
      Object.defineProperty(t2, e76, Object.getOwnPropertyDescriptor(r, e76));
    });
  }
  return t2;
}
function _asyncIterator(e75) {
  var t2, r, n, i = 2;
  for ("undefined" != typeof Symbol && (r = Symbol.asyncIterator, n = Symbol.iterator); i--; ) {
    if (r && null != (t2 = e75[r])) return t2.call(e75);
    if (n && null != (t2 = e75[n])) return new AsyncFromSyncIterator(t2.call(e75));
    r = "@@asyncIterator", n = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(e75) {
  function n(e76) {
    if (Object(e76) !== e76) return Promise.reject(new TypeError(e76 + " is not an object."));
    var t2 = e76.done;
    return Promise.resolve(e76.value).then(function(e77) {
      return { value: e77, done: t2 };
    });
  }
  return AsyncFromSyncIterator = function e76(t2) {
    this.s = t2, this.n = t2.next;
  }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function e76() {
    return n(this.n.apply(this.s, arguments));
  }, return: function e76(t2) {
    var r = this.s["return"];
    return void 0 === r ? Promise.resolve({ value: t2, done: true }) : n(r.apply(this.s, arguments));
  }, throw: function e76(t2) {
    var r = this.s["return"];
    return void 0 === r ? Promise.reject(t2) : n(r.apply(this.s, arguments));
  } }, new AsyncFromSyncIterator(e75);
}
function contentLoaded(r, n) {
  var i = false, e75 = true, a = r.document, t2 = a.documentElement, o = a.addEventListener, u = o ? "addEventListener" : "attachEvent", s = o ? "removeEventListener" : "detachEvent", c = o ? "" : "on", l = function e76(t3) {
    if (t3.type == "readystatechange" && a.readyState != "complete") return;
    (t3.type == "load" ? r : a)[s](c + t3.type, l, false);
    if (!i && (i = true)) n.call(r, t3.type || t3);
  }, f = function e76() {
    try {
      t2.doScroll("left");
    } catch (e77) {
      setTimeout(f, 50);
      return;
    }
    l("poll");
  };
  if (a.readyState == "complete") n.call(r, "lazy");
  else {
    if (!o && t2.doScroll) {
      try {
        e75 = !r.frameElement;
      } catch (e76) {
      }
      if (e75) f();
    }
    a[u](c + "DOMContentLoaded", l, false);
    a[u](c + "readystatechange", l, false);
    r[u](c + "load", l, false);
  }
}
function log(e75) {
  for (var t2 = arguments.length, r = new Array(t2 > 1 ? t2 - 1 : 0), n = 1; n < t2; n++) {
    r[n - 1] = arguments[n];
  }
  if (is_plain_object(e75) && is_debug(r[0])) {
    console.log(map_object(e75, function(e76) {
      return to_string(e76, true);
    }));
  } else if (is_debug()) {
    var i;
    (i = console).log.apply(i, [to_string(e75, true)].concat(_toConsumableArray(r.map(function(e76) {
      return to_string(e76, true);
    }))));
  }
}
function is_debug() {
  var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
  var t2 = user_env && user_env.get("DEBUG", { throwError: false });
  if (e75 === null) {
    return t2 === true;
  }
  return (t2 === null || t2 === void 0 ? void 0 : t2.valueOf()) === e75.valueOf();
}
function num_mnemicic_re(e75) {
  return e75 ? "(?:#".concat(e75, "(?:#[ie])?|#[ie]#").concat(e75, ")") : "(?:#[ie])?";
}
function gen_rational_re(e75, t2) {
  return "".concat(num_mnemicic_re(e75), "[+-]?").concat(t2, "+/").concat(t2, "+");
}
function gen_complex_re(e75, t2) {
  return "".concat(num_mnemicic_re(e75), "(?:[+-]?(?:").concat(t2, "+/").concat(t2, "+|nan.0|inf.0|").concat(t2, "+))?(?:[+-]i|[+-]?(?:").concat(t2, "+/").concat(t2, "+|").concat(t2, "+|nan.0|inf.0)i)(?=[()[\\]\\s]|$)");
}
function gen_integer_re(e75, t2) {
  return "".concat(num_mnemicic_re(e75), "[+-]?").concat(t2, "+");
}
function make_complex_match_re(e75, t2) {
  var r = e75 === "x" ? "(?!\\+|".concat(t2, ")") : "(?!\\.|".concat(t2, ")");
  var n = "";
  if (e75 === "") {
    n = "(?:[-+]?(?:[0-9]+(?:[eE][-+]?[0-9]+)|(?:\\.[0-9]+|[0-9]+\\.[0-9]+(?![0-9]))(?:[eE][-+]?[0-9]+)?))";
  }
  return new RegExp("^((?:(?:".concat(n, "|[-+]?inf.0|[-+]?nan.0|[+-]?").concat(t2, "+/").concat(t2, "+(?!").concat(t2, ")|[+-]?").concat(t2, "+)").concat(r, ")?)(").concat(n, "|[-+]?inf.0|[-+]?nan.0|[+-]?").concat(t2, "+/").concat(t2, "+|[+-]?").concat(t2, "+|[+-])i$"), "i");
}
function ucs2decode(e75) {
  var t2 = [];
  var r = 0;
  var n = e75.length;
  while (r < n) {
    var i = e75.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      var a = e75.charCodeAt(r++);
      if ((a & 64512) === 56320) {
        t2.push(((i & 1023) << 10) + (a & 1023) + 65536);
      } else {
        t2.push(i);
        r--;
      }
    } else {
      t2.push(i);
    }
  }
  return t2;
}
function make_num_stre(i) {
  var e75 = [["o", "[0-7]"], ["x", "[0-9a-fA-F]"], ["b", "[01]"], ["d", "[0-9]"], ["", "[0-9]"]];
  var t2 = e75.map(function(e76) {
    var t3 = _slicedToArray(e76, 2), r = t3[0], n = t3[1];
    return i(r, n);
  }).join("|");
  if (i === gen_complex_re) {
    t2 = complex_float_stre + "|" + t2;
  }
  return t2;
}
function make_type_re(e75) {
  return new RegExp("^(?:" + make_num_stre(e75) + ")$", "i");
}
function num_pre_parse(e75) {
  var t2 = e75.match(pre_num_parse_re);
  var r = {};
  if (t2[1]) {
    var n = t2[1].replace(/#/g, "").toLowerCase().split("");
    if (n.includes("x")) {
      r.radix = 16;
    } else if (n.includes("o")) {
      r.radix = 8;
    } else if (n.includes("b")) {
      r.radix = 2;
    } else if (n.includes("d")) {
      r.radix = 10;
    }
    if (n.includes("i")) {
      r.inexact = true;
    }
    if (n.includes("e")) {
      r.exact = true;
    }
  }
  r.number = t2[2];
  return r;
}
function parse_rational(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
  var r = num_pre_parse(e75);
  var n = r.number.split("/");
  var i = LRational({ num: LNumber([n[0], r.radix || t2]), denom: LNumber([n[1], r.radix || t2]) });
  if (r.inexact) {
    return i.valueOf();
  } else {
    return i;
  }
}
function parse_integer(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
  var r = num_pre_parse(e75);
  if (r.inexact) {
    return LFloat(parseInt(r.number, r.radix || t2));
  }
  return LNumber([r.number, r.radix || t2]);
}
function parse_character(e75) {
  var t2 = e75.match(/#\\x([0-9a-f]+)$/i);
  var r;
  if (t2) {
    var n = parseInt(t2[1], 16);
    r = String.fromCodePoint(n);
  } else {
    t2 = e75.match(/#\\([\s\S]+)$/);
    if (t2) {
      r = t2[1];
    }
  }
  if (r) {
    return LCharacter(r);
  }
  throw new Error("Parse: invalid character");
}
function parse_complex(e75) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
  function t2(e76) {
    var t3;
    if (e76 === "+") {
      t3 = LNumber(1);
    } else if (e76 === "-") {
      t3 = LNumber(-1);
    } else if (e76.match(int_bare_re)) {
      t3 = LNumber([e76, i]);
    } else if (e76.match(rational_bare_re)) {
      var r2 = e76.split("/");
      t3 = LRational({ num: LNumber([r2[0], i]), denom: LNumber([r2[1], i]) });
    } else if (e76.match(float_re)) {
      var n2 = parse_float(e76);
      if (a.exact) {
        return n2.toRational();
      }
      return n2;
    } else if (e76.match(/nan.0$/)) {
      return LNumber(NaN);
    } else if (e76.match(/inf.0$/)) {
      if (e76[0] === "-") {
        return LNumber(Number.NEGATIVE_INFINITY);
      }
      return LNumber(Number.POSITIVE_INFINITY);
    } else {
      throw new Error("Internal Parser Error");
    }
    if (a.inexact) {
      return LFloat(t3.valueOf());
    }
    return t3;
  }
  var a = num_pre_parse(e75);
  i = a.radix || i;
  var r;
  var n = a.number.match(complex_bare_match_re);
  if (i !== 10 && n) {
    r = n;
  } else {
    r = a.number.match(complex_list_re[i]);
  }
  var o, u;
  u = t2(r[2]);
  if (r[1]) {
    o = t2(r[1]);
  } else if (u instanceof LFloat) {
    o = LFloat(0);
  } else {
    o = LNumber(0);
  }
  if (u.cmp(0) === 0 && u.__type__ === "bigint") {
    return o;
  }
  return LComplex({ im: u, re: o });
}
function is_int(e75) {
  return parseInt(e75.toString(), 10) === e75;
}
function parse_big_int(e75) {
  var t2 = e75.match(/^(([-+]?[0-9]*)(?:\.([0-9]+))?)e([-+]?[0-9]+)/i);
  if (t2) {
    var r = parseInt(t2[4], 10);
    var n;
    var i = t2[1].replace(/[-+]?([0-9]*)\..+$/, "$1").length;
    var a = t2[3] && t2[3].length;
    if (i < Math.abs(r)) {
      n = LNumber([t2[1].replace(/\./, ""), 10]);
      if (a) {
        r -= a;
      }
    }
  }
  return { exponent: r, mantisa: n };
}
function string_to_float(e75) {
  if (e75.match(/e/i)) {
    var t2 = e75.split("e"), r = _slicedToArray(t2, 2), n = r[0], i = r[1];
    var a = Math.abs(parseInt(i));
    if (a < 7 && i < 0) {
      var o = "0".repeat(a - 1);
      var u = n[0] === "-" ? "-" : "+";
      var s = n.replace(/(^[-+])|\./g, "");
      var c = "".concat(u, "0.").concat(o).concat(s);
      return parseFloat(c);
    }
  }
  return parseFloat(e75);
}
function parse_float(e75) {
  var t2 = num_pre_parse(e75);
  var r = string_to_float(t2.number);
  var n = (t2.number.match(/\.0$/) || !t2.number.match(/\./)) && !t2.number.match(/e/i);
  if (!t2.inexact) {
    if (t2.exact && n) {
      return LNumber(r);
    }
    if (is_int(r) && Number.isSafeInteger(r) && t2.number.match(/e\+?[0-9]/i)) {
      return LNumber(r);
    }
    var i = parse_big_int(t2.number), a = i.mantisa, o = i.exponent;
    if (a !== void 0 && o !== void 0) {
      var u = LNumber(10).pow(LNumber(Math.abs(o)));
      if (t2.exact && o < 0) {
        return LRational({ num: a, denom: u });
      } else if (o > 0 && (t2.exact || !t2.number.match(/\./))) {
        return LNumber(a).mul(u);
      }
    }
  }
  r = LFloat(r);
  if (t2.exact) {
    return r.toRational();
  }
  return r;
}
function parse_string(e75) {
  e75 = e75.replace(/\\x([0-9a-f]+);/gi, function(e76, t3) {
    return "\\u" + t3.padStart(4, "0");
  }).replace(/\n/g, "\\n");
  var t2 = e75.match(/(\\*)(\\x[0-9A-F])/i);
  if (t2 && t2[1].length % 2 === 0) {
    throw new Error("Invalid string literal, unclosed ".concat(t2[2]));
  }
  try {
    var r = LString(JSON.parse(e75));
    r.freeze();
    return r;
  } catch (e76) {
    var n = e76.message.replace(/in JSON /, "").replace(/.*Error: /, "");
    throw new Error("Invalid string literal: ".concat(n));
  }
}
function parse_symbol(e75) {
  e75.match(/^name/);
  var t2 = /(^|.)\|/g;
  if (e75.match(t2)) {
    e75 = e75.split("|").filter(Boolean).reduce(function(e76, t3) {
      var r2 = "";
      if (t3.match(/^\\+$/)) {
        if (t3.length > 1) {
          var n = Math.floor(t3.length / 2);
          r2 = "\\".repeat(n);
        }
        if (t3.length % 2 !== 0) {
          r2 += "|";
        }
      } else {
        r2 = t3;
      }
      return e76 + r2;
    });
    var r = { t: "	", r: "\r", n: "\n" };
    e75 = e75.replace(/\\(x[^;]+);/g, function(e76, t3) {
      return String.fromCharCode(parseInt("0" + t3, 16));
    }).replace(/\\([trn])/g, function(e76, t3) {
      return r[t3];
    });
  }
  return new LSymbol(e75);
}
function parse_argument(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var r = e75.token;
  if (constants.hasOwnProperty(r)) {
    return constants[r];
  }
  var n;
  if (r.match(/^"[\s\S]*"$/)) {
    n = parse_string(r);
  } else if (r[0] === "#") {
    var i = r.match(re_re);
    if (i) {
      n = new RegExp(i[1], i[2]);
    } else if (r.match(char_re)) {
      n = parse_character(r);
    }
    var a = r.match(/#\\(.+)/);
    if (a && ucs2decode(a[1]).length === 1) {
      n = parse_character(r);
    }
  }
  if (r.match(/[0-9a-f]|[+-]i/i)) {
    if (r.match(int_re)) {
      n = parse_integer(r);
    } else if (r.match(float_re)) {
      n = parse_float(r);
    } else if (r.match(rational_re)) {
      n = parse_rational(r);
    } else if (r.match(complex_re)) {
      n = parse_complex(r);
    }
  }
  if (!n && r.match(/^#[iexobd]/)) {
    throw new Error("Invalid numeric constant: " + e75);
  }
  if (!n) {
    n = parse_symbol(r);
  }
  if (t2) {
    var o = e75.col, u = e75.offset, s = e75.line;
    read_only(n, "__col__", o);
    read_only(n, "__offset__", u);
    read_only(n, "__line__", s);
  }
  return n;
}
function is_atom_string(e75) {
  return !(["(", ")", "[", "]"].includes(e75) || specials.names().includes(e75));
}
function is_symbol_string(e75) {
  return is_atom_string(e75) && !(e75.match(re_re) || e75.match(/^"[\s\S]*"$/) || e75.match(int_re) || e75.match(float_re) || e75.match(complex_re) || e75.match(rational_re) || e75.match(char_re) || ["#t", "#f", "nil"].includes(e75));
}
function escape_regex(e75) {
  if (typeof e75 === "string") {
    var t2 = /([-\\^$[\]()+{}?*.|])/g;
    return e75.replace(t2, "\\$1");
  }
  return e75;
}
function Stack() {
  this.data = [];
}
function tokens(e75) {
  if (e75 instanceof LString) {
    e75 = e75.valueOf();
  }
  var t2 = new Lexer(e75, { whitespace: true });
  var r = [];
  while (true) {
    var n = t2.peek(true);
    if (n === eof) {
      break;
    }
    r.push(n);
    t2.skip();
  }
  return r;
}
function multiline_formatter(e75) {
  var t2 = e75.token, r = _objectWithoutProperties(e75, _excluded);
  if (t2.match(/^"[\s\S]*"$/) && t2.match(/\n/)) {
    var n = new RegExp("^ {1," + (e75.col + 1) + "}", "mg");
    t2 = t2.replace(n, "");
  }
  return _objectSpread({ token: t2 }, r);
}
function Thunk(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
  };
  this.fn = e75;
  this.cont = t2;
}
function trampoline(n) {
  return function() {
    for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
      t2[r] = arguments[r];
    }
    return unwind(n.apply(this, t2));
  };
}
function unwind(e75) {
  while (e75 instanceof Thunk) {
    var t2 = e75;
    e75 = e75.fn();
    if (!(e75 instanceof Thunk)) {
      t2.cont();
    }
  }
  return e75;
}
function tokenize(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (e75 instanceof LString) {
    e75 = e75.toString();
  }
  if (t2) {
    return tokens(e75);
  } else {
    var r = tokens(e75).map(function(e76) {
      if (e76.token === "#\\ " || e76.token == "#\\\n") {
        return e76.token;
      }
      return e76.token.trim();
    }).filter(function(e76) {
      return e76 && !e76.match(/^;/) && !e76.match(/^#\|[\s\S]*\|#$/);
    });
    return strip_s_comments(r);
  }
}
function strip_s_comments(e75) {
  var t2 = 0;
  var r = null;
  var n = [];
  for (var i = 0; i < e75.length; ++i) {
    var a = e75[i];
    if (a === "#;") {
      if (["(", "["].includes(e75[i + 1])) {
        t2 = 1;
        r = i;
      } else {
        n.push([i, i + 2]);
      }
      i += 1;
      continue;
    }
    if (r !== null) {
      if ([")", "]"].includes(a)) {
        t2--;
      } else if (["(", "["].includes(a)) {
        t2++;
      }
      if (t2 === 0) {
        n.push([r, i + 1]);
        r = null;
      }
    }
  }
  e75 = e75.slice();
  n.reverse();
  for (var o = 0, u = n; o < u.length; o++) {
    var s = _slicedToArray(u[o], 2), c = s[0], l = s[1];
    e75.splice(c, l - c);
  }
  return e75;
}
function is_symbol(e75) {
  return _typeof$1(e75) === "symbol" || _typeof$1(e75) === "object" && Object.prototype.toString.call(e75) === "[object Symbol]";
}
function LSymbol(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (e75 instanceof LString) {
    e75 = e75.valueOf();
  }
  if (t2 && LSymbol.list[e75] instanceof LSymbol) {
    return LSymbol.list[e75];
  }
  if (typeof this !== "undefined" && this.constructor !== LSymbol || typeof this === "undefined") {
    return new LSymbol(e75, t2);
  }
  this.__name__ = e75;
  if (t2 && typeof e75 === "string") {
    LSymbol.list[e75] = this;
  }
}
function symbol_to_string(e75) {
  return e75.toString().replace(/^Symbol\(([^)]+)\)/, "$1");
}
function is_gensym(e75) {
  if (_typeof$1(e75) === "symbol") {
    return !!e75.toString().match(/^Symbol\(#:/);
  }
  return false;
}
function hygienic_begin(e75, t2) {
  var r = global_env.get("begin");
  var n = gensym("begin");
  e75.forEach(function(e76) {
    e76.set(n, r);
  });
  return new Pair(n, t2);
}
function QuotedPromise(e75) {
  var r = this;
  var n = { pending: true, rejected: false, fulfilled: false, reason: void 0, type: void 0 };
  e75 = e75.then(function(e76) {
    n.type = type(e76);
    n.fulfilled = true;
    n.pending = false;
    return e76;
  });
  read_only(this, "_promise", e75, { hidden: true });
  if (is_function(e75["catch"])) {
    e75 = e75["catch"](function(e76) {
      n.rejected = true;
      n.pending = false;
      n.reason = e76;
    });
  }
  Object.keys(n).forEach(function(t2) {
    Object.defineProperty(r, "__".concat(t2, "__"), { enumerable: true, get: function e76() {
      return n[t2];
    } });
  });
  read_only(this, "__promise__", e75);
  this.then = false;
}
function promise_all(e75) {
  if (Array.isArray(e75)) {
    return Promise.all(escape_quoted_promises(e75)).then(unescape_quoted_promises);
  }
  return e75;
}
function escape_quoted_promises(e75) {
  var t2 = new Array(e75.length), r = e75.length;
  while (r--) {
    var n = e75[r];
    if (n instanceof QuotedPromise) {
      t2[r] = new Value(n);
    } else {
      t2[r] = n;
    }
  }
  return t2;
}
function unescape_quoted_promises(e75) {
  var t2 = new Array(e75.length), r = e75.length;
  while (r--) {
    var n = e75[r];
    if (n instanceof Value) {
      t2[r] = n.valueOf();
    } else {
      t2[r] = n;
    }
  }
  return t2;
}
function is_special(e75) {
  return specials.names().includes(e75);
}
function is_builtin(e75) {
  return specials.__builtins__.includes(e75);
}
function is_literal(e75) {
  return specials.type(e75) === specials.LITERAL;
}
function is_symbol_extension(e75) {
  return specials.type(e75) === specials.SYMBOL;
}
function match_or_null(e75, t2) {
  if (is_string(e75)) {
    return e75 === t2;
  }
  return e75 === null || t2.match(e75);
}
function _parse(e75, t2) {
  return _parse2.apply(this, arguments);
}
function _parse2() {
  _parse2 = _wrapAsyncGenerator(_regeneratorRuntime.mark(function e75(r, n) {
    var i, a, o;
    return _regeneratorRuntime.wrap(function e76(t2) {
      while (1) switch (t2.prev = t2.next) {
        case 0:
          if (!n) {
            if (global_env) {
              n = global_env.get("**interaction-environment**", { throwError: false });
            } else {
              n = user_env;
            }
          }
          if (r instanceof Parser) {
            i = r;
          } else {
            i = new Parser({ env: n });
            i.prepare(r);
          }
        case 2:
          t2.next = 5;
          return _awaitAsyncGenerator(i.read_object());
        case 5:
          o = t2.sent;
          if (!i.balanced()) {
            i._ballancing_error(o, a);
          }
          if (!(o === eof)) {
            t2.next = 9;
            break;
          }
          return t2.abrupt("break", 14);
        case 9:
          a = o;
          t2.next = 12;
          return o;
        case 12:
          t2.next = 2;
          break;
        case 14:
        case "end":
          return t2.stop();
      }
    }, e75);
  }));
  return _parse2.apply(this, arguments);
}
function unpromise(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function(e76) {
    return e76;
  };
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  if (is_promise(e75)) {
    var n = e75.then(t2);
    if (r === null) {
      return n;
    } else {
      return n["catch"](r);
    }
  }
  if (e75 instanceof Array) {
    return unpromise_array(e75, t2, r);
  }
  if (is_plain_object(e75)) {
    return unpromise_object(e75, t2, r);
  }
  return t2(e75);
}
function unpromise_array(t2, r, e75) {
  if (t2.find(is_promise)) {
    return unpromise(promise_all(t2), function(e76) {
      if (Object.isFrozen(t2)) {
        Object.freeze(e76);
      }
      return r(e76);
    }, e75);
  }
  return r(t2);
}
function unpromise_object(t2, e75, r) {
  var i = Object.keys(t2);
  var n = [], a = [];
  var o = i.length;
  while (o--) {
    var u = i[o];
    var s = t2[u];
    n[o] = s;
    if (is_promise(s)) {
      a.push(s);
    }
  }
  if (a.length) {
    return unpromise(promise_all(n), function(e76) {
      var n2 = {};
      e76.forEach(function(e77, t3) {
        var r2 = i[t3];
        n2[r2] = e77;
      });
      if (Object.isFrozen(t2)) {
        Object.freeze(n2);
      }
      return n2;
    }, r);
  }
  return e75(t2);
}
function read_only(e75, t2, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, i = n.hidden, a = i === void 0 ? false : i;
  Object.defineProperty(e75, t2, { value: r, writable: false, configurable: true, enumerable: !a });
}
function uniterate_async(e75) {
  return _uniterate_async.apply(this, arguments);
}
function _uniterate_async() {
  _uniterate_async = _asyncToGenerator(_regeneratorRuntime.mark(function e75(r) {
    var n, i, a, o, u, s, c;
    return _regeneratorRuntime.wrap(function e76(t2) {
      while (1) switch (t2.prev = t2.next) {
        case 0:
          n = [];
          i = false;
          a = false;
          t2.prev = 3;
          u = _asyncIterator(r);
        case 5:
          t2.next = 7;
          return u.next();
        case 7:
          if (!(i = !(s = t2.sent).done)) {
            t2.next = 13;
            break;
          }
          c = s.value;
          n.push(c);
        case 10:
          i = false;
          t2.next = 5;
          break;
        case 13:
          t2.next = 19;
          break;
        case 15:
          t2.prev = 15;
          t2.t0 = t2["catch"](3);
          a = true;
          o = t2.t0;
        case 19:
          t2.prev = 19;
          t2.prev = 20;
          if (!(i && u["return"] != null)) {
            t2.next = 24;
            break;
          }
          t2.next = 24;
          return u["return"]();
        case 24:
          t2.prev = 24;
          if (!a) {
            t2.next = 27;
            break;
          }
          throw o;
        case 27:
          return t2.finish(24);
        case 28:
          return t2.finish(19);
        case 29:
          return t2.abrupt("return", n);
        case 30:
        case "end":
          return t2.stop();
      }
    }, e75, null, [[3, 15, 19, 29], [20, , 24, 28]]);
  }));
  return _uniterate_async.apply(this, arguments);
}
function matcher(e75, t2) {
  if (t2 instanceof RegExp) {
    return function(e76) {
      return String(e76).match(t2);
    };
  } else if (is_function(t2)) {
    return t2;
  } else if (t2 instanceof LNumber) {
    return function(e76) {
      return LNumber(e76).cmp(t2) === 0;
    };
  } else if (t2 instanceof LString) {
    var r = t2.__string__;
    return function(e76) {
      return LString.is(e76, r);
    };
  } else if (t2 instanceof LSymbol) {
    var n = t2.__name__;
    return function(e76) {
      return LSymbol.is(e76, n);
    };
  } else if (t2 instanceof LCharacter) {
    var i = t2.__char__;
    return function(e76) {
      return LCharacter.is(e76, i);
    };
  }
  return function(e76) {
    return t2 === e76;
  };
}
function doc(e75, t2, r, n) {
  if (typeof e75 !== "string") {
    t2 = arguments[0];
    r = arguments[1];
    n = arguments[2];
    e75 = null;
  }
  if (r) {
    if (n) {
      t2.__doc__ = r;
    } else {
      t2.__doc__ = trim_lines(r);
    }
  }
  if (e75) {
    t2.__name__ = e75;
  } else if (t2.name && !is_lambda(t2)) {
    t2.__name__ = t2.name;
  }
  return t2;
}
function trim_lines(e75) {
  return e75.split("\n").map(function(e76) {
    return e76.trim();
  }).join("\n");
}
function previousSexp(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var r = e75.length;
  if (t2 <= 0) {
    throw Error("previousSexp: Invalid argument sexp = ".concat(t2));
  }
  e: while (t2-- && r >= 0) {
    var n = 1;
    while (n > 0) {
      var i = e75[--r];
      if (!i) {
        break e;
      }
      if (i === "(" || i.token === "(") {
        n--;
      } else if (i === ")" || i.token === ")") {
        n++;
      }
    }
    r--;
  }
  return e75.slice(r + 1);
}
function lineIndent(e75) {
  if (!e75 || !e75.length) {
    return 0;
  }
  var t2 = e75.length;
  if (e75[t2 - 1].token === "\n") {
    return 0;
  }
  while (--t2) {
    if (e75[t2].token === "\n") {
      var r = (e75[t2 + 1] || {}).token;
      if (r) {
        return r.length;
      }
    }
  }
  return 0;
}
function match(e75, t2) {
  return l(e75, t2) === t2.length;
  function l(r, n) {
    function e76(e77, t4) {
      var r2 = _createForOfIteratorHelper(e77), n2;
      try {
        for (r2.s(); !(n2 = r2.n()).done; ) {
          var i2 = n2.value;
          var a2 = l(i2, t4);
          if (a2 !== -1) {
            return a2;
          }
        }
      } catch (e78) {
        r2.e(e78);
      } finally {
        r2.f();
      }
      return -1;
    }
    function t3() {
      return r[a] === Symbol["for"]("symbol") && !is_symbol_string(n[u]);
    }
    function i() {
      var e77 = r[a + 1];
      var t4 = n[u + 1];
      if (e77 !== void 0 && t4 !== void 0) {
        return l([e77], [t4]);
      }
    }
    var a = 0;
    var o = {};
    for (var u = 0; u < n.length; ++u) {
      if (typeof r[a] === "undefined") {
        return u;
      }
      if (r[a] instanceof Pattern) {
        var s;
        if (["+", "*"].includes(r[a].flag)) {
          while (u < n.length) {
            s = e76(r[a].patterns, n.slice(u));
            if (s === -1) {
              break;
            }
            u += s;
          }
          u -= 1;
          a++;
          continue;
        } else if (r[a].flag === "?") {
          s = e76(r[a].patterns, n.slice(u));
          if (s === -1) {
            u -= 2;
          } else {
            a++;
          }
          continue;
        }
      } else if (r[a] instanceof RegExp) {
        if (!n[u].match(r[a])) {
          return -1;
        }
      } else if (lips.LString.isString(r[a])) {
        if (r[a].valueOf() !== n[u]) {
          return -1;
        }
      } else if (_typeof$1(r[a]) === "symbol") {
        if (r[a] === Symbol["for"]("*")) {
          o[a] = o[a] || 0;
          if (["(", "["].includes(n[u])) {
            o[a]++;
          } else if ([")", "]"].includes(n[u])) {
            o[a]--;
          }
          if (typeof r[a + 1] !== "undefined" && o[a] === 0 && i() === -1 || o[a] > 0) {
            continue;
          }
        } else if (t3()) {
          return -1;
        }
      } else if (r[a] instanceof Array) {
        var c = l(r[a], n.slice(u));
        if (c === -1 || c + u > n.length) {
          return -1;
        }
        u += c - 1;
        a++;
        continue;
      } else {
        return -1;
      }
      a++;
    }
    if (r.length !== a) {
      return -1;
    }
    return n.length;
  }
}
function Formatter(e75) {
  this.__code__ = e75.replace(/\r/g, "");
}
function Ahead(e75) {
  this.pattern = e75;
}
function Pattern() {
  for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
    t2[r] = arguments[r];
  }
  var n = t2.pop();
  this.patterns = t2;
  this.flag = n;
}
function keywords_re() {
  for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
    t2[r] = arguments[r];
  }
  return new RegExp("^(?:#:)?(?:".concat(t2.join("|"), ")$"));
}
function foldcase_string(e75) {
  e75 = e75.valueOf();
  return Array.from(e75).map(function(e76) {
    var t2 = e76.codePointAt(0);
    var r = fold_case_mapping[t2];
    if (r) {
      return String.fromCodePoint(r);
    }
    return e76;
  }).join("");
}
function flatten(e75, t2) {
  var r = Object.prototype.toString;
  var n = "[object Array]";
  var i = [];
  var a = e75.slice();
  var o;
  if (!e75.length) {
    return i;
  }
  o = a.pop();
  do {
    if (r.call(o) === n) {
      a.push.apply(a, o);
    } else {
      i.push(o);
    }
  } while (a.length && (o = a.pop()) !== void 0);
  i.reverse();
  return i;
}
function shuffle(e75, t2) {
  var r = e75.length, n;
  while (r > 0) {
    n = Math.floor(t2() * r);
    r--;
    var i = [e75[n], e75[r]];
    e75[r] = i[0];
    e75[n] = i[1];
  }
  return e75;
}
function Nil() {
}
function Pair(e75, t2) {
  if (typeof this !== "undefined" && this.constructor !== Pair || typeof this === "undefined") {
    return new Pair(e75, t2);
  }
  this.car = e75;
  this.cdr = t2;
}
function to_array(a, o) {
  return function e75(t2) {
    typecheck(a, t2, ["pair", "nil"]);
    if (is_nil(t2)) {
      return [];
    }
    var r = [];
    var n = t2;
    while (true) {
      if (is_pair(n)) {
        if (n.have_cycles("cdr")) {
          break;
        }
        var i = n.car;
        if (o && is_pair(i)) {
          i = this.get(a).call(this, i);
        }
        r.push(i);
        n = n.cdr;
      } else if (is_nil(n)) {
        break;
      } else {
        throw new Error("".concat(a, ": can't convert improper list"));
      }
    }
    return r;
  };
}
function is_plain_object(e75) {
  return e75 && _typeof$1(e75) === "object" && e75.constructor === Object;
}
function is_array_method(e75) {
  e75 = unbind(e75);
  return array_methods.includes(e75);
}
function is_lips_function(e75) {
  return is_function(e75) && (is_lambda(e75) || e75.__doc__);
}
function user_repr(e75) {
  var r = e75.constructor || Object;
  var n = is_plain_object(e75);
  var i = is_function(e75[Symbol.asyncIterator]) || is_function(e75[Symbol.iterator]);
  var a;
  if (repr.has(r)) {
    a = repr.get(r);
  } else {
    repr.forEach(function(e76, t2) {
      t2 = unbind(t2);
      if (r === t2 && (t2 === Object && n && !i || t2 !== Object)) {
        a = e76;
      }
    });
  }
  return a;
}
function symbolize(r) {
  if (r && _typeof$1(r) === "object") {
    var n = {};
    var e75 = Object.getOwnPropertySymbols(r);
    e75.forEach(function(e76) {
      var t3 = e76.toString().replace(/Symbol\(([^)]+)\)/, "$1");
      n[t3] = to_string(r[e76]);
    });
    var t2 = Object.getOwnPropertyNames(r);
    t2.forEach(function(e76) {
      var t3 = r[e76];
      if (t3 && _typeof$1(t3) === "object" && t3.constructor === Object) {
        n[e76] = symbolize(t3);
      } else {
        n[e76] = to_string(t3);
      }
    });
    return n;
  }
  return r;
}
function get_props(e75) {
  return Object.keys(e75).concat(Object.getOwnPropertySymbols(e75));
}
function has_own_function(e75, t2) {
  return e75.hasOwnProperty(t2) && is_function(e75.toString);
}
function function_to_string(e75) {
  if (is_native_function(e75)) {
    return "#<procedure(native)>";
  }
  var t2 = e75.prototype && e75.prototype.constructor;
  if (is_function(t2) && is_lambda(t2)) {
    if (e75[__class__] && t2.hasOwnProperty("__name__")) {
      var r = t2.__name__;
      if (LString.isString(r)) {
        r = r.toString();
        return "#<class:".concat(r, ">");
      }
      return "#<class>";
    }
  }
  if (e75.hasOwnProperty("__name__")) {
    var n = e75.__name__;
    if (_typeof$1(n) === "symbol") {
      n = symbol_to_string(n);
    }
    if (typeof n === "string") {
      return "#<procedure:".concat(n, ">");
    }
  }
  if (has_own_function(e75, "toString")) {
    return e75.toString();
  } else if (e75.name && !is_lambda(e75)) {
    return "#<procedure:".concat(e75.name.trim(), ">");
  } else {
    return "#<procedure>";
  }
}
function to_string(e75, t2, r) {
  if (typeof jQuery !== "undefined" && e75 instanceof jQuery.fn.init) {
    return "#<jQuery(" + e75.length + ")>";
  }
  if (str_mapping.has(e75)) {
    return str_mapping.get(e75);
  }
  if (is_prototype(e75)) {
    return "#<prototype>";
  }
  if (e75) {
    var n = e75.constructor;
    if (instances.has(n)) {
      for (var i = arguments.length, a = new Array(i > 3 ? i - 3 : 0), o = 3; o < i; o++) {
        a[o - 3] = arguments[o];
      }
      return instances.get(n)(e75, { quote: t2, skip_cycles: r, pair_args: a });
    }
  }
  var u = _createForOfIteratorHelper(native_types), s;
  try {
    for (u.s(); !(s = u.n()).done; ) {
      var c = s.value;
      if (e75 instanceof c) {
        return e75.toString(t2);
      }
    }
  } catch (e76) {
    u.e(e76);
  } finally {
    u.f();
  }
  if (e75 instanceof LNumber) {
    return e75.toString();
  }
  if ([_nil, eof].includes(e75)) {
    return e75.toString();
  }
  if (e75 === root) {
    return "#<js:global>";
  }
  if (e75 === null) {
    return "null";
  }
  if (is_function(e75)) {
    if (is_function(e75.toString) && e75.hasOwnProperty("toString")) {
      return e75.toString().valueOf();
    }
    return function_to_string(e75);
  }
  if (_typeof$1(e75) === "object") {
    var l = e75.constructor;
    if (!l) {
      l = Object;
    }
    var f;
    if (typeof l.__class__ === "string") {
      f = l.__class__;
    } else {
      var _ = user_repr(e75);
      if (_) {
        if (is_function(_)) {
          return _(e75, t2);
        } else {
          throw new Error("toString: Invalid repr value");
        }
      }
      f = l.name;
    }
    if (is_function(e75.toString) && e75.hasOwnProperty("toString")) {
      return e75.toString().valueOf();
    }
    if (type(e75) === "instance") {
      if (is_lambda(l) && l.__name__) {
        f = l.__name__.valueOf();
        if (_typeof$1(f) === "symbol") {
          f = f.toString().replace(/^Symbol\((?:#:)?([^\)]+)\)$/, "$1");
        }
      } else if (!is_native_function(l)) {
        f = "instance";
      }
    }
    if (is_iterator(e75, Symbol.iterator)) {
      if (f) {
        return "#<iterator(".concat(f, ")>");
      }
      return "#<iterator>";
    }
    if (is_iterator(e75, Symbol.asyncIterator)) {
      if (f) {
        return "#<asyncIterator(".concat(f, ")>");
      }
      return "#<asyncIterator>";
    }
    if (f !== "") {
      return "#<" + f + ">";
    }
    return "#<Object>";
  }
  if (typeof e75 !== "string") {
    return e75.toString();
  }
  return e75;
}
function is_cycle(e75) {
  if (!is_pair(e75)) {
    return false;
  }
  if (e75.have_cycles()) {
    return true;
  }
  return is_cycle(e75.car, fn) || is_cycle(e75.cdr, fn);
}
function mark_cycles(e75) {
  var t2 = [];
  var i = [];
  var a = [];
  function o(e76) {
    if (!t2.includes(e76)) {
      t2.push(e76);
    }
  }
  function u(e76, t3, r2, n2) {
    if (is_pair(r2)) {
      if (n2.includes(r2)) {
        if (!a.includes(r2)) {
          a.push(r2);
        }
        if (!e76[__cycles__]) {
          e76[__cycles__] = {};
        }
        e76[__cycles__][t3] = r2;
        if (!i.includes(e76)) {
          i.push(e76);
        }
        return true;
      }
    }
  }
  var s = trampoline(function e76(t3, r2) {
    if (is_pair(t3)) {
      delete t3[__ref__];
      delete t3[__cycles__];
      o(t3);
      r2.push(t3);
      var n2 = u(t3, "car", t3.car, r2);
      var i2 = u(t3, "cdr", t3.cdr, r2);
      if (!n2) {
        s(t3.car, r2.slice());
      }
      if (!i2) {
        return new Thunk(function() {
          return e76(t3.cdr, r2.slice());
        });
      }
    }
  });
  function r(e76, t3) {
    if (is_pair(e76[__cycles__][t3])) {
      var r2 = n.indexOf(e76[__cycles__][t3]);
      e76[__cycles__][t3] = "#".concat(r2, "#");
    }
  }
  s(e75, []);
  var n = t2.filter(function(e76) {
    return a.includes(e76);
  });
  n.forEach(function(e76, t3) {
    e76[__ref__] = "#".concat(t3, "=");
  });
  i.forEach(function(e76) {
    r(e76, "car");
    r(e76, "cdr");
  });
}
function abs(e75) {
  return e75 < 0 ? -e75 : e75;
}
function seq_compare(e75, t2) {
  var r = _toArray(t2), n = r[0], i = r.slice(1);
  while (i.length > 0) {
    var a = i, o = _slicedToArray(a, 1), u = o[0];
    if (!e75(n, u)) {
      return false;
    }
    var s = i;
    var c = _toArray(s);
    n = c[0];
    i = c.slice(1);
  }
  return true;
}
function equal(e75, t2) {
  if (is_function(e75)) {
    return is_function(t2) && unbind(e75) === unbind(t2);
  } else if (e75 instanceof LNumber) {
    if (!(t2 instanceof LNumber)) {
      return false;
    }
    var r;
    if (e75.__type__ === t2.__type__) {
      if (e75.__type__ === "complex") {
        r = e75.__im__.__type__ === t2.__im__.__type__ && e75.__re__.__type__ === t2.__re__.__type__;
      } else {
        r = true;
      }
      if (r && e75.cmp(t2) === 0) {
        if (e75.valueOf() === 0) {
          return Object.is(e75.valueOf(), t2.valueOf());
        }
        return true;
      }
    }
    return false;
  } else if (typeof e75 === "number") {
    if (typeof t2 !== "number") {
      return false;
    }
    if (Number.isNaN(e75)) {
      return Number.isNaN(t2);
    }
    if (e75 === Number.NEGATIVE_INFINITY) {
      return t2 === Number.NEGATIVE_INFINITY;
    }
    if (e75 === Number.POSITIVE_INFINITY) {
      return t2 === Number.POSITIVE_INFINITY;
    }
    return equal(LNumber(e75), LNumber(t2));
  } else if (e75 instanceof LCharacter) {
    if (!(t2 instanceof LCharacter)) {
      return false;
    }
    return e75.__char__ === t2.__char__;
  } else {
    return e75 === t2;
  }
}
function same_atom(e75, t2) {
  if (type(e75) !== type(t2)) {
    return false;
  }
  if (!is_atom(e75)) {
    return false;
  }
  if (e75 instanceof RegExp) {
    return e75.source === t2.source;
  }
  if (e75 instanceof LString) {
    return e75.valueOf() === t2.valueOf();
  }
  return equal(e75, t2);
}
function is_atom(e75) {
  return e75 instanceof LSymbol || LString.isString(e75) || is_nil(e75) || e75 === null || e75 instanceof LCharacter || e75 instanceof LNumber || e75 === true || e75 === false;
}
function Macro(e75, t2, r, n) {
  if (typeof this !== "undefined" && this.constructor !== Macro || typeof this === "undefined") {
    return new Macro(e75, t2);
  }
  typecheck("Macro", e75, "string", 1);
  typecheck("Macro", t2, "function", 2);
  if (r) {
    if (n) {
      this.__doc__ = r;
    } else {
      this.__doc__ = trim_lines(r);
    }
  }
  this.__name__ = e75;
  this.__fn__ = t2;
}
function is_lambda_macro(e75) {
  return e75.car instanceof LSymbol && is_pair(e75.cdr) && is_pair(e75.cdr.car) && LSymbol.is(e75.cdr.car.car, "lambda");
}
function is_named_macro(e75) {
  return is_pair(e75.car) && e75.car.car instanceof LSymbol;
}
function define_macro(e75, i, a, t2, r) {
  var o = r.use_dynamic, u = r.error;
  var n = Macro.defmacro(e75, function(e76) {
    var t3 = macro_args_env(i, e76, this);
    var r2 = { env: t3, dynamic_env: t3, use_dynamic: o, error: u };
    if (is_pair(a)) {
      var n2 = a.reduce(function(e77, t4) {
        return _evaluate(t4, r2);
      });
      return unpromise(n2, function(e77) {
        if (_typeof$1(e77) === "object") {
          delete e77[__data__];
        }
        return e77;
      });
    }
  }, t2, true);
  n.__code__ = new Pair(new LSymbol("define-macro"), macro);
  return n;
}
function macro_args_env(e75, t2, r) {
  var n = new Environment({}, r, "defmacro");
  var i = t2;
  while (true) {
    if (is_nil(e75)) {
      break;
    }
    if (e75 instanceof LSymbol) {
      n.__env__[e75.__name__] = i;
      break;
    } else if (!is_nil(e75.car)) {
      if (is_nil(i)) {
        n.__env__[e75.car.__name__] = _nil;
      } else {
        if (is_pair(i.car)) {
          i.car[__data__] = true;
        }
        n.__env__[e75.car.__name__] = i.car;
      }
    }
    if (is_nil(e75.cdr)) {
      break;
    }
    if (!is_nil(i)) {
      i = i.cdr;
    }
    e75 = e75.cdr;
  }
  return n;
}
function macro_expand(l) {
  return function() {
    var r = _asyncToGenerator(_regeneratorRuntime.mark(function e75(r2, v) {
      var a, b, n, i, o, u, g, w, D, x, L, E, S, A, s, F, c;
      return _regeneratorRuntime.wrap(function e76(t2) {
        while (1) switch (t2.prev = t2.next) {
          case 0:
            c = function e77() {
              c = _asyncToGenerator(_regeneratorRuntime.mark(function e78(r3, n2, i2) {
                var a2, o2, u2, s2, c2, l2, f, _, p, d, h, m, y;
                return _regeneratorRuntime.wrap(function e79(t3) {
                  while (1) switch (t3.prev = t3.next) {
                    case 0:
                      if (!(is_pair(r3) && r3.car instanceof LSymbol)) {
                        t3.next = 50;
                        break;
                      }
                      if (!r3[__data__]) {
                        t3.next = 3;
                        break;
                      }
                      return t3.abrupt("return", r3);
                    case 3:
                      a2 = r3.car.valueOf();
                      o2 = i2.get(r3.car, { throwError: false });
                      u2 = g(a2);
                      s2 = u2 || D(o2, r3) || x(o2);
                      if (!(S(a2, o2) && !w(a2))) {
                        t3.next = 31;
                        break;
                      }
                      c2 = o2 instanceof Syntax ? r3 : r3.cdr;
                      t3.next = 11;
                      return o2.invoke(c2, _objectSpread(_objectSpread({}, v), {}, { env: i2 }), true);
                    case 11:
                      l2 = t3.sent;
                      if (!(o2 instanceof Syntax)) {
                        t3.next = 20;
                        break;
                      }
                      f = l2, _ = f.expr, p = f.scope;
                      if (!is_pair(_)) {
                        t3.next = 19;
                        break;
                      }
                      if (!(n2 !== -1 && n2 <= 1 || n2 < recur_guard)) {
                        t3.next = 17;
                        break;
                      }
                      return t3.abrupt("return", _);
                    case 17:
                      if (n2 !== -1) {
                        n2 = n2 - 1;
                      }
                      return t3.abrupt("return", F(_, n2, p));
                    case 19:
                      l2 = _;
                    case 20:
                      if (!(l2 instanceof LSymbol)) {
                        t3.next = 22;
                        break;
                      }
                      return t3.abrupt("return", quote(l2));
                    case 22:
                      if (!is_pair(l2)) {
                        t3.next = 27;
                        break;
                      }
                      if (!(n2 !== -1 && n2 <= 1 || n2 < recur_guard)) {
                        t3.next = 25;
                        break;
                      }
                      return t3.abrupt("return", l2);
                    case 25:
                      if (n2 !== -1) {
                        n2 = n2 - 1;
                      }
                      return t3.abrupt("return", F(l2, n2, i2));
                    case 27:
                      if (!is_atom(l2)) {
                        t3.next = 29;
                        break;
                      }
                      return t3.abrupt("return", l2);
                    case 29:
                      t3.next = 50;
                      break;
                    case 31:
                      if (!(s2 && is_pair(r3.cdr.car))) {
                        t3.next = 50;
                        break;
                      }
                      if (!u2) {
                        t3.next = 39;
                        break;
                      }
                      b = E(r3.cdr.car);
                      t3.next = 36;
                      return A(r3.cdr.car, n2);
                    case 36:
                      d = t3.sent;
                      t3.next = 41;
                      break;
                    case 39:
                      b = L(r3.cdr.car);
                      d = r3.cdr.car;
                    case 41:
                      t3.t0 = Pair;
                      t3.t1 = r3.car;
                      t3.t2 = Pair;
                      t3.t3 = d;
                      t3.next = 47;
                      return F(r3.cdr.cdr, n2, i2);
                    case 47:
                      t3.t4 = t3.sent;
                      t3.t5 = new t3.t2(t3.t3, t3.t4);
                      return t3.abrupt("return", new t3.t0(t3.t1, t3.t5));
                    case 50:
                      h = r3.car;
                      if (!is_pair(h)) {
                        t3.next = 55;
                        break;
                      }
                      t3.next = 54;
                      return F(h, n2, i2);
                    case 54:
                      h = t3.sent;
                    case 55:
                      m = r3.cdr;
                      if (!is_pair(m)) {
                        t3.next = 60;
                        break;
                      }
                      t3.next = 59;
                      return F(m, n2, i2);
                    case 59:
                      m = t3.sent;
                    case 60:
                      y = new Pair(h, m);
                      return t3.abrupt("return", y);
                    case 62:
                    case "end":
                      return t3.stop();
                  }
                }, e78);
              }));
              return c.apply(this, arguments);
            };
            F = function e77(t3, r3, n2) {
              return c.apply(this, arguments);
            };
            s = function e77() {
              s = _asyncToGenerator(_regeneratorRuntime.mark(function e78(r3, n2) {
                var i2;
                return _regeneratorRuntime.wrap(function e79(t3) {
                  while (1) switch (t3.prev = t3.next) {
                    case 0:
                      if (!is_nil(r3)) {
                        t3.next = 2;
                        break;
                      }
                      return t3.abrupt("return", _nil);
                    case 2:
                      i2 = r3.car;
                      t3.t0 = Pair;
                      t3.t1 = Pair;
                      t3.t2 = i2.car;
                      t3.next = 8;
                      return F(i2.cdr, n2, a);
                    case 8:
                      t3.t3 = t3.sent;
                      t3.t4 = new t3.t1(t3.t2, t3.t3);
                      t3.next = 12;
                      return A(r3.cdr);
                    case 12:
                      t3.t5 = t3.sent;
                      return t3.abrupt("return", new t3.t0(t3.t4, t3.t5));
                    case 14:
                    case "end":
                      return t3.stop();
                  }
                }, e78);
              }));
              return s.apply(this, arguments);
            };
            A = function e77(t3, r3) {
              return s.apply(this, arguments);
            };
            S = function e77(t3, r3) {
              return r3 instanceof Macro && r3.__defmacro__ && !b.includes(t3);
            };
            E = function e77(t3) {
              return [].concat(_toConsumableArray(b), _toConsumableArray(t3.to_array(false).map(function(e78) {
                if (is_pair(e78)) {
                  return e78.car.valueOf();
                }
                var t4 = type(e78);
                var r3 = "macroexpand: Invalid let binding expectig pair got ".concat(t4);
                throw new Error(r3);
              })));
            };
            L = function e77(t3) {
              var r3 = [];
              while (true) {
                if (!is_nil(t3)) {
                  if (t3 instanceof LSymbol) {
                    r3.push(t3.valueOf());
                    break;
                  }
                  r3.push(t3.car.valueOf());
                  t3 = t3.cdr;
                } else {
                  break;
                }
              }
              return [].concat(_toConsumableArray(b), r3);
            };
            x = function e77(t3) {
              return t3 === o;
            };
            D = function e77(t3, r3) {
              return t3 === u && is_pair(r3.cdr.car);
            };
            w = function e77(t3) {
              if (!g(t3)) {
                return false;
              }
              return i.includes(a.get(t3));
            };
            g = function e77(t3) {
              return n.includes(t3);
            };
            a = v["env"] = this;
            b = [];
            n = ["let", "let*", "letrec", "letrec*"];
            i = n.map(function(e77) {
              return global_env.get(e77);
            });
            o = global_env.get("lambda");
            u = global_env.get("define");
            if (!(is_pair(r2.cdr) && LNumber.isNumber(r2.cdr.car))) {
              t2.next = 23;
              break;
            }
            t2.t0 = quote;
            t2.next = 21;
            return F(r2, r2.cdr.car.valueOf(), a);
          case 21:
            t2.t1 = t2.sent.car;
            return t2.abrupt("return", (0, t2.t0)(t2.t1));
          case 23:
            if (!l) {
              t2.next = 29;
              break;
            }
            t2.t2 = quote;
            t2.next = 27;
            return F(r2, 1, a);
          case 27:
            t2.t3 = t2.sent.car;
            return t2.abrupt("return", (0, t2.t2)(t2.t3));
          case 29:
            t2.t4 = quote;
            t2.next = 32;
            return F(r2, -1, a);
          case 32:
            t2.t5 = t2.sent.car;
            return t2.abrupt("return", (0, t2.t4)(t2.t5));
          case 34:
          case "end":
            return t2.stop();
        }
      }, e75, this);
    }));
    return function(e75, t2) {
      return r.apply(this, arguments);
    };
  }();
}
function Syntax(e75, t2) {
  this.__env__ = t2;
  this.__fn__ = e75;
  this.__defmacro__ = true;
}
function extract_patterns(e75, t2, K, J) {
  var r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  var W = { "...": { symbols: {}, lists: [] }, symbols: {} };
  var Q = r.expansion, X = r.define;
  log(K);
  function Z(t3, e76) {
    var r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var n = r2.ellipsis, i = n === void 0 ? false : n, a = r2.trailing, I = a === void 0 ? false : a, o = r2.pattern_names, u = o === void 0 ? [] : o;
    log({ code: e76, pattern: t3 });
    if (is_atom(t3) && !(t3 instanceof LSymbol)) {
      return same_atom(t3, e76);
    }
    if (t3 instanceof LSymbol) {
      var s = t3.literal();
      if (K.includes(s)) {
        if (!LSymbol.is(e76, s) && !LSymbol.is(t3, e76)) {
          return false;
        }
        var c = Q.ref(s);
        return !c || c === X || c === global_env;
      }
    }
    if (Array.isArray(t3) && Array.isArray(e76)) {
      log("<<< a 1");
      if (t3.length === 0 && e76.length === 0) {
        return true;
      }
      if (LSymbol.is(t3[1], J)) {
        if (t3[0] instanceof LSymbol) {
          var l = t3[0].valueOf();
          log("<<< a 2 " + i);
          if (i) {
            var f = e76.length - 2;
            var j = f > 0 ? e76.slice(0, f) : e76;
            var _ = Pair.fromArray(j, false);
            if (!W["..."].symbols[l]) {
              W["..."].symbols[l] = new Pair(_, _nil);
            } else {
              W["..."].symbols[l].append(new Pair(_, _nil));
            }
          } else {
            W["..."].symbols[l] = Pair.fromArray(e76, false);
          }
        } else if (Array.isArray(t3[0])) {
          log("<<< a 3");
          var R = _toConsumableArray(u);
          var T = _objectSpread(_objectSpread({}, r2), {}, { pattern_names: R, ellipsis: true });
          if (!e76.every(function(e77) {
            return Z(t3[0], e77, T);
          })) {
            return false;
          }
        }
        if (t3.length > 2) {
          var p = t3.slice(2);
          return Z(p, e76.slice(-p.length), r2);
        }
        return true;
      }
      var d = Z(t3[0], e76[0], r2);
      log({ first: d, pattern: t3[0], code: e76[0] });
      var h = Z(t3.slice(1), e76.slice(1), r2);
      log({ first: d, rest: h });
      return d && h;
    }
    if (is_pair(t3) && is_pair(t3.car) && is_pair(t3.car.cdr) && LSymbol.is(t3.car.cdr.car, J)) {
      log(">> 0");
      if (is_nil(e76)) {
        log({ pattern: t3 });
        if (t3.car.car instanceof LSymbol) {
          var m = t3.car.car.valueOf();
          if (W["..."].symbols[m]) {
            throw new Error("syntax: named ellipsis can only appear onces");
          }
          W["..."].symbols[m] = e76;
        }
      }
    }
    if (is_pair(t3) && is_pair(t3.cdr) && LSymbol.is(t3.cdr.car, J)) {
      log(">> 1 (a)");
      if (!is_nil(t3.cdr.cdr)) {
        if (is_pair(t3.cdr.cdr)) {
          log(">> 1 (b)");
          var $ = t3.cdr.cdr.length();
          var y = !is_nil(t3.last_pair().cdr);
          if (!is_pair(e76)) {
            return false;
          }
          var v = e76.length();
          var b = e76;
          var M = y ? 1 : 1;
          while (v - M > $) {
            b = b.cdr;
            v--;
          }
          var V = b.cdr;
          b.cdr = _nil;
          var q = _objectSpread(_objectSpread({}, r2), {}, { trailing: y });
          if (!Z(t3.cdr.cdr, V, q)) {
            return false;
          }
        }
      }
      if (t3.car instanceof LSymbol) {
        var g = t3.car.__name__;
        if (W["..."].symbols[g] && !u.includes(g) && !i) {
          throw new Error("syntax: named ellipsis can only appear onces");
        }
        log(">> 1 (next)");
        if (is_nil(e76)) {
          log(">> 2");
          if (i) {
            log("NIL");
            W["..."].symbols[g] = _nil;
          } else {
            log("NULL");
            W["..."].symbols[g] = null;
          }
        } else if (is_pair(e76) && (is_pair(e76.car) || is_nil(e76.car))) {
          log(">> 3 " + i);
          if (i) {
            if (W["..."].symbols[g]) {
              var w = W["..."].symbols[g];
              if (is_nil(w)) {
                w = new Pair(_nil, new Pair(e76, _nil));
              } else {
                w = w.append(new Pair(e76, _nil));
              }
              W["..."].symbols[g] = w;
            } else {
              W["..."].symbols[g] = new Pair(e76, _nil);
            }
          } else {
            log(">> 4");
            W["..."].symbols[g] = new Pair(e76, _nil);
          }
        } else {
          log(">> 6");
          if (is_pair(e76)) {
            log(">> 7 " + i);
            if (!is_pair(e76.cdr) && !is_nil(e76.cdr)) {
              log(">> 7 (b)");
              if (is_nil(t3.cdr.cdr)) {
                return false;
              } else if (!W["..."].symbols[g]) {
                W["..."].symbols[g] = new Pair(e76.car, _nil);
                return Z(t3.cdr.cdr, e76.cdr, r2);
              }
            }
            var D = e76.last_pair();
            log({ last_pair: D });
            if (!is_nil(D.cdr)) {
              log(">> 7 (c)");
              if (is_nil(t3.cdr.cdr)) {
                return false;
              } else {
                log(">> 7 (d)");
                var x = e76.clone();
                x.last_pair().cdr = _nil;
                W["..."].symbols[g] = x;
                return Z(t3.cdr.cdr, D.cdr, r2);
              }
            }
            u.push(g);
            if (!W["..."].symbols[g]) {
              log(">> 7 (e)");
              W["..."].symbols[g] = new Pair(e76, _nil);
            } else {
              log(">> 7 (f)");
              var z = W["..."].symbols[g];
              W["..."].symbols[g] = z.append(new Pair(e76, _nil));
            }
            log({ IIIIII: W["..."].symbols[g] });
          } else if (t3.car instanceof LSymbol && is_pair(t3.cdr) && LSymbol.is(t3.cdr.car, J)) {
            log(">> 8");
            W["..."].symbols[g] = null;
            return Z(t3.cdr.cdr, e76, r2);
          } else {
            log(">> 9");
            return false;
          }
        }
        return true;
      } else if (is_pair(t3.car)) {
        var L = _toConsumableArray(u);
        if (is_nil(e76)) {
          log(">> 10");
          W["..."].lists.push(_nil);
          return true;
        }
        log(">> 11");
        var E = e76;
        var U = _objectSpread(_objectSpread({}, r2), {}, { pattern_names: L, ellipsis: true });
        while (is_pair(E)) {
          if (!Z(t3.car, E.car, U)) {
            return false;
          }
          E = E.cdr;
        }
        return true;
      }
      if (Array.isArray(t3.car)) {
        var L = _toConsumableArray(u);
        var S = e76;
        var G = _objectSpread(_objectSpread({}, r2), {}, { pattern_names: L, ellipsis: true });
        while (is_pair(S)) {
          if (!Z(t3.car, S.car, G)) {
            return false;
          }
          S = S.cdr;
        }
        return true;
      }
      return false;
    }
    if (t3 instanceof LSymbol) {
      if (LSymbol.is(t3, J)) {
        throw new Error("syntax: invalid usage of ellipsis");
      }
      log(">> 12");
      var A = t3.__name__;
      if (K.includes(A)) {
        return true;
      }
      if (i) {
        var F, k;
        log(W["..."].symbols[A]);
        (k = (F = W["..."].symbols)[A]) !== null && k !== void 0 ? k : F[A] = [];
        W["..."].symbols[A].push(e76);
      } else {
        W.symbols[A] = e76;
      }
      return true;
    }
    if (is_pair(t3) && is_pair(e76)) {
      log(">> 13");
      log({ a: 13, code: e76, pattern: t3 });
      var C = t3.car instanceof LSymbol && t3.cdr instanceof LSymbol;
      if (I && C) {
        log(">> 13 (a)");
        if (!is_nil(e76.cdr)) {
          return false;
        }
        var H = t3.car.valueOf();
        var Y = t3.cdr.valueOf();
        W.symbols[H] = e76.car;
        W.symbols[Y] = _nil;
        return true;
      }
      if (is_nil(e76.cdr)) {
        log(">> 13 (b)");
        if (C) {
          if (!Z(t3.car, e76.car, r2)) {
            return false;
          }
          log(">> 14");
          var P = t3.cdr.valueOf();
          if (!(P in W.symbols)) {
            W.symbols[P] = _nil;
          }
          P = t3.car.valueOf();
          if (!(P in W.symbols)) {
            W.symbols[P] = e76.car;
          }
          return true;
        }
      }
      log({ pattern: t3, code: e76 });
      if (is_pair(t3.cdr) && is_pair(t3.cdr.cdr) && t3.cdr.car instanceof LSymbol && LSymbol.is(t3.cdr.cdr.car, J) && is_pair(t3.cdr.cdr.cdr) && !LSymbol.is(t3.cdr.cdr.cdr.car, J) && Z(t3.car, e76.car, r2) && Z(t3.cdr.cdr.cdr, e76.cdr, _objectSpread(_objectSpread({}, r2), {}, { trailing: true }))) {
        var O = t3.cdr.car.__name__;
        log({ pattern: t3, code: e76, name: O });
        if (K.includes(O)) {
          return true;
        }
        W["..."].symbols[O] = null;
        return true;
      }
      log("recur");
      log({ pattern: t3, code: e76 });
      var N = Z(t3.car, e76.car, r2);
      var B = Z(t3.cdr, e76.cdr, r2);
      log({ $car_code: e76.car, $car_pattern: t3.car, car: N, $cdr_code: e76.cdr, $cdr_pattern: t3.cdr, cdr: B });
      if (N && B) {
        return true;
      }
    } else if (is_nil(t3) && (is_nil(e76) || e76 === void 0)) {
      return true;
    } else if (is_pair(t3.car) && LSymbol.is(t3.car.car, J)) {
      throw new Error("syntax: invalid usage of ellipsis");
    } else {
      return false;
    }
  }
  if (Z(e75, t2)) {
    return W;
  }
}
function clear_gensyms(e75, i) {
  function a(t2) {
    if (is_pair(t2)) {
      if (!i.length) {
        return t2;
      }
      var e76 = a(t2.car);
      var r = a(t2.cdr);
      return new Pair(e76, r);
    } else if (t2 instanceof LSymbol) {
      var n = i.find(function(e77) {
        return e77.gensym === t2;
      });
      if (n) {
        return LSymbol(n.name);
      }
      return t2;
    } else {
      return t2;
    }
  }
  return a(e75);
}
function transform_syntax() {
  var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var O = e75.bindings, t2 = e75.expr, N = e75.scope, o = e75.symbols, l = e75.names, B = e75.ellipsis;
  var f = {};
  function u(e76) {
    if (e76 instanceof LSymbol) {
      return true;
    }
    return ["string", "symbol"].includes(_typeof$1(e76));
  }
  function I(e76) {
    if (!u(e76)) {
      var t3 = type(e76);
      throw new Error("syntax: internal error, need symbol got ".concat(t3));
    }
    var r = e76.valueOf();
    if (r === B) {
      throw new Error("syntax: internal error, ellipis not transformed");
    }
    var n = _typeof$1(r);
    if (["string", "symbol"].includes(n)) {
      if (r in O.symbols) {
        return O.symbols[r];
      } else if (n === "string" && r.match(/\./)) {
        var i = r.split(".");
        var a = i[0];
        if (a in O.symbols) {
          return Pair.fromArray([LSymbol("."), O.symbols[a]].concat(i.slice(1).map(function(e77) {
            return LString(e77);
          })));
        }
      }
    }
    if (o.includes(r)) {
      return e76;
    }
    return s(r, e76);
  }
  function s(e76, t3) {
    if (!f[e76]) {
      var r = N.ref(e76);
      if (_typeof$1(e76) === "symbol" && !r) {
        e76 = t3.literal();
      }
      if (f[e76]) {
        return f[e76];
      }
      var n = gensym(e76);
      if (r) {
        var i = N.get(e76);
        N.set(n, i);
      } else {
        var a = N.get(e76, { throwError: false });
        if (typeof a !== "undefined") {
          N.set(n, a);
        }
      }
      l.push({ name: e76, gensym: n });
      f[e76] = n;
      if (typeof e76 === "string" && e76.match(/\./)) {
        var o2 = e76.split(".").filter(Boolean), u2 = _toArray(o2), s2 = u2[0], c = u2.slice(1);
        if (f[s2]) {
          hidden_prop(n, "__object__", [f[s2]].concat(_toConsumableArray(c)));
        }
      }
    }
    return f[e76];
  }
  function j(e76, t3, r) {
    var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
    };
    var i = r.nested;
    log({ bindings: t3, expr: e76 });
    if (Array.isArray(e76) && !e76.length) {
      return e76;
    }
    if (e76 instanceof LSymbol) {
      var a = e76.valueOf();
      if (is_gensym(e76) && !t3[a]) ;
      log("[t 1");
      if (t3[a]) {
        if (is_pair(t3[a])) {
          var o2 = t3[a], u2 = o2.car, s2 = o2.cdr;
          if (i) {
            var c = u2.car, l2 = u2.cdr;
            if (!is_nil(l2)) {
              n(a, new Pair(l2, _nil));
            }
            return c;
          }
          if (!is_nil(s2)) {
            n(a, s2);
          }
          return u2;
        } else if (t3[a] instanceof Array) {
          n(a, t3[a].slice(1));
          return t3[a][0];
        }
      }
      return I(e76);
    }
    var f2 = Array.isArray(e76);
    if (is_pair(e76) || f2) {
      var _ = f2 ? e76[0] : e76.car;
      var p = f2 ? e76[1] : is_pair(e76.cdr) && e76.cdr.car;
      if (_ instanceof LSymbol && LSymbol.is(p, B)) {
        f2 ? e76.slice(2) : e76.cdr.cdr;
        log("[t 2");
        var d = _.valueOf();
        var h = t3[d];
        if (h === null) {
          return;
        } else if (d in t3) {
          log({ name: d, binding: t3[d] });
          if (is_pair(h)) {
            log("[t 2 Pair " + i);
            var m = h.car, y = h.cdr;
            var v = f2 ? e76.slice(2) : e76.cdr.cdr;
            if (i) {
              if (!is_nil(y)) {
                log("|| next 1");
                n(d, y);
              }
              if (f2 && v.length || !is_nil(v) && !f2) {
                var b = j(v, t3, r, n);
                if (f2) {
                  return m.concat(b);
                } else if (is_pair(m)) {
                  return m.append(b);
                } else {
                  log("UNKNOWN");
                }
              }
              return m;
            } else if (is_pair(m)) {
              if (!is_nil(m.cdr)) {
                log("|| next 2");
                n(d, new Pair(m.cdr, y));
              }
              return new Value(m.car);
            } else if (is_nil(y)) {
              return m;
            } else {
              var g = e76.last_pair();
              if (g.cdr instanceof LSymbol) {
                log("|| next 3");
                n(d, h.last_pair());
                return m;
              }
            }
          } else if (h instanceof Array) {
            log("[t 2 Array " + i);
            if (i) {
              n(d, h.slice(1));
              return Pair.fromArray(h);
            } else {
              var w = h.slice(1);
              if (w.length) {
                n(d, w);
              }
              return h[0];
            }
          } else {
            return h;
          }
        }
      }
      log("[t 3 recur ", e76);
      var D = f2 ? e76.slice(1) : e76.cdr;
      var x = j(_, t3, r, n);
      var L = j(D, t3, r, n);
      log({ head: x, rest: L });
      if (f2) {
        return [x].concat(L);
      }
      return new Pair(x, L);
    }
    return e76;
  }
  function R(t3, r) {
    var e76 = Object.values(t3);
    var n = Object.getOwnPropertySymbols(t3);
    if (n.length) {
      e76.push.apply(e76, _toConsumableArray(n.map(function(e77) {
        return t3[e77];
      })));
    }
    return e76.length && e76.every(function(e77) {
      if (e77 === null) {
        return !r;
      }
      return is_pair(e77) || is_nil(e77) || Array.isArray(e77) && e77.length;
    });
  }
  function T(e76) {
    return Object.keys(e76).concat(Object.getOwnPropertySymbols(e76));
  }
  function $(i) {
    var e76 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t3 = e76.disabled;
    log("traverse>> ", i);
    var a = Array.isArray(i);
    if (a && i.length === 0) {
      return i;
    }
    if (is_pair(i) || a) {
      log(">> 0");
      var r = a ? i[0] : i.car;
      var n, o2;
      if (a) {
        n = i[1];
        o2 = i.slice(2);
      } else if (is_pair(i.cdr)) {
        n = i.cdr.car;
        o2 = i.cdr.cdr;
      }
      log({ first: r, second: n, rest_second: o2 });
      if (!t3 && is_pair(r) && LSymbol.is(r.car, B)) {
        return new Pair(r.cdr.car, $(i.cdr));
      }
      if (n && LSymbol.is(n, B) && !t3) {
        log(">> 1");
        var u2 = O["..."].symbols;
        var s2 = Object.values(u2);
        if (s2.length && s2.every(function(e77) {
          return e77 === null;
        })) {
          log(">>> 1 (a)");
          return $(o2, { disabled: t3 });
        }
        var c = T(u2);
        var l2 = r instanceof LSymbol && LSymbol.is(o2.car, B);
        if (is_pair(r) || l2) {
          log(">>> 1 (b)");
          if (is_nil(O["..."].lists[0])) {
            if (!l2) {
              return $(o2, { disabled: t3 });
            }
            log(o2);
            return _nil;
          }
          var f2 = r;
          if (l2) {
            log(">>> 1 (c)");
            f2 = new Pair(r, new Pair(n, _nil));
          }
          log(">> 2");
          var _;
          if (c.length) {
            log(">> 2 (a)");
            var p = _objectSpread({}, u2);
            _ = a ? [] : _nil;
            var d = function e77() {
              log({ bind: p });
              if (!R(p)) {
                return 1;
              }
              var n2 = {};
              var t4 = function e78(t5, r3) {
                n2[t5] = r3;
              };
              var r2 = j(f2, p, { nested: true }, t4);
              if (r2 !== void 0) {
                if (r2 instanceof Value) {
                  r2 = r2.valueOf();
                }
                if (l2) {
                  if (a) {
                    if (Array.isArray(r2)) {
                      var i2;
                      (i2 = _).push.apply(i2, _toConsumableArray(r2));
                    } else {
                      log("ZONK {1}");
                    }
                  } else {
                    if (is_nil(_)) {
                      _ = r2;
                    } else {
                      _ = _.append(r2);
                    }
                  }
                } else if (a) {
                  _.push(r2);
                } else {
                  _ = new Pair(r2, _);
                }
              }
              p = n2;
            };
            while (true) {
              if (d()) break;
            }
            if (!is_nil(_) && !l2 && !a) {
              _ = _.reverse();
            }
            if (a) {
              if (o2) {
                log({ rest_second: o2, expr: i });
                var h = $(o2, { disabled: t3 });
                return _.concat(h);
              }
              return _;
            }
            if (!is_nil(i.cdr.cdr) && !LSymbol.is(i.cdr.cdr.car, B)) {
              var m = $(i.cdr.cdr, { disabled: t3 });
              return _.append(m);
            }
            return _;
          } else {
            log(">> 3");
            var y = j(r, u2, { nested: true });
            if (y) {
              if (y instanceof Value) {
                y = y.valueOf();
              }
              return new Pair(y, _nil);
            }
            return _nil;
          }
        } else if (r instanceof LSymbol) {
          log(">> 4");
          if (LSymbol.is(o2.car, B)) {
            log(">> 4 (a)");
          } else {
            log(">> 4 (b)");
          }
          var v = r.__name__;
          var b = _defineProperty({}, v, u2[v]);
          log({ bind: b });
          var g = u2[v] === null;
          var w = a ? [] : _nil;
          var D = function e77() {
            if (!R(b, true)) {
              log({ bind: b });
              return 1;
            }
            var n2 = {};
            var t4 = function e78(t5, r3) {
              n2[t5] = r3;
            };
            var r2 = j(i, b, { nested: false }, t4);
            log({ value: r2 });
            if (typeof r2 !== "undefined") {
              if (r2 instanceof Value) {
                r2 = r2.valueOf();
              }
              if (a) {
                w.push(r2);
              } else {
                w = new Pair(r2, w);
              }
            }
            b = n2;
          };
          while (true) {
            if (D()) break;
          }
          if (!is_nil(w) && !a) {
            w = w.reverse();
          }
          if (is_pair(i.cdr)) {
            if (is_pair(i.cdr.cdr) || i.cdr.cdr instanceof LSymbol) {
              var x = $(i.cdr.cdr, { disabled: t3 });
              log({ node: x });
              if (g) {
                return x;
              }
              if (is_nil(w)) {
                w = x;
              } else {
                w.append(x);
              }
              log({ result: w, node: x });
            }
          }
          log("<<<< 2");
          log({ result: w });
          return w;
        }
      }
      var L = $(r, { disabled: t3 });
      var E;
      var S;
      if (r instanceof LSymbol) {
        var A = N.get(r, { throwError: false });
        S = A instanceof Macro && A.__name__ === "syntax-rules";
      }
      if (S) {
        if (i.cdr.car instanceof LSymbol) {
          E = new Pair($(i.cdr.car, { disabled: t3 }), new Pair(i.cdr.cdr.car, $(i.cdr.cdr.cdr, { disabled: t3 })));
        } else {
          E = new Pair(i.cdr.car, $(i.cdr.cdr, { disabled: t3 }));
        }
        log("REST >>>> ", E);
      } else {
        E = $(i.cdr, { disabled: t3 });
      }
      log({ a: true, car: to_string(i.car), cdr: to_string(i.cdr), head: to_string(L), rest: to_string(E) });
      return new Pair(L, E);
    }
    if (i instanceof LSymbol) {
      if (t3 && LSymbol.is(i, B)) {
        return i;
      }
      var F = Object.keys(O["..."].symbols);
      var k = i.literal();
      if (F.includes(k)) {
        var C = "missing ellipsis symbol next to name `".concat(k, "'");
        throw new Error("syntax-rules: ".concat(C));
      }
      var P = I(i);
      if (typeof P !== "undefined") {
        return P;
      }
    }
    return i;
  }
  return $(t2, {});
}
function is_null(e75) {
  return is_undef(e75) || is_nil(e75) || e75 === null;
}
function is_nil(e75) {
  return e75 === _nil;
}
function is_function(e75) {
  return typeof e75 === "function" && typeof e75.bind === "function";
}
function is_directive(e75) {
  return directives.includes(e75);
}
function is_false(e75) {
  return e75 === false || e75 === null;
}
function is_string(e75) {
  return typeof e75 === "string";
}
function is_lambda(e75) {
  return e75 && e75[__lambda__];
}
function is_method(e75) {
  return e75 && e75[__method__];
}
function is_raw_lambda(e75) {
  return is_lambda(e75) && !e75[__prototype__] && !is_method(e75) && !is_port_method(e75);
}
function is_native_function(e75) {
  var t2 = Symbol["for"]("__native__");
  return is_function(e75) && e75.toString().match(/\{\s*\[native code\]\s*\}/) && (e75.name.match(/^bound /) && e75[t2] === true || !e75.name.match(/^bound /) && !e75[t2]);
}
function is_prototype(e75) {
  return e75 && _typeof$1(e75) === "object" && e75.hasOwnProperty && e75.hasOwnProperty("constructor") && typeof e75.constructor === "function" && e75.constructor.prototype === e75;
}
function is_continuation(e75) {
  return e75 instanceof Continuation;
}
function is_context(e75) {
  return e75 instanceof LambdaContext;
}
function is_parameter(e75) {
  return e75 instanceof Parameter;
}
function is_pair(e75) {
  return e75 instanceof Pair;
}
function is_env(e75) {
  return e75 instanceof Environment;
}
function is_callable(e75) {
  return is_function(e75) || is_continuation(e75) || is_parameter(e75) || is_macro(e75);
}
function is_macro(e75) {
  return e75 instanceof Macro || e75 instanceof SyntaxParameter;
}
function is_promise(e75) {
  if (e75 instanceof QuotedPromise) {
    return false;
  }
  if (e75 instanceof Promise) {
    return true;
  }
  return !!e75 && is_function(e75.then);
}
function is_undef(e75) {
  return typeof e75 === "undefined";
}
function get_proto(e75) {
  return Object.getPrototypeOf(e75);
}
function is_iterator(e75, t2) {
  if (has_own_symbol(e75, t2) || has_own_symbol(get_proto(e75), t2)) {
    return is_function(e75[t2]);
  }
}
function is_instance(e75) {
  if (!e75) {
    return false;
  }
  if (_typeof$1(e75) !== "object") {
    return false;
  }
  if (e75.__instance__) {
    e75.__instance__ = false;
    return e75.__instance__;
  }
  return false;
}
function self_evaluated(e75) {
  var t2 = _typeof$1(e75);
  return ["string", "function"].includes(t2) || _typeof$1(e75) === "symbol" || e75 instanceof QuotedPromise || e75 instanceof LSymbol || e75 instanceof LNumber || e75 instanceof LString || e75 instanceof RegExp;
}
function is_native(e75) {
  return e75 && (e75 instanceof LNumber || e75 instanceof LString || e75 instanceof LCharacter);
}
function has_own_symbol(e75, t2) {
  if (e75 === null) {
    return false;
  }
  return _typeof$1(e75) === "object" && t2 in Object.getOwnPropertySymbols(e75);
}
function box(e75) {
  switch (_typeof$1(e75)) {
    case "string":
      return LString(e75);
    case "bigint":
      return LNumber(e75);
    case "number":
      if (Number.isNaN(e75)) {
        return nan;
      } else {
        return LNumber(e75);
      }
  }
  return e75;
}
function map_object(r, n) {
  var e75 = Object.getOwnPropertyNames(r);
  var t2 = Object.getOwnPropertySymbols(r);
  var i = {};
  e75.concat(t2).forEach(function(e76) {
    var t3 = n(r[e76]);
    i[e76] = t3;
  });
  return i;
}
function unbox(t2) {
  var e75 = [LString, LNumber, LCharacter].some(function(e76) {
    return t2 instanceof e76;
  });
  if (e75) {
    return t2.valueOf();
  }
  if (t2 instanceof Array) {
    return t2.map(unbox);
  }
  if (t2 instanceof QuotedPromise) {
    delete t2.then;
  }
  if (is_plain_object(t2)) {
    return map_object(t2, unbox);
  }
  return t2;
}
function patch_value(e75, t2) {
  if (is_pair(e75)) {
    e75.mark_cycles();
    return quote(e75);
  }
  if (is_function(e75)) {
    if (t2) {
      return bind2(e75, t2);
    }
  }
  return box(e75);
}
function unbind(e75) {
  if (is_bound(e75)) {
    return e75[__fn__];
  }
  return e75;
}
function bind2(e75, t2) {
  if (e75[Symbol["for"]("__bound__")]) {
    return e75;
  }
  var r = e75.bind(t2);
  var n = Object.getOwnPropertyNames(e75);
  var i = _createForOfIteratorHelper(n), a;
  try {
    for (i.s(); !(a = i.n()).done; ) {
      var o = a.value;
      if (filter_fn_names(o)) {
        try {
          r[o] = e75[o];
        } catch (e76) {
        }
      }
    }
  } catch (e76) {
    i.e(e76);
  } finally {
    i.f();
  }
  hidden_prop(r, "__fn__", e75);
  hidden_prop(r, "__context__", t2);
  hidden_prop(r, "__bound__", true);
  if (is_native_function(e75)) {
    hidden_prop(r, "__native__", true);
  }
  if (is_plain_object(t2) && is_lambda(e75)) {
    hidden_prop(r, "__method__", true);
  }
  r.valueOf = function() {
    return e75;
  };
  return r;
}
function is_object_bound(e75) {
  return is_bound(e75) && e75[Symbol["for"]("__context__")] === Object;
}
function is_bound(e75) {
  return !!(is_function(e75) && e75[__fn__]);
}
function lips_context(e75) {
  if (is_function(e75)) {
    var t2 = e75[__context__];
    if (t2 && (t2 === lips || t2.constructor && t2.constructor.__class__)) {
      return true;
    }
  }
  return false;
}
function is_port(e75) {
  return e75 instanceof InputPort || e75 instanceof OutputPort;
}
function is_port_method(e75) {
  if (is_function(e75)) {
    if (is_port(e75[__context__])) {
      return true;
    }
  }
  return false;
}
function filter_fn_names(e75) {
  return !exluded_names.includes(e75);
}
function enumerable(e75, t2, r) {
  Object.defineProperty(e75, t2, { value: r, enumerable: true });
}
function hidden_prop(e75, t2, r) {
  Object.defineProperty(e75, Symbol["for"](t2), { get: function e76() {
    return r;
  }, set: function e76() {
  }, configurable: false, enumerable: false });
}
function set_fn_length(t2, r) {
  try {
    Object.defineProperty(t2, "length", { get: function e75() {
      return r;
    } });
    return t2;
  } catch (e75) {
    var n = new Array(r).fill(0).map(function(e76, t3) {
      return "a" + t3;
    }).join(",");
    var i = new Function("f", "return function(".concat(n, ") {\n                return f.apply(this, arguments);\n            };"));
    return i(t2);
  }
}
function let_macro(e75) {
  var w;
  switch (e75) {
    case Symbol["for"]("letrec"):
      w = "letrec";
      break;
    case Symbol["for"]("let"):
      w = "let";
      break;
    case Symbol["for"]("let*"):
      w = "let*";
      break;
    default:
      throw new Error("Invalid let_macro value");
  }
  return Macro.defmacro(w, function(t2, e76) {
    var l = e76.dynamic_env;
    var f = e76.error, r = e76.macro_expand, _ = e76.use_dynamic;
    var p;
    if (t2.car instanceof LSymbol) {
      if (!(is_pair(t2.cdr.car) || is_nil(t2.cdr.car))) {
        throw new Error("let require list of pairs");
      }
      var n;
      if (is_nil(t2.cdr.car)) {
        p = _nil;
        n = _nil;
      } else {
        n = t2.cdr.car.map(function(e77) {
          return e77.car;
        });
        p = t2.cdr.car.map(function(e77) {
          return e77.cdr.car;
        });
      }
      return new Pair(Pair.fromArray([LSymbol("letrec"), [[t2.car, Pair(LSymbol("lambda"), Pair(n, t2.cdr.cdr))]], t2.car]), p);
    } else if (r) {
      return;
    }
    var d = this;
    p = global_env.get("list->array")(t2.car);
    var h = d.inherit(w);
    var m, y;
    if (w === "let*") {
      y = h;
    } else if (w === "let") {
      m = [];
    }
    var v = 0;
    function b() {
      var e77 = hygienic_begin([h], t2.cdr);
      return _evaluate(e77, { env: h, dynamic_env: h, use_dynamic: _, error: f });
    }
    function g(e77) {
      if (e77 in h.__env__) {
        throw new Error("Duplicated let variable ".concat(e77));
      }
    }
    return function t3() {
      var r2 = p[v++];
      l = w === "let*" ? h : d;
      if (!r2) {
        if (m && m.length) {
          var e77 = m.map(function(e78) {
            return e78.value;
          });
          var n2 = e77.filter(is_promise);
          if (n2.length) {
            return promise_all(e77).then(function(e78) {
              for (var t4 = 0, r3 = e78.length; t4 < r3; ++t4) {
                var n3 = m[t4].name;
                g(n3);
                h.set(n3, e78[t4]);
              }
            }).then(b);
          } else {
            var i = _createForOfIteratorHelper(m), a;
            try {
              for (i.s(); !(a = i.n()).done; ) {
                var o = a.value, u = o.name, s = o.value;
                g(u);
                h.set(u, s);
              }
            } catch (e78) {
              i.e(e78);
            } finally {
              i.f();
            }
          }
        }
        return b();
      } else {
        if (w === "let") {
          y = d;
        } else if (w === "letrec") {
          y = h;
        }
        var c = _evaluate(r2.cdr.car, { env: y, dynamic_env: l, use_dynamic: _, error: f });
        if (w === "let*") {
          y = h = y.inherit("let*[" + v + "]");
        }
        if (m) {
          m.push({ name: r2.car, value: c });
          return t3();
        } else {
          return unpromise(c, function(e78) {
            h.set(r2.car, e78);
            return t3();
          });
        }
      }
    }();
  });
}
function parallel(e75, c) {
  return new Macro(e75, function(e76) {
    var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = t2.use_dynamic, n = t2.error;
    var i = this;
    var a = this;
    var o = [];
    var u = e76;
    while (is_pair(u)) {
      o.push(_evaluate(u.car, { env: i, dynamic_env: a, use_dynamic: r, error: n }));
      u = u.cdr;
    }
    var s = o.filter(is_promise).length;
    if (s) {
      return promise_all(o).then(c.bind(this));
    } else {
      return c.call(this, o);
    }
  });
}
function guard_math_call(e75) {
  for (var t2 = arguments.length, r = new Array(t2 > 1 ? t2 - 1 : 0), n = 1; n < t2; n++) {
    r[n - 1] = arguments[n];
  }
  r.forEach(function(e76) {
    typecheck("", e76, "number");
  });
  return e75.apply(void 0, r);
}
function pipe() {
  var n = this;
  for (var e75 = arguments.length, i = new Array(e75), t2 = 0; t2 < e75; t2++) {
    i[t2] = arguments[t2];
  }
  i.forEach(function(e76, t3) {
    typecheck("pipe", e76, "function", t3 + 1);
  });
  return function() {
    for (var e76 = arguments.length, t3 = new Array(e76), r = 0; r < e76; r++) {
      t3[r] = arguments[r];
    }
    return i.reduce(function(e77, t4) {
      return [t4.apply(n, e77)];
    }, t3)[0];
  };
}
function compose() {
  for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
    t2[r] = arguments[r];
  }
  t2.forEach(function(e76, t3) {
    typecheck("compose", e76, "function", t3 + 1);
  });
  return pipe.apply(void 0, _toConsumableArray(t2.reverse()));
}
function fold(o, u) {
  var s = this;
  return function e75(t2, r) {
    typecheck(o, t2, "function");
    for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++) {
      i[a - 2] = arguments[a];
    }
    if (i.some(is_null)) {
      if (typeof r === "number") {
        return LNumber(r);
      }
      return r;
    } else {
      return u.call.apply(u, [s, e75, t2, r].concat(i));
    }
  };
}
function limit_math_op(e75, t2) {
  return limit(e75 + 1, curry(guard_math_call, t2));
}
function reduce_math_op(n) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  return function() {
    for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
      t2[r] = arguments[r];
    }
    if (i !== null) {
      t2 = [i].concat(_toConsumableArray(t2));
    }
    return t2.reduce(binary_math_op(n));
  };
}
function curry(o) {
  for (var e75 = arguments.length, t2 = new Array(e75 > 1 ? e75 - 1 : 0), r = 1; r < e75; r++) {
    t2[r - 1] = arguments[r];
  }
  typecheck("curry", o, "function");
  var u = o.length;
  return function() {
    var n = this;
    var i = t2.slice();
    var a = /* @__PURE__ */ function() {
      return function() {
        for (var e76 = arguments.length, t3 = new Array(e76), r2 = 0; r2 < e76; r2++) {
          t3[r2] = arguments[r2];
        }
        i = i.concat(t3);
        if (i.length >= u) {
          return o.apply(n, i);
        } else {
          return a;
        }
      };
    }();
    return a.apply(void 0, arguments);
  };
}
function limit(n, i) {
  typecheck("limit", i, "function", 2);
  return function() {
    for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
      t2[r] = arguments[r];
    }
    return i.apply(void 0, _toConsumableArray(t2.slice(0, n)));
  };
}
function LCharacter(e75) {
  if (typeof this !== "undefined" && !(this instanceof LCharacter) || typeof this === "undefined") {
    return new LCharacter(e75);
  }
  if (e75 instanceof LString) {
    e75 = e75.valueOf();
  }
  var t2;
  if (Array.from(e75).length > 1) {
    e75 = e75.toLowerCase();
    if (LCharacter.__names__[e75]) {
      t2 = e75;
      e75 = LCharacter.__names__[e75];
    } else {
      throw new Error("Internal: Unknown named character");
    }
  } else {
    t2 = LCharacter.__rev_names__[e75];
  }
  enumerable(this, "__char__", e75);
  if (t2) {
    enumerable(this, "__name__", t2);
  }
}
function LString(e75) {
  if (typeof this !== "undefined" && !(this instanceof LString) || typeof this === "undefined") {
    return new LString(e75);
  }
  if (e75 instanceof Array) {
    this.__string__ = e75.map(function(e76, t2) {
      typecheck("LString", e76, "character", t2 + 1);
      return e76.toString();
    }).join("");
  } else {
    this.__string__ = e75.valueOf();
  }
}
function LNumber(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (e75 instanceof LNumber) {
    return e75;
  }
  if (typeof this !== "undefined" && !(this instanceof LNumber) || typeof this === "undefined") {
    return new LNumber(e75, t2);
  }
  if (typeof e75 === "undefined") {
    throw new Error("Invalid LNumber constructor call");
  }
  var r = LNumber.getType(e75);
  if (LNumber.types[r]) {
    return LNumber.types[r](e75, t2);
  }
  var n = e75 instanceof Array && LString.isString(e75[0]) && LNumber.isNumber(e75[1]);
  if (e75 instanceof LNumber) {
    return LNumber(e75.value);
  }
  if (!LNumber.isNumber(e75) && !n) {
    throw new Error("You can't create LNumber from ".concat(type(e75)));
  }
  if (e75 === null) {
    e75 = 0;
  }
  var i;
  if (n) {
    var a = e75, o = _slicedToArray(a, 2), u = o[0], s = o[1];
    if (u instanceof LString) {
      u = u.valueOf();
    }
    if (s instanceof LNumber) {
      s = s.valueOf();
    }
    var c = u.match(/^([+-])/);
    var l = false;
    if (c) {
      u = u.replace(/^[+-]/, "");
      if (c[1] === "-") {
        l = true;
      }
    }
  }
  if (Number.isNaN(e75)) {
    return LFloat(e75);
  } else if (n && Number.isNaN(parseInt(u, s))) {
    return nan;
  } else if (typeof BigInt !== "undefined") {
    if (typeof e75 !== "bigint") {
      if (n) {
        var f;
        switch (s) {
          case 8:
            f = "0o";
            break;
          case 16:
            f = "0x";
            break;
          case 2:
            f = "0b";
            break;
          case 10:
            f = "";
            break;
        }
        if (typeof f === "undefined") {
          var _ = BigInt(s);
          i = _toConsumableArray(u).map(function(e76, t3) {
            return BigInt(parseInt(e76, s)) * pow(_, BigInt(t3));
          }).reduce(function(e76, t3) {
            return e76 + t3;
          });
        } else {
          i = BigInt(f + u);
        }
      } else {
        i = BigInt(e75);
      }
      if (l) {
        i *= BigInt(-1);
      }
    } else {
      i = e75;
    }
    return LBigInteger(i, true);
  } else if (typeof BN !== "undefined" && !(e75 instanceof BN)) {
    if (e75 instanceof Array) {
      return LBigInteger(_construct(BN, _toConsumableArray(e75)));
    }
    return LBigInteger(new BN(e75));
  } else if (n) {
    this.constant(parseInt(u, s), "integer");
  } else {
    this.constant(e75, "integer");
  }
}
function coerce(e75, t2, r, n) {
  return matrix[e75][t2](r, n);
}
function LComplex(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (typeof this !== "undefined" && !(this instanceof LComplex) || typeof this === "undefined") {
    return new LComplex(e75, t2);
  }
  if (e75 instanceof LComplex) {
    return LComplex({ im: e75.__im__, re: e75.__re__ });
  }
  if (LNumber.isNumber(e75) && t2) {
    if (!t2) {
      return Number(e75);
    }
  } else if (!LNumber.isComplex(e75)) {
    var r = "Invalid constructor call for LComplex expect &(:im <num> :re <num>) object but got ".concat(toString(e75));
    throw new Error(r);
  }
  var n = e75.im instanceof LNumber ? e75.im : LNumber(e75.im);
  var i = e75.re instanceof LNumber ? e75.re : LNumber(e75.re);
  this.constant(n, i);
}
function LFloat(e75) {
  if (typeof this !== "undefined" && !(this instanceof LFloat) || typeof this === "undefined") {
    return new LFloat(e75);
  }
  if (!LNumber.isNumber(e75)) {
    throw new Error("Invalid constructor call for LFloat");
  }
  if (e75 instanceof LNumber) {
    return LFloat(e75.valueOf());
  }
  if (typeof e75 === "number") {
    if (Object.is(e75, -0)) {
      Object.defineProperty(this, "_minus", { value: true });
    }
    this.constant(e75, "float");
  }
}
function approxRatio(n) {
  return function(e75) {
    var t2 = function e76(n2, t3, r2) {
      var i = function e77(t4, r3) {
        return r3 < n2 ? t4 : i(r3, t4 % r3);
      };
      if (Number.isNaN(t3) || Number.isNaN(r2)) {
        return NaN;
      }
      return i(Math.abs(t3), Math.abs(r2));
    }, r = t2(n ? n : 1 / 1e4, 1, e75);
    return LRational({ num: Math.floor(e75 / r), denom: Math.floor(1 / r) });
  };
}
function rationalize(e75, t2) {
  var r = e75.sub(t2);
  var n = e75.add(t2);
  var i;
  if (r.cmp(n) > 0) {
    i = simplest_rational2(n, r);
  } else if (n.cmp(r) <= 0) {
    i = r;
  } else if (r.cmp(0) > 0) {
    i = simplest_rational2(r, n);
  } else if (t2.cmp(0) < 0) {
    i = LNumber(simplest_rational2(n.sub(), r.sub())).sub();
  } else {
    i = LNumber(0);
  }
  if (LNumber.isFloat(t2) || LNumber.isFloat(e75)) {
    return LFloat(i);
  }
  return i;
}
function simplest_rational2(e75, t2) {
  var r = LNumber(e75).floor();
  var n = LNumber(t2).floor();
  if (e75.cmp(r) < 1) {
    return r;
  } else if (r.cmp(n) === 0) {
    var i = LNumber(1).div(t2.sub(n));
    var a = LNumber(1).div(e75.sub(r));
    return r.add(LNumber(1).div(simplest_rational2(i, a)));
  } else {
    return r.add(LNumber(1));
  }
}
function LRational(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (typeof this !== "undefined" && !(this instanceof LRational) || typeof this === "undefined") {
    return new LRational(e75, t2);
  }
  if (!LNumber.isRational(e75)) {
    throw new Error("Invalid constructor call for LRational");
  }
  var r, n;
  if (e75 instanceof LRational) {
    r = LNumber(e75.__num__);
    n = LNumber(e75.__denom__);
  } else {
    r = LNumber(e75.num);
    n = LNumber(e75.denom);
  }
  if (!t2 && n.cmp(0) !== 0) {
    var i = r.op("%", n).cmp(0) === 0;
    if (i) {
      return LNumber(r.div(n));
    }
  }
  this.constant(r, n);
}
function LBigInteger(e75, t2) {
  if (typeof this !== "undefined" && !(this instanceof LBigInteger) || typeof this === "undefined") {
    return new LBigInteger(e75, t2);
  }
  if (e75 instanceof LBigInteger) {
    return LBigInteger(e75.__value__, e75._native);
  }
  if (!LNumber.isBigInteger(e75)) {
    throw new Error("Invalid constructor call for LBigInteger");
  }
  this.constant(e75, "bigint");
  Object.defineProperty(this, "_native", { value: t2 });
}
function InputPort(e75) {
  var n = this;
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : global_env;
  if (typeof this !== "undefined" && !(this instanceof InputPort) || typeof this === "undefined") {
    return new InputPort(e75);
  }
  typecheck("InputPort", e75, "function");
  read_only(this, "__type__", text_port);
  var a;
  Object.defineProperty(this, "__parser__", { enumerable: true, get: function e76() {
    return a;
  }, set: function e76(t2) {
    typecheck("InputPort::__parser__", t2, "parser");
    a = t2;
  } });
  this._read = e75;
  this._with_parser = this._with_init_parser.bind(this, _asyncToGenerator(_regeneratorRuntime.mark(function e76() {
    var r;
    return _regeneratorRuntime.wrap(function e77(t2) {
      while (1) switch (t2.prev = t2.next) {
        case 0:
          if (n.char_ready()) {
            t2.next = 6;
            break;
          }
          t2.next = 3;
          return n._read();
        case 3:
          r = t2.sent;
          a = new Parser({ env: i });
          a.prepare(r);
        case 6:
          return t2.abrupt("return", n.__parser__);
        case 7:
        case "end":
          return t2.stop();
      }
    }, e76);
  })));
  this.char_ready = function() {
    return !!this.__parser__ && this.__parser__.__lexer__.peek() !== eof;
  };
  this._make_defaults();
}
function OutputPort(e75) {
  if (typeof this !== "undefined" && !(this instanceof OutputPort) || typeof this === "undefined") {
    return new OutputPort(e75);
  }
  typecheck("OutputPort", e75, "function");
  read_only(this, "__type__", text_port);
  this.write = e75;
}
function OutputStringPort(t2) {
  var r = this;
  if (typeof this !== "undefined" && !(this instanceof OutputStringPort) || typeof this === "undefined") {
    return new OutputStringPort(t2);
  }
  typecheck("OutputStringPort", t2, "function");
  read_only(this, "__type__", text_port);
  read_only(this, "__buffer__", []);
  this.write = function(e75) {
    if (!LString.isString(e75)) {
      e75 = t2(e75);
    } else {
      e75 = e75.valueOf();
    }
    r.__buffer__.push(e75);
  };
}
function OutputFilePort(e75, t2) {
  var r = this;
  if (typeof this !== "undefined" && !(this instanceof OutputFilePort) || typeof this === "undefined") {
    return new OutputFilePort(e75, t2);
  }
  typecheck("OutputFilePort", e75, "string");
  read_only(this, "__filename__", e75);
  read_only(this, "_fd", t2.valueOf(), { hidden: true });
  read_only(this, "__type__", text_port);
  this.write = function(e76) {
    if (!LString.isString(e76)) {
      e76 = to_string(e76);
    } else {
      e76 = e76.valueOf();
    }
    r.fs().write(r._fd, e76, function(e77) {
      if (e77) {
        throw e77;
      }
    });
  };
}
function InputStringPort(e75) {
  var t2 = this;
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : global_env;
  if (typeof this !== "undefined" && !(this instanceof InputStringPort) || typeof this === "undefined") {
    return new InputStringPort(e75);
  }
  typecheck("InputStringPort", e75, "string");
  e75 = e75.valueOf();
  this._with_parser = this._with_init_parser.bind(this, function() {
    if (!t2.__parser__) {
      t2.__parser__ = new Parser({ env: r });
      t2.__parser__.prepare(e75);
    }
    return t2.__parser__;
  });
  read_only(this, "__type__", text_port);
  this._make_defaults();
}
function ParserInputPort(e75) {
  if (typeof this !== "undefined" && !(this instanceof ParserInputPort) || typeof this === "undefined") {
    return new ParserInputPort(e75);
  }
  this._with_parser = this._with_init_parser.bind(this, function() {
    return e75;
  });
  read_only(this, "__type__", text_port);
  this._make_defaults();
}
function InputByteVectorPort(e75) {
  if (typeof this !== "undefined" && !(this instanceof InputByteVectorPort) || typeof this === "undefined") {
    return new InputByteVectorPort(e75);
  }
  typecheck("InputByteVectorPort", e75, "uint8array");
  read_only(this, "__vector__", e75);
  read_only(this, "__type__", binary_port);
  var r = 0;
  Object.defineProperty(this, "__index__", { enumerable: true, get: function e76() {
    return r;
  }, set: function e76(t2) {
    typecheck("InputByteVectorPort::__index__", t2, "number");
    if (t2 instanceof LNumber) {
      t2 = t2.valueOf();
    }
    if (typeof t2 === "bigint") {
      t2 = Number(t2);
    }
    if (Math.floor(t2) !== t2) {
      throw new Error("InputByteVectorPort::__index__ value is not integer");
    }
    r = t2;
  } });
}
function OutputByteVectorPort() {
  if (typeof this !== "undefined" && !(this instanceof OutputByteVectorPort) || typeof this === "undefined") {
    return new OutputByteVectorPort();
  }
  read_only(this, "__type__", binary_port);
  read_only(this, "_buffer", [], { hidden: true });
  this.write = function(e75) {
    typecheck("write", e75, ["number", "uint8array"]);
    if (LNumber.isNumber(e75)) {
      this._buffer.push(e75.valueOf());
    } else {
      var t2;
      (t2 = this._buffer).push.apply(t2, _toConsumableArray(Array.from(e75)));
    }
  };
  Object.defineProperty(this, "__buffer__", { enumerable: true, get: function e75() {
    return Uint8Array.from(this._buffer);
  } });
}
function InputFilePort(e75, t2) {
  if (typeof this !== "undefined" && !(this instanceof InputFilePort) || typeof this === "undefined") {
    return new InputFilePort(e75, t2);
  }
  InputStringPort.call(this, e75);
  typecheck("InputFilePort", t2, "string");
  read_only(this, "__filename__", t2);
}
function InputBinaryFilePort(e75, t2) {
  if (typeof this !== "undefined" && !(this instanceof InputBinaryFilePort) || typeof this === "undefined") {
    return new InputBinaryFilePort(e75, t2);
  }
  InputByteVectorPort.call(this, e75);
  typecheck("InputBinaryFilePort", t2, "string");
  read_only(this, "__filename__", t2);
}
function OutputBinaryFilePort(e75, t2) {
  var i = this;
  if (typeof this !== "undefined" && !(this instanceof OutputBinaryFilePort) || typeof this === "undefined") {
    return new OutputBinaryFilePort(e75, t2);
  }
  typecheck("OutputBinaryFilePort", e75, "string");
  read_only(this, "__filename__", e75);
  read_only(this, "_fd", t2.valueOf(), { hidden: true });
  read_only(this, "__type__", binary_port);
  var a;
  this.write = function(e76) {
    typecheck("write", e76, ["number", "uint8array"]);
    var n;
    if (!a) {
      a = i.internal("fs");
    }
    if (LNumber.isNumber(e76)) {
      n = new Uint8Array([e76.valueOf()]);
    } else {
      n = new Uint8Array(Array.from(e76));
    }
    return new Promise(function(t3, r) {
      a.write(i._fd, n, function(e77) {
        if (e77) {
          r(e77);
        } else {
          t3();
        }
      });
    });
  };
}
function EOF() {
}
function Interpreter(e75) {
  var t2 = this;
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = r.stderr, i = r.stdin, a = r.stdout, o = r.command_line, u = o === void 0 ? null : o, s = _objectWithoutProperties(r, _excluded3);
  if (typeof this !== "undefined" && !(this instanceof Interpreter) || typeof this === "undefined") {
    return new Interpreter(e75, _objectSpread({ stdin: i, stdout: a, stderr: n, command_line: u }, s));
  }
  if (typeof e75 === "undefined") {
    e75 = "anonymous";
  }
  this.__env__ = user_env.inherit(e75, s);
  this.__parser__ = new Parser({ env: this.__env__ });
  this.__env__.set("parent.frame", doc("parent.frame", function() {
    return t2.__env__;
  }, global_env.__env__["parent.frame"].__doc__));
  var c = "**interaction-environment-defaults**";
  this.set(c, get_props(s).concat(c));
  var l = internal_env.inherit("internal-".concat(e75));
  if (is_port(i)) {
    l.set("stdin", i);
  }
  if (is_port(n)) {
    l.set("stderr", n);
  }
  if (is_port(a)) {
    l.set("stdout", a);
  }
  l.set("command-line", u);
  set_interaction_env(this.__env__, l);
}
function LipsError(e75, t2) {
  this.name = "LipsError";
  this.message = e75;
  this.args = t2;
  this.stack = new Error().stack;
}
function Environment(e75, t2, r) {
  if (arguments.length === 1) {
    if (_typeof$1(arguments[0]) === "object") {
      e75 = arguments[0];
      t2 = null;
    } else if (typeof arguments[0] === "string") {
      e75 = {};
      t2 = null;
      r = arguments[0];
    }
  }
  this.__docs__ = /* @__PURE__ */ new Map();
  this.__env__ = e75;
  this.__parent__ = t2;
  this.__name__ = r || "anonymous";
}
function Value(e75) {
  if (typeof this !== "undefined" && !(this instanceof Value) || typeof this === "undefined") {
    return new Value(e75);
  }
  this.value = e75;
}
function Values(e75) {
  if (!e75.length) {
    return;
  }
  if (e75.length === 1) {
    return e75[0];
  }
  if (typeof this !== "undefined" && !(this instanceof Values) || typeof this === "undefined") {
    return new Values(e75);
  }
  this.__values__ = e75;
}
function quote(e75) {
  if (is_promise(e75)) {
    return e75.then(quote);
  }
  if (is_pair(e75) || e75 instanceof LSymbol) {
    e75[__data__] = true;
  }
  return e75;
}
function get_internal(e75) {
  return interaction(e75, "**internal-env**");
}
function internal(e75, t2) {
  var r = get_internal(e75);
  return r.get(t2);
}
function interaction(e75, t2) {
  var r = e75.get("**interaction-environment**");
  return r.get(t2);
}
function set_interaction_env(e75, t2) {
  e75.constant("**internal-env**", t2);
  e75.doc("**internal-env**", "**internal-env**\n\n         Constant used to hide stdin, stdout and stderr so they don't interfere\n         with variables with the same name. Constants are an internal type\n         of variable that can't be redefined, defining a variable with the same name\n         will throw an error.");
  global_env.set("**interaction-environment**", e75);
}
function set_fs(e75) {
  user_env.get("**internal-env**").set("fs", e75);
}
function allPossibleCases(e75) {
  if (e75.length === 1) {
    return e75[0];
  } else {
    var t2 = [];
    var r = allPossibleCases(e75.slice(1));
    for (var n = 0; n < r.length; n++) {
      for (var i = 0; i < e75[0].length; i++) {
        t2.push(e75[0][i] + r[n]);
      }
    }
    return t2;
  }
}
function combinations(e75, t2, r) {
  var n = [];
  for (var i = t2; i <= r; ++i) {
    var a = [];
    for (var o = 0; o < i; ++o) {
      a.push(e75);
    }
    n = n.concat(allPossibleCases(a));
  }
  return n;
}
function reversseFind(e75, t2) {
  var r = e75.split(path.sep).filter(Boolean);
  for (var n = r.length; n--; ) {
    var i;
    var a = (i = path).join.apply(i, ["/"].concat(_toConsumableArray(r.slice(0, n + 1))));
    if (t2(a)) {
      return a;
    }
  }
}
function nodeModuleFind(e75) {
  return reversseFind(e75, function(e76) {
    return fs.existsSync(path.join(e76, "node_modules"));
  });
}
function is_node() {
  return typeof global !== "undefined" && global.global === global;
}
function node_specific() {
  return _node_specific.apply(this, arguments);
}
function _node_specific() {
  _node_specific = _asyncToGenerator(_regeneratorRuntime.mark(function e75() {
    var r, n, i, a, o;
    return _regeneratorRuntime.wrap(function e76(t2) {
      while (1) switch (t2.prev = t2.next) {
        case 0:
          t2.next = 2;
          return import("module");
        case 2:
          r = t2.sent;
          n = r.createRequire;
          nodeRequire = n(import.meta.url);
          t2.next = 7;
          return import("fs");
        case 7:
          fs = t2.sent;
          t2.next = 10;
          return import("path");
        case 10:
          path = t2.sent;
          global_env.set("global", global);
          global_env.set("self", global);
          global_env.set("window", void 0);
          i = new URL(import.meta.url);
          a = path.dirname(i.pathname);
          o = path.basename(i.pathname);
          global_env.set("__dirname", a);
          global_env.set("__filename", o);
          global_env.set("require.resolve", doc("require.resolve", function(e77) {
            typecheck("require.resolve", e77, "string");
            var t3 = e77.valueOf();
            return nodeRequire.resolve(t3);
          }, "(require.resolve path)\n\n        Returns the path relative to the current module.\n\n        Only available when LIPS is running under Node.js."));
          global_env.set("require", doc("require", function(t3) {
            typecheck("require", t3, "string");
            t3 = t3.valueOf();
            var e77 = process.cwd();
            var r2;
            try {
              if (t3.match(/^\s*\./)) {
                r2 = nodeRequire(path.join(e77, t3));
              } else {
                var n2 = nodeModuleFind(e77);
                if (n2) {
                  r2 = nodeRequire(path.join(n2, "node_modules", t3));
                } else {
                  r2 = nodeRequire(t3);
                }
              }
            } catch (e78) {
              r2 = nodeRequire(t3);
            }
            return patch_value(r2, global);
          }, "(require module)\n\n        Function used inside Node.js to import a module."));
          process.on("unhandledRejection", function(e77, t3) {
            if (e77 instanceof IgnoreException) {
              t3["catch"](noop);
            }
          });
        case 22:
        case "end":
          return t2.stop();
      }
    }, e75);
  }));
  return _node_specific.apply(this, arguments);
}
function typeErrorMessage(e75, t2, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var i = e75 ? " in expression `".concat(e75, "`") : "";
  if (n !== null) {
    i += " (argument ".concat(n, ")");
  }
  if (is_function(r)) {
    return "Invalid type: got ".concat(t2).concat(i);
  }
  if (r instanceof Array) {
    if (r.length === 1) {
      var a = r[0].toLowerCase();
      r = "a" + ("aeiou".includes(a) ? "n " : " ") + r[0];
    } else {
      r = new Intl.ListFormat("en", { style: "long", type: "disjunction" }).format(r);
    }
  }
  return "Expecting ".concat(r, " got ").concat(t2).concat(i);
}
function typecheck_number(e75, t2, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  typecheck(e75, t2, "number", n);
  var i = t2.__type__;
  var a;
  if (is_pair(r)) {
    r = r.to_array();
  }
  if (r instanceof Array) {
    r = r.map(function(e76) {
      return e76.valueOf();
    });
  }
  if (r instanceof Array) {
    r = r.map(function(e76) {
      return e76.valueOf().toLowerCase();
    });
    if (r.includes(i)) {
      a = true;
    }
  } else {
    r = r.valueOf().toLowerCase();
  }
  if (!a && i !== r) {
    throw new Error(typeErrorMessage(e75, i, r, n));
  }
}
function typecheck_numbers(r, e75, n) {
  e75.forEach(function(e76, t2) {
    typecheck_number(r, e76, n, t2 + 1);
  });
}
function typecheck_args(r, e75, n) {
  e75.forEach(function(e76, t2) {
    typecheck(r, e76, n, t2 + 1);
  });
}
function typecheck_text_port(e75, t2, r) {
  typecheck(e75, t2, r);
  if (t2.__type__ === binary_port) {
    throw new Error(typeErrorMessage(e75, "binary-port", "textual-port"));
  }
}
function typecheck(e75, t2, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  e75 = e75.valueOf();
  var i = type(t2).toLowerCase();
  if (is_function(r)) {
    if (!r(t2)) {
      throw new Error(typeErrorMessage(e75, i, r, n));
    }
    return;
  }
  var a = false;
  if (is_pair(r)) {
    r = r.to_array();
  }
  if (r instanceof Array) {
    r = r.map(function(e76) {
      return e76.valueOf();
    });
  }
  if (r instanceof Array) {
    r = r.map(function(e76) {
      return e76.valueOf().toLowerCase();
    });
    if (r.includes(i)) {
      a = true;
    }
  } else {
    r = r.valueOf().toLowerCase();
  }
  if (!a && i !== r) {
    throw new Error(typeErrorMessage(e75, i, r, n));
  }
}
function memoize(r) {
  var n = /* @__PURE__ */ new WeakMap();
  return function(e75) {
    var t2 = n.get(e75);
    if (!t2) {
      t2 = r(e75);
    }
    return t2;
  };
}
function type(e75) {
  var t2 = type_constants.get(e75);
  if (t2) {
    return t2;
  }
  if (_typeof$1(e75) === "object") {
    for (var r = 0, n = Object.entries(type_mapping); r < n.length; r++) {
      var i = _slicedToArray(n[r], 2), a = i[0], o = i[1];
      if (e75 instanceof o) {
        return a;
      }
    }
    if (is_instance(e75)) {
      if (is_function(e75.typeOf)) {
        return e75.typeOf();
      }
      return "instance";
    }
    if (e75.constructor) {
      if (e75.constructor.__class__) {
        return e75.constructor.__class__;
      }
      if (e75.constructor === Object) {
        if (is_iterator(e75, Symbol.iterator)) {
          return "iterator";
        }
        if (is_iterator(e75, Symbol.asyncIterator)) {
          return "async-iterator";
        }
      }
      if (e75.constructor.name === "") {
        return "object";
      }
      return e75.constructor.name.toLowerCase();
    }
  }
  if (e75 === void 0) {
    return "void";
  }
  return _typeof$1(e75);
}
function resolve_promises(e75) {
  var t2 = [];
  r(e75);
  if (t2.length) {
    return a(e75);
  }
  return e75;
  function r(e76) {
    if (is_promise(e76)) {
      t2.push(e76);
    } else if (is_pair(e76)) {
      if (!e76.have_cycles("car")) {
        r(e76.car);
      }
      if (!e76.have_cycles("cdr")) {
        r(e76.cdr);
      }
    } else if (e76 instanceof Array) {
      e76.forEach(r);
    }
  }
  function n(e76) {
    return i.apply(this, arguments);
  }
  function i() {
    i = _asyncToGenerator(_regeneratorRuntime.mark(function e76(r2) {
      var n2;
      return _regeneratorRuntime.wrap(function e77(t3) {
        while (1) switch (t3.prev = t3.next) {
          case 0:
            t3.t0 = Pair;
            if (!r2.have_cycles("car")) {
              t3.next = 5;
              break;
            }
            t3.t1 = r2.car;
            t3.next = 8;
            break;
          case 5:
            t3.next = 7;
            return a(r2.car);
          case 7:
            t3.t1 = t3.sent;
          case 8:
            t3.t2 = t3.t1;
            if (!r2.have_cycles("cdr")) {
              t3.next = 13;
              break;
            }
            t3.t3 = r2.cdr;
            t3.next = 16;
            break;
          case 13:
            t3.next = 15;
            return a(r2.cdr);
          case 15:
            t3.t3 = t3.sent;
          case 16:
            t3.t4 = t3.t3;
            n2 = new t3.t0(t3.t2, t3.t4);
            if (r2[__data__]) {
              n2[__data__] = true;
            }
            return t3.abrupt("return", n2);
          case 20:
          case "end":
            return t3.stop();
        }
      }, e76);
    }));
    return i.apply(this, arguments);
  }
  function a(e76) {
    if (e76 instanceof Array) {
      return promise_all(e76.map(a));
    }
    if (is_pair(e76) && t2.length) {
      return n(e76);
    }
    return e76;
  }
}
function evaluate_args(e75, t2) {
  var r = t2.use_dynamic, n = _objectWithoutProperties(t2, _excluded5);
  var i = [];
  var a = e75;
  function o() {
    return i;
  }
  return function t3() {
    if (is_pair(a)) {
      var e76 = _evaluate(a.car, _objectSpread({ use_dynamic: r }, n));
      if (r) {
        e76 = unpromise(e76, function(e77) {
          if (is_native_function(e77)) {
            return e77.bind(dynamic_env);
          }
          return e77;
        });
      }
      return unpromise(resolve_promises(e76), function(e77) {
        i.push(e77);
        if (a.have_cycles("cdr")) {
          throw new Error("Invalid expression: Can't evaluate cycle");
        }
        a = a.cdr;
        return t3();
      });
    } else if (is_nil(a)) {
      return o();
    } else {
      throw new Error("Syntax Error: improper list found in apply");
    }
  }();
}
function evaluate_syntax(e75, t2, r) {
  var n = e75.invoke(t2, r);
  return unpromise(resolve_promises(n), function(e76) {
    if (is_pair(e76)) {
      e76.mark_cycles();
    }
    return quote(e76);
  });
}
function evaluate_macro(e75, t2, r) {
  function n(e76) {
    if (is_pair(e76)) {
      e76.mark_cycles();
      return e76;
    }
    return quote(e76);
  }
  var i = e75.invoke(t2, r);
  return unpromise(resolve_promises(i), function e76(t3) {
    if (!t3 || t3 && t3[__data__] || self_evaluated(t3)) {
      return t3;
    } else {
      return unpromise(_evaluate(t3, r), n);
    }
  }, function(e76) {
    throw e76;
  });
}
function prepare_fn_args(e75, t2) {
  if (is_bound(e75) && !is_object_bound(e75) && (!lips_context(e75) || is_port_method(e75))) {
    t2 = t2.map(unbox);
  }
  if (!is_raw_lambda(e75) && t2.some(is_lips_function) && !is_lips_function(e75) && !is_array_method(e75)) {
    var r = [], n = t2.length;
    var i = function e76() {
      var i2 = t2[n];
      if (is_lips_function(i2)) {
        a = function e77() {
          for (var t3 = arguments.length, r2 = new Array(t3), n2 = 0; n2 < t3; n2++) {
            r2[n2] = arguments[n2];
          }
          return unpromise(i2.apply(this, r2), unbox);
        };
        hidden_prop(a, "__bound__", true);
        hidden_prop(a, "__fn__", i2);
        a.prototype = i2.prototype;
        r[n] = a;
      } else {
        r[n] = i2;
      }
    }, a;
    while (n--) {
      i();
    }
    t2 = r;
  }
  return t2;
}
function call_function(e75, t2) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = r.env, i = r.dynamic_env, a = r.use_dynamic;
  var o = n === null || n === void 0 ? void 0 : n.new_frame(e75, t2);
  var u = i === null || i === void 0 ? void 0 : i.new_frame(e75, t2);
  var s = new LambdaContext({ env: o, use_dynamic: a, dynamic_env: u });
  return resolve_promises(e75.apply(s, t2));
}
function apply(n, e75) {
  var t2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = t2.env, a = t2.dynamic_env, o = t2.use_dynamic, r = t2.error, u = r === void 0 ? function() {
  } : r;
  e75 = evaluate_args(e75, { env: i, dynamic_env: a, error: u, use_dynamic: o });
  return unpromise(e75, function(e76) {
    if (is_raw_lambda(n)) {
      n = unbind(n);
    }
    e76 = prepare_fn_args(n, e76);
    var t3 = e76.slice();
    var r2 = call_function(n, t3, { env: i, dynamic_env: a, use_dynamic: o });
    return unpromise(r2, function(e77) {
      if (is_pair(e77)) {
        e77.mark_cycles();
        return quote(e77);
      }
      return box(e77);
    }, u);
  });
}
function search_param(e75, t2) {
  var r = e75.get(t2.__name__, { throwError: false });
  if (is_parameter(r) && r !== t2) {
    return r;
  }
  var n = user_env.get("**interaction-environment**");
  while (true) {
    var i = e75.get("parent.frame", { throwError: false });
    e75 = i(0);
    if (e75 === n) {
      break;
    }
    r = e75.get(t2.__name__, { throwError: false });
    if (is_parameter(r) && r !== t2) {
      return r;
    }
  }
  return t2;
}
function _evaluate(u) {
  var e75 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = e75.env, c = e75.dynamic_env, l = e75.use_dynamic, t2 = e75.error, f = t2 === void 0 ? noop : t2, r = _objectWithoutProperties(e75, _excluded6);
  return function(e76) {
    try {
      if (!is_env(c)) {
        c = s === true ? user_env : s || user_env;
      }
      if (l) {
        s = c;
      } else if (s === true) {
        s = user_env;
      } else {
        s = s || global_env;
      }
      var t3 = { env: s, dynamic_env: c, use_dynamic: l, error: f };
      var r2;
      if (is_null(u)) {
        return u;
      }
      if (u instanceof LSymbol) {
        return s.get(u);
      }
      if (!is_pair(u)) {
        return u;
      }
      var n = u.car;
      var e76 = u.cdr;
      if (is_pair(n)) {
        r2 = resolve_promises(_evaluate(n, t3));
        if (is_promise(r2)) {
          return r2.then(function(e77) {
            if (!is_callable(e77)) {
              throw new Error(type(e77) + " " + s.get("repr")(e77) + " is not callable while evaluating " + u.toString());
            }
            return _evaluate(new Pair(e77, u.cdr), t3);
          });
        } else if (!is_callable(r2)) {
          throw new Error(type(r2) + " " + s.get("repr")(r2) + " is not callable while evaluating " + u.toString());
        }
      }
      if (n instanceof LSymbol) {
        r2 = s.get(n);
      } else if (is_function(n)) {
        r2 = n;
      }
      var i;
      if (r2 instanceof Syntax) {
        i = evaluate_syntax(r2, u, t3);
      } else if (r2 instanceof Macro) {
        i = evaluate_macro(r2, e76, t3);
      } else if (is_function(r2)) {
        i = apply(r2, e76, t3);
      } else if (r2 instanceof SyntaxParameter) {
        i = evaluate_syntax(r2._syntax, u, t3);
      } else if (is_parameter(r2)) {
        var a = search_param(c, r2);
        if (is_null(u.cdr)) {
          i = a.invoke();
        } else {
          return unpromise(_evaluate(u.cdr.car, t3), function(e77) {
            a.__value__ = e77;
          });
        }
      } else if (is_continuation(r2)) {
        i = r2.invoke();
      } else if (is_pair(u)) {
        r2 = n && n.toString();
        throw new Error("".concat(type(n), " ").concat(r2, " is not a function"));
      } else {
        return u;
      }
      var o = s.get(Symbol["for"]("__promise__"), { throwError: false });
      if (o === true && is_promise(i)) {
        i = i.then(function(e77) {
          if (is_pair(e77) && !r2[__data__]) {
            return _evaluate(e77, t3);
          }
          return e77;
        });
        return new QuotedPromise(i);
      }
      return i;
    } catch (e77) {
      f && f.call(s, e77, u);
    }
  }(r);
}
function exec_with_stacktrace(e75) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = t2.env, n = t2.dynamic_env, i = t2.use_dynamic;
  return _evaluate(e75, { env: r, dynamic_env: n, use_dynamic: i, error: function e76(t3, r2) {
    if (t3 && t3.message) {
      if (t3.message.match(/^Error:/)) {
        var n2 = /^(Error:)\s*([^:]+:\s*)/;
        t3.message = t3.message.replace(n2, "$1 $2");
      }
      if (r2) {
        if (!(t3.__code__ instanceof Array)) {
          t3.__code__ = [];
        }
        t3.__code__.push(r2.toString(true));
      }
    }
    if (!(t3 instanceof IgnoreException)) {
      throw t3;
    }
  } });
}
function exec_collect(h) {
  return function() {
    var t2 = _asyncToGenerator(function(f) {
      var e76 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ = e76.env, p = e76.dynamic_env, d = e76.use_dynamic;
      return _regeneratorRuntime.mark(function e77() {
        var r, n, i, a, o, u, s, c, l;
        return _regeneratorRuntime.wrap(function e78(t3) {
          while (1) switch (t3.prev = t3.next) {
            case 0:
              if (!is_env(p)) {
                p = _ === true ? user_env : _ || user_env;
              }
              if (_ === true) {
                _ = user_env;
              } else {
                _ = _ || user_env;
              }
              r = [];
              if (!is_pair(f)) {
                t3.next = 8;
                break;
              }
              t3.next = 6;
              return exec_with_stacktrace(f, { env: _, dynamic_env: p, use_dynamic: d });
            case 6:
              t3.t0 = t3.sent;
              return t3.abrupt("return", [t3.t0]);
            case 8:
              n = Array.isArray(f) ? f : _parse(f);
              i = false;
              a = false;
              t3.prev = 11;
              u = _asyncIterator(n);
            case 13:
              t3.next = 15;
              return u.next();
            case 15:
              if (!(i = !(s = t3.sent).done)) {
                t3.next = 24;
                break;
              }
              c = s.value;
              t3.next = 19;
              return exec_with_stacktrace(c, { env: _, dynamic_env: p, use_dynamic: d });
            case 19:
              l = t3.sent;
              r.push(h(c, l));
            case 21:
              i = false;
              t3.next = 13;
              break;
            case 24:
              t3.next = 30;
              break;
            case 26:
              t3.prev = 26;
              t3.t1 = t3["catch"](11);
              a = true;
              o = t3.t1;
            case 30:
              t3.prev = 30;
              t3.prev = 31;
              if (!(i && u["return"] != null)) {
                t3.next = 35;
                break;
              }
              t3.next = 35;
              return u["return"]();
            case 35:
              t3.prev = 35;
              if (!a) {
                t3.next = 38;
                break;
              }
              throw o;
            case 38:
              return t3.finish(35);
            case 39:
              return t3.finish(30);
            case 40:
              return t3.abrupt("return", r);
            case 41:
            case "end":
              return t3.stop();
          }
        }, e77, null, [[11, 26, 30, 40], [31, , 35, 39]]);
      })();
    });
    function e75(e76) {
      return t2.apply(this, arguments);
    }
    return e75;
  }();
}
function balanced(e75) {
  var t2 = { "[": "]", "(": ")" };
  var r;
  if (typeof e75 === "string") {
    try {
      r = tokenize(e75);
    } catch (e76) {
      if (e76 instanceof Unterminated) {
        return false;
      }
      throw e76;
    }
  } else {
    r = e75.map(function(e76) {
      return e76 && e76.token ? e76.token : e76;
    });
  }
  var n = Object.keys(t2);
  var i = Object.values(t2).concat(n);
  r = r.filter(function(e76) {
    return i.includes(e76);
  });
  var a = new Stack();
  var o = _createForOfIteratorHelper(r), u;
  try {
    for (o.s(); !(u = o.n()).done; ) {
      var s = u.value;
      if (n.includes(s)) {
        a.push(s);
      } else if (!a.is_empty()) {
        var c = a.top();
        var l = t2[c];
        if (s === l) {
          a.pop();
        } else {
          throw new Error("Syntax error: missing closing ".concat(l));
        }
      } else {
        throw new Error("Syntax error: not matched closing ".concat(s));
      }
    }
  } catch (e76) {
    o.e(e76);
  } finally {
    o.f();
  }
  return a.is_empty();
}
function fworker(e75) {
  var t2 = "(" + e75.toString() + ")()";
  var r = window.URL || window.webkitURL;
  var n;
  try {
    n = new Blob([t2], { type: "application/javascript" });
  } catch (e76) {
    var i = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
    n = new i();
    n.append(t2);
    n = n.getBlob();
  }
  return new root.Worker(r.createObjectURL(n));
}
function is_dev() {
  return lips.version.match(/^(\{\{VER\}\}|DEV)$/);
}
function get_current_script() {
  if (is_node()) {
    return;
  }
  var e75;
  if (document.currentScript) {
    e75 = document.currentScript;
  } else {
    var t2 = document.querySelectorAll("script");
    if (!t2.length) {
      return;
    }
    e75 = t2[t2.length - 1];
  }
  var r = e75.getAttribute("src");
  return r;
}
function bootstrap() {
  var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var t2 = "dist/std.xcb";
  if (e75 === "") {
    if (current_script) {
      e75 = current_script.replace(/[^/]*$/, "std.xcb");
    } else if (is_dev()) {
      e75 = "https://cdn.jsdelivr.net/gh/jcubic/lips@devel/".concat(t2);
    } else {
      e75 = "https://cdn.jsdelivr.net/npm/@jcubic/lips@".concat(lips.version, "/").concat(t2);
    }
  }
  global_env.set("__dirname", e75.replace(/[^/]+$/, ""));
  var r = global_env.get("load");
  return r.call(user_env, e75, global_env);
}
function Worker2(e75) {
  this.url = e75;
  var o = this.worker = fworker(function() {
    var o2;
    var u;
    self.addEventListener("message", function(e76) {
      var r = e76.data;
      var t2 = r.id;
      if (r.type !== "RPC" || t2 === null) {
        return;
      }
      function n(e77) {
        self.postMessage({ id: t2, type: "RPC", result: e77 });
      }
      function i(e77) {
        self.postMessage({ id: t2, type: "RPC", error: e77 });
      }
      if (r.method === "eval") {
        if (!u) {
          i("Worker RPC: LIPS not initialized, call init first");
          return;
        }
        u.then(function() {
          var e77 = r.params[0];
          var t3 = r.params[1];
          o2.exec(e77, { use_dynamic: t3 }).then(function(e78) {
            e78 = e78.map(function(e79) {
              return e79 && e79.valueOf();
            });
            n(e78);
          })["catch"](function(e78) {
            i(e78);
          });
        });
      } else if (r.method === "init") {
        var a = r.params[0];
        if (typeof a !== "string") {
          i("Worker RPC: url is not a string");
        } else {
          importScripts("".concat(a, "/dist/lips.min.js"));
          o2 = new lips.Interpreter("worker");
          u = bootstrap(a);
          u.then(function() {
            n(true);
          });
        }
      }
    });
  });
  this.rpc = /* @__PURE__ */ function() {
    var n = 0;
    return function e76(t2, r) {
      var a = ++n;
      return new Promise(function(n2, i) {
        o.addEventListener("message", function e77(t3) {
          var r2 = t3.data;
          if (r2 && r2.type === "RPC" && r2.id === a) {
            if (r2.error) {
              i(r2.error);
            } else {
              n2(r2.result);
            }
            o.removeEventListener("message", e77);
          }
        });
        o.postMessage({ type: "RPC", method: t2, id: a, params: r });
      });
    };
  }();
  this.rpc("init", [e75])["catch"](function(e76) {
    console.error(e76);
  });
  this.exec = function(e76, t2) {
    var r = t2.use_dynamic, n = r === void 0 ? false : r;
    return this.rpc("eval", [e76, n]);
  };
}
function mangle_name(e75) {
  return class_map[e75];
}
function resolve_name(e75) {
  return available_class[e75];
}
function serialize(e75) {
  return JSON.stringify(e75, function(e76, t2) {
    var r = this[e76];
    if (r) {
      if (r instanceof RegExp) {
        return { "@": mangle_name("regex"), "#": [r.source, r.flags] };
      }
      var n = mangle_name(r.constructor.__class__);
      if (!is_undef(n)) {
        return { "@": n, "#": r.serialize() };
      }
    }
    return t2;
  });
}
function unserialize(e75) {
  return JSON.parse(e75, function(e76, t2) {
    if (t2 && _typeof$1(t2) === "object") {
      if (!is_undef(t2["@"])) {
        var r = resolve_name(t2["@"]);
        if (serialization_map[r]) {
          return serialization_map[r](t2["#"]);
        }
      }
    }
    return t2;
  });
}
function merge_uint8_array() {
  for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
    t2[r] = arguments[r];
  }
  if (t2.length > 1) {
    var n = t2.reduce(function(e76, t3) {
      return e76 + t3.length;
    }, 0);
    var i = new Uint8Array(n);
    var a = 0;
    t2.forEach(function(e76) {
      i.set(e76, a);
      a += e76.length;
    });
    return i;
  } else if (t2.length) {
    return t2[0];
  }
}
function encode_magic() {
  var e75 = 1;
  var t2 = new TextEncoder("utf-8");
  return t2.encode("LIPS".concat(e75.toString().padStart(3, " ")));
}
function decode_magic(e75) {
  var t2 = new TextDecoder("utf-8");
  var r = t2.decode(e75.slice(0, MAGIC_LENGTH));
  var n = r.substring(0, 4);
  if (n === "LIPS") {
    var i = r.match(/^(....).*([0-9]+)$/);
    if (i) {
      return { type: i[1], version: Number(i[2]) };
    }
  }
  return { type: "unknown" };
}
function serialize_bin(e75) {
  var t2 = encode_magic();
  var r = cbor.encode(e75);
  return merge_uint8_array(t2, lzjbPackExports.pack(r, { magic: false }));
}
function unserialize_bin(e75) {
  var t2 = decode_magic(e75), r = t2.type, n = t2.version;
  if (r === "LIPS" && n === 1) {
    var i = lzjbPackExports.unpack(e75.slice(MAGIC_LENGTH), { magic: false });
    return cbor.decode(i);
  } else {
    throw new Error("Invalid file format ".concat(r));
  }
}
function execError(e75) {
  console.error(e75.message || e75);
  if (Array.isArray(e75.code)) {
    console.error(e75.code.map(function(e76, t2) {
      return "[".concat(t2 + 1, "]: ").concat(e76);
    }));
  }
}
function init() {
  var o = ["text/x-lips", "text/x-scheme"];
  var u;
  function s(e76) {
    var t3;
    return (t3 = e76.getAttribute("data-bootstrap")) !== null && t3 !== void 0 ? t3 : e76.getAttribute("bootstrap");
  }
  function c(r2) {
    return new Promise(function(t3) {
      var e76 = r2.getAttribute("src");
      if (e76) {
        return fetch(e76).then(function(e77) {
          return e77.text();
        }).then(exec).then(t3)["catch"](function(e77) {
          execError(e77);
          t3();
        });
      } else {
        return exec(r2.innerHTML).then(t3)["catch"](function(e77) {
          execError(e77);
          t3();
        });
      }
    });
  }
  function e75() {
    return new Promise(function(i) {
      var a = Array.from(document.querySelectorAll("script"));
      return function e76() {
        var t3 = a.shift();
        if (!t3) {
          i();
        } else {
          var r2 = t3.getAttribute("type");
          if (o.includes(r2)) {
            var n = s(t3);
            if (!u && typeof n === "string") {
              return bootstrap(n).then(function() {
                return c(t3);
              }).then(e76);
            } else {
              return c(t3).then(e76);
            }
          } else if (r2 && r2.match(/lips|lisp/)) {
            console.warn("Expecting " + o.join(" or ") + " found " + r2);
          }
          return e76();
        }
      }();
    });
  }
  if (!window.document) {
    return Promise.resolve();
  } else if (currentScript) {
    var t2 = currentScript;
    var r = s(t2);
    if (typeof r === "string") {
      return bootstrap(r).then(function() {
        u = true;
        return e75();
      });
    }
  }
  return e75();
}
var regeneratorRuntime$1, _typeof, hasRequired_typeof, hasRequiredRegeneratorRuntime, regenerator, hasRequiredRegenerator, regeneratorExports, _regeneratorRuntime, decoder, src, srcEnd, position$1, LEGACY_RECORD_INLINE_ID, RECORD_DEFINITIONS_ID, RECORD_INLINE_ID, BUNDLED_STRINGS_ID, PACKED_REFERENCE_TAG_ID, STOP_CODE, maxArraySize, maxMapSize, currentDecoder, currentStructures, srcString, srcStringStart, srcStringEnd, bundledStrings$1, referenceMap, currentExtensions, currentExtensionRanges, packedValues, dataView, restoreMapsAsObject, defaultOptions, sequentialMode, inlineObjectReadThreshold, Decoder, validName, readFixedString, fromCharCode, f32Array, u8Array, Tag, recordDefinition, glbl, packedTable, SHARED_DATA_TAG_ID, isLittleEndianMachine$1, typedArrays, typedArrayTags, mult10, defaultDecoder, textEncoder, extensions, extensionClasses, Buffer$1, hasNodeBuffer, ByteArrayAllocate, ByteArray, MAX_STRUCTURES, MAX_BUFFER_SIZE, throwOnIterable, target, targetView, position, safeEnd, bundledStrings, MAX_BUNDLE_SIZE, hasNonLatin, RECORD_SYMBOL, Encoder, SharedData, BlobConstructor, isLittleEndianMachine, defaultEncoder, REUSE_BUFFER_MODE, RESET_BUFFER_MODE, THROW_ON_ITERABLE, lzjbPack, hasRequiredLzjbPack, lzjbPackExports, _excluded, _excluded2, _excluded3, _excluded4, _excluded5, _excluded6, root, type_mapping, type_constants, fs, path, nodeRequire, BN, re_re, float_stre, complex_float_stre, float_re, complex_list_re, characters, character_symbols, char_sre_re, char_re, complex_re, rational_re, int_re, int_bare_re, rational_bare_re, complex_bare_re, complex_bare_match_re, pre_num_parse_re, string_re, gensym, specials, defined_specials, builtins, Lexer, parsable_contants, directives, hash_literals, Parser, Unterminated, DatumReference, p_o, p_e, not_p, not_close, glob, sexp_or_atom, sexp, symbol, symbols, identifiers, let_value, syntax_rules, def_lambda_re, non_def, let_re, comment_re, fold_case_mapping, _nil, repr, props, array_methods, str_mapping, instances, native_types, truncate, macro, recur_guard, SyntaxParameter, __context__, __fn__, __data__, __ref__, __cycles__, __class__, __method__, __prototype__, __lambda__, exluded_names, single_math_op, binary_math_op, ignore, _keys, wrap, _iterator10, _step10, key, matrix, mapping, rev_mapping, pow, exp_op, toRational, BufferedOutputPort, binary_port, text_port, eof, IgnoreException, native_lambda, get2, internal_env, nan, constants, global_env, user_env, noop, node_ready, _p_name__, Parameter, LambdaContext, Continuation, compile, exec, current_script, serialization_map, available_class, class_map, _Object$entries3$_i, i, cls, _i6, _Object$entries3, cbor, MAGIC_LENGTH, currentScript, banner, version, date, parse, lips;
var init_lips_esm_min = __esm({
  "node_modules/.pnpm/@jcubic+lips@https+++codeload.github.com+jcubic+lips+tar.gz+876af5394f85e7b720f9a62545c19864bc1fe409/node_modules/@jcubic/lips/dist/lips.esm.min.js"() {
    AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
      return this;
    }, AsyncGenerator.prototype.next = function(e75) {
      return this._invoke("next", e75);
    }, AsyncGenerator.prototype["throw"] = function(e75) {
      return this._invoke("throw", e75);
    }, AsyncGenerator.prototype["return"] = function(e75) {
      return this._invoke("return", e75);
    };
    regeneratorRuntime$1 = { exports: {} };
    _typeof = { exports: {} };
    regeneratorExports = requireRegenerator();
    _regeneratorRuntime = getDefaultExportFromCjs(regeneratorExports);
    try {
      decoder = new TextDecoder();
    } catch (e75) {
    }
    position$1 = 0;
    LEGACY_RECORD_INLINE_ID = 105;
    RECORD_DEFINITIONS_ID = 57342;
    RECORD_INLINE_ID = 57343;
    BUNDLED_STRINGS_ID = 57337;
    PACKED_REFERENCE_TAG_ID = 6;
    STOP_CODE = {};
    maxArraySize = 11281e4;
    maxMapSize = 1681e4;
    currentDecoder = {};
    srcStringStart = 0;
    srcStringEnd = 0;
    currentExtensions = [];
    currentExtensionRanges = [];
    defaultOptions = { useRecords: false, mapsAsObjects: true };
    sequentialMode = false;
    inlineObjectReadThreshold = 2;
    try {
      new Function("");
    } catch (e75) {
      inlineObjectReadThreshold = Infinity;
    }
    Decoder = class _Decoder {
      constructor(r) {
        if (r) {
          if ((r.keyMap || r._keyMap) && !r.useRecords) {
            r.useRecords = false;
            r.mapsAsObjects = true;
          }
          if (r.useRecords === false && r.mapsAsObjects === void 0) r.mapsAsObjects = true;
          if (r.getStructures) r.getShared = r.getStructures;
          if (r.getShared && !r.structures) (r.structures = []).uninitialized = true;
          if (r.keyMap) {
            this.mapKey = /* @__PURE__ */ new Map();
            for (let [e75, t2] of Object.entries(r.keyMap)) this.mapKey.set(t2, e75);
          }
        }
        Object.assign(this, r);
      }
      decodeKey(e75) {
        return this.keyMap ? this.mapKey.get(e75) || e75 : e75;
      }
      encodeKey(e75) {
        return this.keyMap && this.keyMap.hasOwnProperty(e75) ? this.keyMap[e75] : e75;
      }
      encodeKeys(r) {
        if (!this._keyMap) return r;
        let n = /* @__PURE__ */ new Map();
        for (let [e75, t2] of Object.entries(r)) n.set(this._keyMap.hasOwnProperty(e75) ? this._keyMap[e75] : e75, t2);
        return n;
      }
      decodeKeys(e75) {
        if (!this._keyMap || e75.constructor.name != "Map") return e75;
        if (!this._mapKey) {
          this._mapKey = /* @__PURE__ */ new Map();
          for (let [e76, t2] of Object.entries(this._keyMap)) this._mapKey.set(t2, e76);
        }
        let r = {};
        e75.forEach((e76, t2) => r[safeKey(this._mapKey.has(t2) ? this._mapKey.get(t2) : t2)] = e76);
        return r;
      }
      mapDecode(e75, t2) {
        let r = this.decode(e75);
        if (this._keyMap) {
          switch (r.constructor.name) {
            case "Array":
              return r.map((e76) => this.decodeKeys(e76));
          }
        }
        return r;
      }
      decode(t2, e75) {
        if (src) {
          return saveState(() => {
            clearSource();
            return this ? this.decode(t2, e75) : _Decoder.prototype.decode.call(defaultOptions, t2, e75);
          });
        }
        srcEnd = e75 > -1 ? e75 : t2.length;
        position$1 = 0;
        srcStringEnd = 0;
        srcString = null;
        bundledStrings$1 = null;
        src = t2;
        try {
          dataView = t2.dataView || (t2.dataView = new DataView(t2.buffer, t2.byteOffset, t2.byteLength));
        } catch (e76) {
          src = null;
          if (t2 instanceof Uint8Array) throw e76;
          throw new Error("Source must be a Uint8Array or Buffer but was a " + (t2 && typeof t2 == "object" ? t2.constructor.name : typeof t2));
        }
        if (this instanceof _Decoder) {
          currentDecoder = this;
          packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
          if (this.structures) {
            currentStructures = this.structures;
            return checkedRead();
          } else if (!currentStructures || currentStructures.length > 0) {
            currentStructures = [];
          }
        } else {
          currentDecoder = defaultOptions;
          if (!currentStructures || currentStructures.length > 0) currentStructures = [];
          packedValues = null;
        }
        return checkedRead();
      }
      decodeMultiple(r, n) {
        let i, a = 0;
        try {
          let e75 = r.length;
          sequentialMode = true;
          let t2 = this ? this.decode(r, e75) : defaultDecoder.decode(r, e75);
          if (n) {
            if (n(t2) === false) {
              return;
            }
            while (position$1 < e75) {
              a = position$1;
              if (n(checkedRead()) === false) {
                return;
              }
            }
          } else {
            i = [t2];
            while (position$1 < e75) {
              a = position$1;
              i.push(checkedRead());
            }
            return i;
          }
        } catch (e75) {
          e75.lastPosition = a;
          e75.values = i;
          throw e75;
        } finally {
          sequentialMode = false;
          clearSource();
        }
      }
    };
    validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
    readFixedString = readStringJS;
    fromCharCode = String.fromCharCode;
    f32Array = new Float32Array(1);
    u8Array = new Uint8Array(f32Array.buffer, 0, 4);
    new Array(4096);
    Tag = class {
      constructor(e75, t2) {
        this.value = e75;
        this.tag = t2;
      }
    };
    currentExtensions[0] = (e75) => {
      return new Date(e75);
    };
    currentExtensions[1] = (e75) => {
      return new Date(Math.round(e75 * 1e3));
    };
    currentExtensions[2] = (r) => {
      let n = BigInt(0);
      for (let e75 = 0, t2 = r.byteLength; e75 < t2; e75++) {
        n = BigInt(r[e75]) + (n << BigInt(8));
      }
      return n;
    };
    currentExtensions[3] = (e75) => {
      return BigInt(-1) - currentExtensions[2](e75);
    };
    currentExtensions[4] = (e75) => {
      return +(e75[1] + "e" + e75[0]);
    };
    currentExtensions[5] = (e75) => {
      return e75[1] * Math.exp(e75[0] * Math.log(2));
    };
    recordDefinition = (e75, t2) => {
      e75 = e75 - 57344;
      let r = currentStructures[e75];
      if (r && r.isShared) {
        (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[e75] = r;
      }
      currentStructures[e75] = t2;
      t2.read = createStructureReader(t2);
    };
    currentExtensions[LEGACY_RECORD_INLINE_ID] = (r) => {
      let e75 = r.length;
      let n = r[1];
      recordDefinition(r[0], n);
      let i = {};
      for (let t2 = 2; t2 < e75; t2++) {
        let e76 = n[t2 - 2];
        i[safeKey(e76)] = r[t2];
      }
      return i;
    };
    currentExtensions[14] = (e75) => {
      if (bundledStrings$1) return bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 += e75);
      return new Tag(e75, 14);
    };
    currentExtensions[15] = (e75) => {
      if (bundledStrings$1) return bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += e75);
      return new Tag(e75, 15);
    };
    glbl = { Error, RegExp };
    currentExtensions[27] = (e75) => {
      return (glbl[e75[0]] || Error)(e75[1], e75[2]);
    };
    packedTable = (e75) => {
      if (src[position$1++] != 132) {
        let e76 = new Error("Packed values structure must be followed by a 4 element array");
        if (src.length < position$1) e76.incomplete = true;
        throw e76;
      }
      let t2 = e75();
      if (!t2 || !t2.length) {
        let e76 = new Error("Packed values structure must be followed by a 4 element array");
        e76.incomplete = true;
        throw e76;
      }
      packedValues = packedValues ? t2.concat(packedValues.slice(t2.length)) : t2;
      packedValues.prefixes = e75();
      packedValues.suffixes = e75();
      return e75();
    };
    packedTable.handlesRead = true;
    currentExtensions[51] = packedTable;
    currentExtensions[PACKED_REFERENCE_TAG_ID] = (e75) => {
      if (!packedValues) {
        if (currentDecoder.getShared) loadShared();
        else return new Tag(e75, PACKED_REFERENCE_TAG_ID);
      }
      if (typeof e75 == "number") return packedValues[16 + (e75 >= 0 ? 2 * e75 : -2 * e75 - 1)];
      let t2 = new Error("No support for non-integer packed references yet");
      if (e75 === void 0) t2.incomplete = true;
      throw t2;
    };
    currentExtensions[28] = (e75) => {
      if (!referenceMap) {
        referenceMap = /* @__PURE__ */ new Map();
        referenceMap.id = 0;
      }
      let t2 = referenceMap.id++;
      let r = position$1;
      let n = src[position$1];
      let i;
      if (n >> 5 == 4) i = [];
      else i = {};
      let a = { target: i };
      referenceMap.set(t2, a);
      let o = e75();
      if (a.used) {
        if (Object.getPrototypeOf(i) !== Object.getPrototypeOf(o)) {
          position$1 = r;
          i = o;
          referenceMap.set(t2, { target: i });
          o = e75();
        }
        return Object.assign(i, o);
      }
      a.target = o;
      return o;
    };
    currentExtensions[28].handlesRead = true;
    currentExtensions[29] = (e75) => {
      let t2 = referenceMap.get(e75);
      t2.used = true;
      return t2.target;
    };
    currentExtensions[258] = (e75) => new Set(e75);
    (currentExtensions[259] = (e75) => {
      if (currentDecoder.mapsAsObjects) {
        currentDecoder.mapsAsObjects = false;
        restoreMapsAsObject = true;
      }
      return e75();
    }).handlesRead = true;
    SHARED_DATA_TAG_ID = 1399353956;
    currentExtensionRanges.push((e75, t2) => {
      if (e75 >= 225 && e75 <= 255) return combine(getPackedValues().prefixes[e75 - 224], t2);
      if (e75 >= 28704 && e75 <= 32767) return combine(getPackedValues().prefixes[e75 - 28672], t2);
      if (e75 >= 1879052288 && e75 <= 2147483647) return combine(getPackedValues().prefixes[e75 - 1879048192], t2);
      if (e75 >= 216 && e75 <= 223) return combine(t2, getPackedValues().suffixes[e75 - 216]);
      if (e75 >= 27647 && e75 <= 28671) return combine(t2, getPackedValues().suffixes[e75 - 27639]);
      if (e75 >= 1811940352 && e75 <= 1879048191) return combine(t2, getPackedValues().suffixes[e75 - 1811939328]);
      if (e75 == SHARED_DATA_TAG_ID) {
        return { packedValues, structures: currentStructures.slice(0), version: t2 };
      }
      if (e75 == 55799) return t2;
    });
    isLittleEndianMachine$1 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
    typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, typeof BigUint64Array == "undefined" ? { name: "BigUint64Array" } : BigUint64Array, Int8Array, Int16Array, Int32Array, typeof BigInt64Array == "undefined" ? { name: "BigInt64Array" } : BigInt64Array, Float32Array, Float64Array];
    typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
    for (let e75 = 0; e75 < typedArrays.length; e75++) {
      registerTypedArray(typedArrays[e75], typedArrayTags[e75]);
    }
    mult10 = new Array(147);
    for (let e75 = 0; e75 < 256; e75++) {
      mult10[e75] = +("1e" + Math.floor(45.15 - e75 * 0.30103));
    }
    defaultDecoder = new Decoder({ useRecords: false });
    defaultDecoder.decode;
    defaultDecoder.decodeMultiple;
    try {
      textEncoder = new TextEncoder();
    } catch (e75) {
    }
    Buffer$1 = typeof globalThis === "object" && globalThis.Buffer;
    hasNodeBuffer = typeof Buffer$1 !== "undefined";
    ByteArrayAllocate = hasNodeBuffer ? Buffer$1.allocUnsafeSlow : Uint8Array;
    ByteArray = hasNodeBuffer ? Buffer$1 : Uint8Array;
    MAX_STRUCTURES = 256;
    MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
    position = 0;
    bundledStrings = null;
    MAX_BUNDLE_SIZE = 61440;
    hasNonLatin = /[\u0080-\uFFFF]/;
    RECORD_SYMBOL = Symbol("record-id");
    Encoder = class extends Decoder {
      constructor(r) {
        super(r);
        this.offset = 0;
        let s;
        let o;
        let c;
        let l;
        let n;
        r = r || {};
        let f = ByteArray.prototype.utf8Write ? function(e76, t2, r2) {
          return target.utf8Write(e76, t2, r2);
        } : textEncoder && textEncoder.encodeInto ? function(e76, t2) {
          return textEncoder.encodeInto(e76, target.subarray(t2)).written;
        } : false;
        let a = this;
        let e75 = r.structures || r.saveStructures;
        let _ = r.maxSharedStructures;
        if (_ == null) _ = e75 ? 128 : 0;
        if (_ > 8190) throw new Error("Maximum maxSharedStructure is 8190");
        let i = r.sequential;
        if (i) {
          _ = 0;
        }
        if (!this.structures) this.structures = [];
        if (this.saveStructures) this.saveShared = this.saveStructures;
        let p, d, u = r.sharedValues;
        let h;
        if (u) {
          h = /* @__PURE__ */ Object.create(null);
          for (let e76 = 0, t2 = u.length; e76 < t2; e76++) {
            h[u[e76]] = e76;
          }
        }
        let m = [];
        let y = 0;
        let v = 0;
        this.mapEncode = function(e76, t2) {
          if (this._keyMap && !this._mapped) {
            switch (e76.constructor.name) {
              case "Array":
                e76 = e76.map((e77) => this.encodeKeys(e77));
                break;
            }
          }
          return this.encode(e76, t2);
        };
        this.encode = function(t2, e76) {
          if (!target) {
            target = new ByteArrayAllocate(8192);
            targetView = new DataView(target.buffer, 0, 8192);
            position = 0;
          }
          safeEnd = target.length - 10;
          if (safeEnd - position < 2048) {
            target = new ByteArrayAllocate(target.length);
            targetView = new DataView(target.buffer, 0, target.length);
            safeEnd = target.length - 10;
            position = 0;
          } else if (e76 === REUSE_BUFFER_MODE) position = position + 7 & 2147483640;
          s = position;
          if (a.useSelfDescribedHeader) {
            targetView.setUint32(position, 3654940416);
            position += 3;
          }
          n = a.structuredClone ? /* @__PURE__ */ new Map() : null;
          if (a.bundleStrings && typeof t2 !== "string") {
            bundledStrings = [];
            bundledStrings.size = Infinity;
          } else bundledStrings = null;
          o = a.structures;
          if (o) {
            if (o.uninitialized) {
              let e78 = a.getShared() || {};
              a.structures = o = e78.structures || [];
              a.sharedVersion = e78.version;
              let r2 = a.sharedValues = e78.packedValues;
              if (r2) {
                h = {};
                for (let e79 = 0, t3 = r2.length; e79 < t3; e79++) h[r2[e79]] = e79;
              }
            }
            let e77 = o.length;
            if (e77 > _ && !i) e77 = _;
            if (!o.transitions) {
              o.transitions = /* @__PURE__ */ Object.create(null);
              for (let a2 = 0; a2 < e77; a2++) {
                let r2 = o[a2];
                if (!r2) continue;
                let n2, i2 = o.transitions;
                for (let t3 = 0, e78 = r2.length; t3 < e78; t3++) {
                  if (i2[RECORD_SYMBOL] === void 0) i2[RECORD_SYMBOL] = a2;
                  let e79 = r2[t3];
                  n2 = i2[e79];
                  if (!n2) {
                    n2 = i2[e79] = /* @__PURE__ */ Object.create(null);
                  }
                  i2 = n2;
                }
                i2[RECORD_SYMBOL] = a2 | 1048576;
              }
            }
            if (!i) o.nextId = e77;
          }
          if (c) c = false;
          l = o || [];
          d = h;
          if (r.pack) {
            let e77 = /* @__PURE__ */ new Map();
            e77.values = [];
            e77.encoder = a;
            e77.maxValues = r.maxPrivatePackedValues || (h ? 16 : Infinity);
            e77.objectMap = h || false;
            e77.samplingPackedValues = p;
            findRepetitiveStrings(t2, e77);
            if (e77.values.length > 0) {
              target[position++] = 216;
              target[position++] = 51;
              writeArrayHeader(4);
              let r2 = e77.values;
              b(r2);
              writeArrayHeader(0);
              writeArrayHeader(0);
              d = Object.create(h || null);
              for (let e78 = 0, t3 = r2.length; e78 < t3; e78++) {
                d[r2[e78]] = e78;
              }
            }
          }
          throwOnIterable = e76 & THROW_ON_ITERABLE;
          try {
            if (throwOnIterable) return;
            b(t2);
            if (bundledStrings) {
              writeBundles(s, b);
            }
            a.offset = position;
            if (n && n.idsToInsert) {
              position += n.idsToInsert.length * 2;
              if (position > safeEnd) w(position);
              a.offset = position;
              let e77 = insertIds(target.subarray(s, position), n.idsToInsert);
              n = null;
              return e77;
            }
            if (e76 & REUSE_BUFFER_MODE) {
              target.start = s;
              target.end = position;
              return target;
            }
            return target.subarray(s, position);
          } finally {
            if (o) {
              if (v < 10) v++;
              if (o.length > _) o.length = _;
              if (y > 1e4) {
                o.transitions = null;
                v = 0;
                y = 0;
                if (m.length > 0) m = [];
              } else if (m.length > 0 && !i) {
                for (let e77 = 0, t3 = m.length; e77 < t3; e77++) {
                  m[e77][RECORD_SYMBOL] = void 0;
                }
                m = [];
              }
            }
            if (c && a.saveShared) {
              if (a.structures.length > _) {
                a.structures = a.structures.slice(0, _);
              }
              let e77 = target.subarray(s, position);
              if (a.updateSharedData() === false) return a.encode(t2);
              return e77;
            }
            if (e76 & RESET_BUFFER_MODE) position = s;
          }
        };
        this.findCommonStringsToPack = () => {
          p = /* @__PURE__ */ new Map();
          if (!h) h = /* @__PURE__ */ Object.create(null);
          return (e76) => {
            let r2 = e76 && e76.threshold || 4;
            let n2 = this.pack ? e76.maxPrivatePackedValues || 16 : 0;
            if (!u) u = this.sharedValues = [];
            for (let [e77, t2] of p) {
              if (t2.count > r2) {
                h[e77] = n2++;
                u.push(e77);
                c = true;
              }
            }
            while (this.saveShared && this.updateSharedData() === false) {
            }
            p = null;
          };
        };
        const b = (o2) => {
          if (position > safeEnd) target = w(position);
          var e76 = typeof o2;
          var u2;
          if (e76 === "string") {
            if (d) {
              let e78 = d[o2];
              if (e78 >= 0) {
                if (e78 < 16) target[position++] = e78 + 224;
                else {
                  target[position++] = 198;
                  if (e78 & 1) b(15 - e78 >> 1);
                  else b(e78 - 16 >> 1);
                }
                return;
              } else if (p && !r.pack) {
                let e79 = p.get(o2);
                if (e79) e79.count++;
                else p.set(o2, { count: 1 });
              }
            }
            let i2 = o2.length;
            if (bundledStrings && i2 >= 4 && i2 < 1024) {
              if ((bundledStrings.size += i2) > MAX_BUNDLE_SIZE) {
                let e79;
                let t2 = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;
                if (position + t2 > safeEnd) target = w(position + t2);
                target[position++] = 217;
                target[position++] = 223;
                target[position++] = 249;
                target[position++] = bundledStrings.position ? 132 : 130;
                target[position++] = 26;
                e79 = position - s;
                position += 4;
                if (bundledStrings.position) {
                  writeBundles(s, b);
                }
                bundledStrings = ["", ""];
                bundledStrings.size = 0;
                bundledStrings.position = e79;
              }
              let e78 = hasNonLatin.test(o2);
              bundledStrings[e78 ? 0 : 1] += o2;
              target[position++] = e78 ? 206 : 207;
              b(i2);
              return;
            }
            let a2;
            if (i2 < 32) {
              a2 = 1;
            } else if (i2 < 256) {
              a2 = 2;
            } else if (i2 < 65536) {
              a2 = 3;
            } else {
              a2 = 5;
            }
            let e77 = i2 * 3;
            if (position + e77 > safeEnd) target = w(position + e77);
            if (i2 < 64 || !f) {
              let e78, t2, r2, n2 = position + a2;
              for (e78 = 0; e78 < i2; e78++) {
                t2 = o2.charCodeAt(e78);
                if (t2 < 128) {
                  target[n2++] = t2;
                } else if (t2 < 2048) {
                  target[n2++] = t2 >> 6 | 192;
                  target[n2++] = t2 & 63 | 128;
                } else if ((t2 & 64512) === 55296 && ((r2 = o2.charCodeAt(e78 + 1)) & 64512) === 56320) {
                  t2 = 65536 + ((t2 & 1023) << 10) + (r2 & 1023);
                  e78++;
                  target[n2++] = t2 >> 18 | 240;
                  target[n2++] = t2 >> 12 & 63 | 128;
                  target[n2++] = t2 >> 6 & 63 | 128;
                  target[n2++] = t2 & 63 | 128;
                } else {
                  target[n2++] = t2 >> 12 | 224;
                  target[n2++] = t2 >> 6 & 63 | 128;
                  target[n2++] = t2 & 63 | 128;
                }
              }
              u2 = n2 - position - a2;
            } else {
              u2 = f(o2, position + a2, e77);
            }
            if (u2 < 24) {
              target[position++] = 96 | u2;
            } else if (u2 < 256) {
              if (a2 < 2) {
                target.copyWithin(position + 2, position + 1, position + 1 + u2);
              }
              target[position++] = 120;
              target[position++] = u2;
            } else if (u2 < 65536) {
              if (a2 < 3) {
                target.copyWithin(position + 3, position + 2, position + 2 + u2);
              }
              target[position++] = 121;
              target[position++] = u2 >> 8;
              target[position++] = u2 & 255;
            } else {
              if (a2 < 5) {
                target.copyWithin(position + 5, position + 3, position + 3 + u2);
              }
              target[position++] = 122;
              targetView.setUint32(position, u2);
              position += 4;
            }
            position += u2;
          } else if (e76 === "number") {
            if (!this.alwaysUseFloat && o2 >>> 0 === o2) {
              if (o2 < 24) {
                target[position++] = o2;
              } else if (o2 < 256) {
                target[position++] = 24;
                target[position++] = o2;
              } else if (o2 < 65536) {
                target[position++] = 25;
                target[position++] = o2 >> 8;
                target[position++] = o2 & 255;
              } else {
                target[position++] = 26;
                targetView.setUint32(position, o2);
                position += 4;
              }
            } else if (!this.alwaysUseFloat && o2 >> 0 === o2) {
              if (o2 >= -24) {
                target[position++] = 31 - o2;
              } else if (o2 >= -256) {
                target[position++] = 56;
                target[position++] = ~o2;
              } else if (o2 >= -65536) {
                target[position++] = 57;
                targetView.setUint16(position, ~o2);
                position += 2;
              } else {
                target[position++] = 58;
                targetView.setUint32(position, ~o2);
                position += 4;
              }
            } else {
              let t2;
              if ((t2 = this.useFloat32) > 0 && o2 < 4294967296 && o2 >= -2147483648) {
                target[position++] = 250;
                targetView.setFloat32(position, o2);
                let e77;
                if (t2 < 4 || (e77 = o2 * mult10[(target[position] & 127) << 1 | target[position + 1] >> 7]) >> 0 === e77) {
                  position += 4;
                  return;
                } else position--;
              }
              target[position++] = 251;
              targetView.setFloat64(position, o2);
              position += 8;
            }
          } else if (e76 === "object") {
            if (!o2) target[position++] = 246;
            else {
              if (n) {
                let t2 = n.get(o2);
                if (t2) {
                  target[position++] = 216;
                  target[position++] = 29;
                  target[position++] = 25;
                  if (!t2.references) {
                    let e78 = n.idsToInsert || (n.idsToInsert = []);
                    t2.references = [];
                    e78.push(t2);
                  }
                  t2.references.push(position - s);
                  position += 2;
                  return;
                } else n.set(o2, { offset: position - s });
              }
              let e77 = o2.constructor;
              if (e77 === Object) {
                g(o2);
              } else if (e77 === Array) {
                u2 = o2.length;
                if (u2 < 24) {
                  target[position++] = 128 | u2;
                } else {
                  writeArrayHeader(u2);
                }
                for (let e78 = 0; e78 < u2; e78++) {
                  b(o2[e78]);
                }
              } else if (e77 === Map) {
                if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
                  target[position++] = 217;
                  target[position++] = 1;
                  target[position++] = 3;
                }
                u2 = o2.size;
                if (u2 < 24) {
                  target[position++] = 160 | u2;
                } else if (u2 < 256) {
                  target[position++] = 184;
                  target[position++] = u2;
                } else if (u2 < 65536) {
                  target[position++] = 185;
                  target[position++] = u2 >> 8;
                  target[position++] = u2 & 255;
                } else {
                  target[position++] = 186;
                  targetView.setUint32(position, u2);
                  position += 4;
                }
                if (a.keyMap) {
                  for (let [e78, t2] of o2) {
                    b(a.encodeKey(e78));
                    b(t2);
                  }
                } else {
                  for (let [e78, t2] of o2) {
                    b(e78);
                    b(t2);
                  }
                }
              } else {
                for (let r2 = 0, e78 = extensions.length; r2 < e78; r2++) {
                  let e79 = extensionClasses[r2];
                  if (o2 instanceof e79) {
                    let e80 = extensions[r2];
                    let t2 = e80.tag;
                    if (t2 == void 0) t2 = e80.getTag && e80.getTag.call(this, o2);
                    if (t2 < 24) {
                      target[position++] = 192 | t2;
                    } else if (t2 < 256) {
                      target[position++] = 216;
                      target[position++] = t2;
                    } else if (t2 < 65536) {
                      target[position++] = 217;
                      target[position++] = t2 >> 8;
                      target[position++] = t2 & 255;
                    } else if (t2 > -1) {
                      target[position++] = 218;
                      targetView.setUint32(position, t2);
                      position += 4;
                    }
                    e80.encode.call(this, o2, b, w);
                    return;
                  }
                }
                if (o2[Symbol.iterator]) {
                  if (throwOnIterable) {
                    let e78 = new Error("Iterable should be serialized as iterator");
                    e78.iteratorNotHandled = true;
                    throw e78;
                  }
                  target[position++] = 159;
                  for (let e78 of o2) {
                    b(e78);
                  }
                  target[position++] = 255;
                  return;
                }
                if (o2[Symbol.asyncIterator] || isBlob(o2)) {
                  let e78 = new Error("Iterable/blob should be serialized as iterator");
                  e78.iteratorNotHandled = true;
                  throw e78;
                }
                if (this.useToJSON && o2.toJSON) {
                  const t2 = o2.toJSON();
                  if (t2 !== o2) return b(t2);
                }
                g(o2);
              }
            }
          } else if (e76 === "boolean") {
            target[position++] = o2 ? 245 : 244;
          } else if (e76 === "bigint") {
            if (o2 < BigInt(1) << BigInt(64) && o2 >= 0) {
              target[position++] = 27;
              targetView.setBigUint64(position, o2);
            } else if (o2 > -(BigInt(1) << BigInt(64)) && o2 < 0) {
              target[position++] = 59;
              targetView.setBigUint64(position, -o2 - BigInt(1));
            } else {
              if (this.largeBigIntToFloat) {
                target[position++] = 251;
                targetView.setFloat64(position, Number(o2));
              } else {
                if (o2 >= BigInt(0)) target[position++] = 194;
                else {
                  target[position++] = 195;
                  o2 = BigInt(-1) - o2;
                }
                let e77 = [];
                while (o2) {
                  e77.push(Number(o2 & BigInt(255)));
                  o2 >>= BigInt(8);
                }
                writeBuffer(new Uint8Array(e77.reverse()), w);
                return;
              }
            }
            position += 8;
          } else if (e76 === "undefined") {
            target[position++] = 247;
          } else {
            throw new Error("Unknown type: " + e76);
          }
        };
        const g = this.useRecords === false ? this.variableMapSize ? (e76) => {
          let t2 = Object.keys(e76);
          let r2 = Object.values(e76);
          let n2 = t2.length;
          if (n2 < 24) {
            target[position++] = 160 | n2;
          } else if (n2 < 256) {
            target[position++] = 184;
            target[position++] = n2;
          } else if (n2 < 65536) {
            target[position++] = 185;
            target[position++] = n2 >> 8;
            target[position++] = n2 & 255;
          } else {
            target[position++] = 186;
            targetView.setUint32(position, n2);
            position += 4;
          }
          if (a.keyMap) {
            for (let e77 = 0; e77 < n2; e77++) {
              b(a.encodeKey(t2[e77]));
              b(r2[e77]);
            }
          } else {
            for (let e77 = 0; e77 < n2; e77++) {
              b(t2[e77]);
              b(r2[e77]);
            }
          }
        } : (t2) => {
          target[position++] = 185;
          let e76 = position - s;
          position += 2;
          let r2 = 0;
          if (a.keyMap) {
            for (let e77 in t2) if (typeof t2.hasOwnProperty !== "function" || t2.hasOwnProperty(e77)) {
              b(a.encodeKey(e77));
              b(t2[e77]);
              r2++;
            }
          } else {
            for (let e77 in t2) if (typeof t2.hasOwnProperty !== "function" || t2.hasOwnProperty(e77)) {
              b(e77);
              b(t2[e77]);
              r2++;
            }
          }
          target[e76++ + s] = r2 >> 8;
          target[e76 + s] = r2 & 255;
        } : (t2, e76) => {
          let r2, n2 = l.transitions || (l.transitions = /* @__PURE__ */ Object.create(null));
          let i2 = 0;
          let a2 = 0;
          let o2;
          let u2;
          if (this.keyMap) {
            u2 = Object.keys(t2).map((e77) => this.encodeKey(e77));
            a2 = u2.length;
            for (let t3 = 0; t3 < a2; t3++) {
              let e77 = u2[t3];
              r2 = n2[e77];
              if (!r2) {
                r2 = n2[e77] = /* @__PURE__ */ Object.create(null);
                i2++;
              }
              n2 = r2;
            }
          } else {
            for (let e77 in t2) if (typeof t2.hasOwnProperty !== "function" || t2.hasOwnProperty(e77)) {
              r2 = n2[e77];
              if (!r2) {
                if (n2[RECORD_SYMBOL] & 1048576) {
                  o2 = n2[RECORD_SYMBOL] & 65535;
                }
                r2 = n2[e77] = /* @__PURE__ */ Object.create(null);
                i2++;
              }
              n2 = r2;
              a2++;
            }
          }
          let s2 = n2[RECORD_SYMBOL];
          if (s2 !== void 0) {
            s2 &= 65535;
            target[position++] = 217;
            target[position++] = s2 >> 8 | 224;
            target[position++] = s2 & 255;
          } else {
            if (!u2) u2 = n2.__keys__ || (n2.__keys__ = Object.keys(t2));
            if (o2 === void 0) {
              s2 = l.nextId++;
              if (!s2) {
                s2 = 0;
                l.nextId = 1;
              }
              if (s2 >= MAX_STRUCTURES) {
                l.nextId = (s2 = _) + 1;
              }
            } else {
              s2 = o2;
            }
            l[s2] = u2;
            if (s2 < _) {
              target[position++] = 217;
              target[position++] = s2 >> 8 | 224;
              target[position++] = s2 & 255;
              n2 = l.transitions;
              for (let e77 = 0; e77 < a2; e77++) {
                if (n2[RECORD_SYMBOL] === void 0 || n2[RECORD_SYMBOL] & 1048576) n2[RECORD_SYMBOL] = s2;
                n2 = n2[u2[e77]];
              }
              n2[RECORD_SYMBOL] = s2 | 1048576;
              c = true;
            } else {
              n2[RECORD_SYMBOL] = s2;
              targetView.setUint32(position, 3655335680);
              position += 3;
              if (i2) y += v * i2;
              if (m.length >= MAX_STRUCTURES - _) m.shift()[RECORD_SYMBOL] = void 0;
              m.push(n2);
              writeArrayHeader(a2 + 2);
              b(57344 + s2);
              b(u2);
              if (e76) return;
              for (let e77 in t2) if (typeof t2.hasOwnProperty !== "function" || t2.hasOwnProperty(e77)) b(t2[e77]);
              return;
            }
          }
          if (a2 < 24) {
            target[position++] = 128 | a2;
          } else {
            writeArrayHeader(a2);
          }
          if (e76) return;
          for (let e77 in t2) if (typeof t2.hasOwnProperty !== "function" || t2.hasOwnProperty(e77)) b(t2[e77]);
        };
        const w = (e76) => {
          let t2;
          if (e76 > 16777216) {
            if (e76 - s > MAX_BUFFER_SIZE) throw new Error("Encoded buffer would be larger than maximum buffer size");
            t2 = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((e76 - s) * (e76 > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096);
          } else t2 = (Math.max(e76 - s << 2, target.length - 1) >> 12) + 1 << 12;
          let r2 = new ByteArrayAllocate(t2);
          targetView = new DataView(r2.buffer, 0, t2);
          if (target.copy) target.copy(r2, 0, s, e76);
          else r2.set(target.slice(s, e76));
          position -= s;
          s = 0;
          safeEnd = r2.length - 10;
          return target = r2;
        };
        let D = 100;
        let x = 1e3;
        this.encodeAsIterable = function(e76, t2) {
          return A(e76, t2, L);
        };
        this.encodeAsAsyncIterable = function(e76, t2) {
          return A(e76, t2, F);
        };
        function* L(n2, i2, e76) {
          let t2 = n2.constructor;
          if (t2 === Object) {
            let r2 = a.useRecords !== false;
            if (r2) g(n2, true);
            else writeEntityLength(Object.keys(n2).length, 160);
            for (let t3 in n2) {
              let e77 = n2[t3];
              if (!r2) b(t3);
              if (e77 && typeof e77 === "object") {
                if (i2[t3]) yield* L(e77, i2[t3]);
                else yield* E(e77, i2, t3);
              } else b(e77);
            }
          } else if (t2 === Array) {
            let e77 = n2.length;
            writeArrayHeader(e77);
            for (let t3 = 0; t3 < e77; t3++) {
              let e78 = n2[t3];
              if (e78 && (typeof e78 === "object" || position - s > D)) {
                if (i2.element) yield* L(e78, i2.element);
                else yield* E(e78, i2, "element");
              } else b(e78);
            }
          } else if (n2[Symbol.iterator] && !n2.buffer) {
            target[position++] = 159;
            for (let e77 of n2) {
              if (e77 && (typeof e77 === "object" || position - s > D)) {
                if (i2.element) yield* L(e77, i2.element);
                else yield* E(e77, i2, "element");
              } else b(e77);
            }
            target[position++] = 255;
          } else if (isBlob(n2)) {
            writeEntityLength(n2.size, 64);
            yield target.subarray(s, position);
            yield n2;
            S();
          } else if (n2[Symbol.asyncIterator]) {
            target[position++] = 159;
            yield target.subarray(s, position);
            yield n2;
            S();
            target[position++] = 255;
          } else {
            b(n2);
          }
          if (e76 && position > s) yield target.subarray(s, position);
          else if (position - s > D) {
            yield target.subarray(s, position);
            S();
          }
        }
        function* E(t2, r2, n2) {
          let i2 = position - s;
          try {
            b(t2);
            if (position - s > D) {
              yield target.subarray(s, position);
              S();
            }
          } catch (e76) {
            if (e76.iteratorNotHandled) {
              r2[n2] = {};
              position = s + i2;
              yield* L.call(this, t2, r2[n2]);
            } else throw e76;
          }
        }
        function S() {
          D = x;
          a.encode(null, THROW_ON_ITERABLE);
        }
        function A(e76, t2, r2) {
          if (t2 && t2.chunkThreshold) D = x = t2.chunkThreshold;
          else D = 100;
          if (e76 && typeof e76 === "object") {
            a.encode(null, THROW_ON_ITERABLE);
            return r2(e76, a.iterateProperties || (a.iterateProperties = {}), true);
          }
          return [a.encode(e76)];
        }
        async function* F(e76, t2) {
          for (let r2 of L(e76, t2, true)) {
            let e77 = r2.constructor;
            if (e77 === ByteArray || e77 === Uint8Array) yield r2;
            else if (isBlob(r2)) {
              let e78 = r2.stream().getReader();
              let t3;
              while (!(t3 = await e78.read()).done) {
                yield t3.value;
              }
            } else if (r2[Symbol.asyncIterator]) {
              for await (let e78 of r2) {
                S();
                if (e78) yield* F(e78, t2.async || (t2.async = {}));
                else yield a.encode(e78);
              }
            } else {
              yield r2;
            }
          }
        }
      }
      useBuffer(e75) {
        target = e75;
        targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
        position = 0;
      }
      clearSharedData() {
        if (this.structures) this.structures = [];
        if (this.sharedValues) this.sharedValues = void 0;
      }
      updateSharedData() {
        let t2 = this.sharedVersion || 0;
        this.sharedVersion = t2 + 1;
        let e75 = this.structures.slice(0);
        let r = new SharedData(e75, this.sharedValues, this.sharedVersion);
        let n = this.saveShared(r, (e76) => (e76 && e76.version || 0) == t2);
        if (n === false) {
          r = this.getShared() || {};
          this.structures = r.structures || [];
          this.sharedValues = r.packedValues;
          this.sharedVersion = r.version;
          this.structures.nextId = this.structures.length;
        } else {
          e75.forEach((e76, t3) => this.structures[t3] = e76);
        }
        return n;
      }
    };
    SharedData = class {
      constructor(e75, t2, r) {
        this.structures = e75;
        this.packedValues = t2;
        this.version = r;
      }
    };
    BlobConstructor = typeof Blob === "undefined" ? function() {
    } : Blob;
    isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
    extensionClasses = [Date, Set, Error, RegExp, Tag, ArrayBuffer, Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, typeof BigUint64Array == "undefined" ? function() {
    } : BigUint64Array, Int8Array, Int16Array, Int32Array, typeof BigInt64Array == "undefined" ? function() {
    } : BigInt64Array, Float32Array, Float64Array, SharedData];
    extensions = [{ tag: 1, encode(e75, t2) {
      let r = e75.getTime() / 1e3;
      if ((this.useTimestamp32 || e75.getMilliseconds() === 0) && r >= 0 && r < 4294967296) {
        target[position++] = 26;
        targetView.setUint32(position, r);
        position += 4;
      } else {
        target[position++] = 251;
        targetView.setFloat64(position, r);
        position += 8;
      }
    } }, { tag: 258, encode(e75, t2) {
      let r = Array.from(e75);
      t2(r);
    } }, { tag: 27, encode(e75, t2) {
      t2([e75.name, e75.message]);
    } }, { tag: 27, encode(e75, t2) {
      t2(["RegExp", e75.source, e75.flags]);
    } }, { getTag(e75) {
      return e75.tag;
    }, encode(e75, t2) {
      t2(e75.value);
    } }, { encode(e75, t2, r) {
      writeBuffer(e75, r);
    } }, { getTag(e75) {
      if (e75.constructor === Uint8Array) {
        if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false) return 64;
      }
    }, encode(e75, t2, r) {
      writeBuffer(e75, r);
    } }, typedArrayEncoder(68, 1), typedArrayEncoder(69, 2), typedArrayEncoder(70, 4), typedArrayEncoder(71, 8), typedArrayEncoder(72, 1), typedArrayEncoder(77, 2), typedArrayEncoder(78, 4), typedArrayEncoder(79, 8), typedArrayEncoder(85, 4), typedArrayEncoder(86, 8), { encode(t2, n) {
      let e75 = t2.packedValues || [];
      let r = t2.structures || [];
      if (e75.values.length > 0) {
        target[position++] = 216;
        target[position++] = 51;
        writeArrayHeader(4);
        let r2 = e75.values;
        n(r2);
        writeArrayHeader(0);
        writeArrayHeader(0);
        packedObjectMap = Object.create(sharedPackedObjectMap || null);
        for (let e76 = 0, t3 = r2.length; e76 < t3; e76++) {
          packedObjectMap[r2[e76]] = e76;
        }
      }
      if (r) {
        targetView.setUint32(position, 3655335424);
        position += 3;
        let e76 = r.slice(0);
        e76.unshift(57344);
        e76.push(new Tag(t2.version, 1399353956));
        n(e76);
      } else n(new Tag(t2.version, 1399353956));
    } }];
    defaultEncoder = new Encoder({ useRecords: false });
    defaultEncoder.encode;
    defaultEncoder.encodeAsIterable;
    defaultEncoder.encodeAsAsyncIterable;
    REUSE_BUFFER_MODE = 512;
    RESET_BUFFER_MODE = 1024;
    THROW_ON_ITERABLE = 2048;
    lzjbPack = {};
    lzjbPackExports = requireLzjbPack();
    _excluded = ["token"];
    _excluded2 = ["env"];
    _excluded3 = ["stderr", "stdin", "stdout", "command_line"];
    _excluded4 = ["use_dynamic"];
    _excluded5 = ["use_dynamic"];
    _excluded6 = ["env", "dynamic_env", "use_dynamic", "error"];
    root = typeof global !== "undefined" ? global : self;
    if (!root.fetch) {
      root.fetch = e;
    }
    type_mapping = { pair: Pair, symbol: LSymbol, number: LNumber, array: Array, nil: Nil, character: LCharacter, values: Values, "input-port": InputPort, "output-port": OutputPort, regex: RegExp, syntax: Syntax, eof: EOF, macro: Macro, string: LString, "native-symbol": Symbol };
    type_constants = /* @__PURE__ */ new Map([[NaN, "NaN"], [null, "null"]]);
    BN = root.BN;
    re_re = /^#\/((?:\\\/|[^/]|\[[^\]]*\/[^\]]*\])+)\/([gimyus]*)$/;
    float_stre = "(?:[-+]?(?:[0-9]+(?:[eE][-+]?[0-9]+)|(?:\\.[0-9]+|[0-9]+\\.[0-9]+)(?:[eE][-+]?[0-9]+)?)|[0-9]+\\.)";
    complex_float_stre = "(?:#[ie])?(?:[+-]?(?:[0-9][0-9_]*/[0-9][0-9_]*|nan.0|inf.0|".concat(float_stre, "|[+-]?[0-9]+))?(?:").concat(float_stre, "|[+-](?:[0-9]+/[0-9]+|[0-9]+|nan.0|inf.0))i");
    float_re = new RegExp("^(#[ie])?".concat(float_stre, "$"), "i");
    complex_list_re = function() {
      var a = {};
      [[10, "", "[0-9]"], [16, "x", "[0-9a-fA-F]"], [8, "o", "[0-7]"], [2, "b", "[01]"]].forEach(function(e75) {
        var t2 = _slicedToArray(e75, 3), r = t2[0], n = t2[1], i = t2[2];
        a[r] = make_complex_match_re(n, i);
      });
      return a;
    }();
    characters = { alarm: "\x07", backspace: "\b", delete: "", escape: "\x1B", newline: "\n", null: "\0", return: "\r", space: " ", tab: "	", dle: "", soh: "", dc1: "", stx: "", dc2: "", etx: "", dc3: "", eot: "", dc4: "", enq: "", nak: "", ack: "", syn: "", bel: "\x07", etb: "", bs: "\b", can: "", ht: "	", em: "", lf: "\n", sub: "", vt: "\v", esc: "\x1B", ff: "\f", fs: "", cr: "\r", gs: "", so: "", rs: "", si: "", us: "", del: "" };
    character_symbols = Object.keys(characters).join("|");
    char_sre_re = "#\\\\(?:x[0-9a-f]+|".concat(character_symbols, "|[\\s\\S])");
    char_re = new RegExp("^".concat(char_sre_re, "$"), "i");
    complex_re = make_type_re(gen_complex_re);
    rational_re = make_type_re(gen_rational_re);
    int_re = make_type_re(gen_integer_re);
    int_bare_re = new RegExp("^(?:" + gen_integer_re("", "[0-9a-f]") + ")$", "i");
    rational_bare_re = new RegExp("^(?:" + gen_rational_re("", "[0-9a-f]") + ")$", "i");
    complex_bare_re = new RegExp("^(?:" + gen_complex_re("", "[0-9a-f]") + ")$", "i");
    complex_bare_match_re = make_complex_match_re("", "[0-9a-fA-F]");
    pre_num_parse_re = /((?:#[xodbie]){0,2})(.*)/i;
    string_re = /"(?:\\[\S\s]|[^"])*"?/g;
    Stack.prototype.push = function(e75) {
      this.data.push(e75);
    };
    Stack.prototype.top = function() {
      return this.data[this.data.length - 1];
    };
    Stack.prototype.pop = function() {
      return this.data.pop();
    };
    Stack.prototype.is_empty = function() {
      return !this.data.length;
    };
    Thunk.prototype.toString = function() {
      return "#<Thunk>";
    };
    LSymbol.list = {};
    LSymbol.literal = Symbol["for"]("__literal__");
    LSymbol.object = Symbol["for"]("__object__");
    LSymbol.prototype.is_interned = function() {
      return LSymbol.list[this.__name__] == this;
    };
    LSymbol.is = function(e75, t2) {
      return e75 instanceof LSymbol && (t2 instanceof LSymbol && e75.__name__ === t2.__name__ || typeof t2 === "string" && e75.__name__ === t2 || t2 instanceof RegExp && t2.test(e75.__name__));
    };
    LSymbol.prototype.toString = function(e75) {
      if (is_symbol(this.__name__)) {
        return symbol_to_string(this.__name__);
      }
      var t2 = this.valueOf();
      if (e75 && t2.match(/(^;|[\s()[\]'])/)) {
        return "|".concat(t2, "|");
      }
      return t2;
    };
    LSymbol.prototype.literal = function() {
      if (this.is_gensym()) {
        return this[LSymbol.literal];
      }
      return this.valueOf();
    };
    LSymbol.prototype.serialize = function() {
      if (LString.isString(this.__name__)) {
        return this.__name__;
      }
      return [symbol_to_string(this.__name__)];
    };
    LSymbol.prototype.valueOf = function() {
      return this.__name__.valueOf();
    };
    LSymbol.prototype.is_gensym = function() {
      return is_gensym(this.__name__);
    };
    gensym = /* @__PURE__ */ function() {
      var t2 = 0;
      function r(e75, t3) {
        var r2 = new LSymbol(t3, false);
        hidden_prop(r2, "__literal__", e75);
        return r2;
      }
      return function() {
        var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        if (e75 instanceof LSymbol) {
          if (e75.is_gensym()) {
            return e75;
          }
          e75 = e75.valueOf();
        }
        if (is_gensym(e75)) {
          return LSymbol(e75, false);
        }
        if (e75 !== null) {
          return r(e75, Symbol("#:".concat(e75)));
        }
        t2++;
        return r(t2, Symbol("#:g".concat(t2)));
      };
    }();
    QuotedPromise.prototype.then = function(e75) {
      return new QuotedPromise(this.valueOf().then(e75));
    };
    QuotedPromise.prototype["catch"] = function(e75) {
      return new QuotedPromise(this.valueOf()["catch"](e75));
    };
    QuotedPromise.prototype.valueOf = function() {
      if (!this._promise) {
        throw new Error("QuotedPromise: invalid promise created");
      }
      return this._promise;
    };
    QuotedPromise.prototype.toString = function() {
      if (this.__pending__) {
        return QuotedPromise.pending_str;
      }
      if (this.__rejected__) {
        return QuotedPromise.rejected_str;
      }
      return "#<js-promise resolved (".concat(this.__type__, ")>");
    };
    QuotedPromise.pending_str = "#<js-promise (pending)>";
    QuotedPromise.rejected_str = "#<js-promise (rejected)>";
    specials = { LITERAL: Symbol["for"]("literal"), SPLICE: Symbol["for"]("splice"), SYMBOL: Symbol["for"]("symbol"), names: function e2() {
      return Object.keys(this.__list__);
    }, type: function e3(t2) {
      try {
        return this.get(t2).type;
      } catch (e75) {
        console.log({ name: t2 });
        console.log(e75);
        return null;
      }
    }, get: function e4(t2) {
      return this.__list__[t2];
    }, off: function e5(t2) {
      var r = this;
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (Array.isArray(t2)) {
        t2.forEach(function(e75) {
          return r.off(e75, n);
        });
      } else if (n === null) {
        delete this.__events__[t2];
      } else {
        this.__events__ = this.__events__.filter(function(e75) {
          return e75 !== n;
        });
      }
    }, on: function e6(t2, r) {
      var n = this;
      if (Array.isArray(t2)) {
        t2.forEach(function(e75) {
          return n.on(e75, r);
        });
      } else if (!this.__events__[t2]) {
        this.__events__[t2] = [r];
      } else {
        this.__events__[t2].push(r);
      }
    }, trigger: function e7(t2) {
      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) {
        n[i - 1] = arguments[i];
      }
      if (this.__events__[t2]) {
        this.__events__[t2].forEach(function(e75) {
          return e75.apply(void 0, n);
        });
      }
    }, remove: function e8(t2) {
      delete this.__list__[t2];
      this.trigger("remove");
    }, append: function e9(t2, r, n) {
      this.__list__[t2] = { seq: t2, symbol: r, type: n };
      this.trigger("append");
    }, __events__: {}, __list__: {} };
    defined_specials = [["'", new LSymbol("quote"), specials.LITERAL], ["`", new LSymbol("quasiquote"), specials.LITERAL], [",@", new LSymbol("unquote-splicing"), specials.LITERAL], [",", new LSymbol("unquote"), specials.LITERAL], ["'>", new LSymbol("quote-promise"), specials.LITERAL]];
    builtins = defined_specials.map(function(e75) {
      return e75[0];
    });
    Object.freeze(builtins);
    Object.defineProperty(specials, "__builtins__", { writable: false, enumerable: true, value: builtins });
    defined_specials.forEach(function(e75) {
      var t2 = _slicedToArray(e75, 3), r = t2[0], n = t2[1], i = t2[2];
      specials.append(r, n, i);
    });
    Lexer = function() {
      function v(e75) {
        var t2 = this;
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = r.whitespace, i = n === void 0 ? false : n;
        _classCallCheck(this, v);
        read_only(this, "__input__", e75);
        var a = {};
        ["_i", "_whitespace", "_col", "_newline", "_line", "_state", "_next", "_token", "_prev_char"].forEach(function(r2) {
          Object.defineProperty(t2, r2, { configurable: false, enumerable: false, get: function e76() {
            return a[r2];
          }, set: function e76(t3) {
            a[r2] = t3;
          } });
        });
        this._whitespace = i;
        this._i = this._line = this._col = this._newline = 0;
        this._state = this._next = this._token = null;
        this._prev_char = "";
      }
      return _createClass(v, [{ key: "get", value: function e75(t2) {
        return this.__internal[t2];
      } }, { key: "set", value: function e75(t2, r) {
        this.__internal[t2] = r;
      } }, { key: "token", value: function e75() {
        var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (t2) {
          var r = this._line;
          if (this._whitespace && this._token === "\n") {
            --r;
          }
          return { token: this._token, col: this._col, offset: this._i, line: r };
        }
        return this._token;
      } }, { key: "peek", value: function e75() {
        var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (this._i >= this.__input__.length) {
          return eof;
        }
        if (this._token) {
          read_only(this, "__token__", this.token(true));
          return this.token(t2);
        }
        var r = this.next_token();
        if (r) {
          this._token = this.__input__.substring(this._i, this._next);
          if (!this.__token__) {
            read_only(this, "__token__", this.token(true));
          }
          return this.token(t2);
        }
        return eof;
      } }, { key: "skip", value: function e75() {
        if (this._next !== null) {
          this._token = null;
          this._i = this._next;
        }
      } }, { key: "read_line", value: function e75() {
        var t2 = this.__input__.length;
        if (this._i >= t2) {
          return eof;
        }
        for (var r = this._i; r < t2; ++r) {
          var n = this.__input__[r];
          if (n === "\n") {
            var i = this.__input__.substring(this._i, r);
            this._i = r + 1;
            ++this._line;
            return i;
          }
        }
        return this.read_rest();
      } }, { key: "read_rest", value: function e75() {
        var t2 = this._i;
        this._i = this.__input__.length;
        return this.__input__.substring(t2);
      } }, { key: "read_string", value: function e75(t2) {
        var r = this.__input__.length;
        if (this._i >= r) {
          return eof;
        }
        if (t2 + this._i >= r) {
          return this.read_rest();
        }
        var n = this._i + t2;
        var i = this.__input__.substring(this._i, n);
        var a = i.match(/\n/g);
        if (a) {
          this._line += a.length;
        }
        this._i = n;
        return i;
      } }, { key: "peek_char", value: function e75() {
        if (this._i >= this.__input__.length) {
          return eof;
        }
        return LCharacter(this.__input__[this._i]);
      } }, { key: "read_char", value: function e75() {
        var t2 = this.peek_char();
        this.skip_char();
        return t2;
      } }, { key: "skip_char", value: function e75() {
        if (this._i < this.__input__.length) {
          ++this._i;
          this._token = null;
        }
      } }, { key: "match_rule", value: function e75(t2) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = r.prev_char, i = r["char"], a = r.next_char;
        var o = _slicedToArray(t2, 4), u = o[0], s = o[1], c = o[2], l = o[3];
        if (t2.length !== 5) {
          throw new Error("Lexer: Invalid rule of length ".concat(t2.length));
        }
        if (is_string(u)) {
          if (u !== i) {
            return false;
          }
        } else if (!i.match(u)) {
          return false;
        }
        if (!match_or_null(s, n)) {
          return false;
        }
        if (!match_or_null(c, a)) {
          return false;
        }
        if (l !== this._state) {
          return false;
        }
        return true;
      } }, { key: "next_token", value: function e75() {
        if (this._i >= this.__input__.length) {
          return false;
        }
        var t2 = true;
        e: for (var r = this._i, n = this.__input__.length; r < n; ++r) {
          var i = this.__input__[r];
          var a = this.__input__[r - 1] || "";
          var o = this.__input__[r + 1] || "";
          if (i === "\n") {
            ++this._line;
            var u = this._newline;
            if (this._state === null) {
              this._newline = r + 1;
            }
            if (this._whitespace && this._state === null) {
              this._next = r + 1;
              this._col = this._i - u;
              return true;
            }
          }
          if (t2 && this._state === null && i.match(/\s/)) {
            if (this._whitespace) {
              if (!o.match(/\s/)) {
                this._next = r + 1;
                this._col = this._i - this._newline;
                return true;
              } else {
                continue;
              }
            } else {
              this._i = r + 1;
              continue;
            }
          }
          t2 = false;
          var s = _createForOfIteratorHelper(v.rules), c;
          try {
            for (s.s(); !(c = s.n()).done; ) {
              var l = c.value;
              if (this.match_rule(l, { prev_char: a, char: i, next_char: o })) {
                var f = l[l.length - 1];
                this._state = f;
                if (this._state === null) {
                  this._next = r + 1;
                  this._col = this._i - this._newline;
                  return true;
                }
                continue e;
              }
            }
          } catch (e76) {
            s.e(e76);
          } finally {
            s.f();
          }
          if (this._state !== null) {
            continue e;
          }
          var _ = this.__input__.split("\n")[this._line];
          throw new Error("Invalid Syntax at line ".concat(this._line + 1, "\n").concat(_));
        }
        if (![null, v.comment].includes(this._state)) {
          var p, d;
          var h = (p = (d = this.__input__.substring(0, this._newline).match(/\n/g)) === null || d === void 0 ? void 0 : d.length) !== null && p !== void 0 ? p : 0;
          var m = this.__input__.substring(this._newline);
          if (this.__input__[this._i] === "#") {
            var y = this.__input__.substring(this._i).replace(/^([^\s()\[\]]+).*/, "$1");
            throw new Error("Invalid Syntax at line ".concat(h + 1, ": invalid token ").concat(y));
          }
          throw new Unterminated("Invalid Syntax at line ".concat(h + 1, ": Unterminated expression ").concat(m));
        }
      } }]);
    }();
    Lexer.literal_rule = function e10(t2, r) {
      var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      if (t2.length === 0) {
        throw new Error("Lexer: invalid literal rule");
      }
      if (t2.length === 1) {
        return [[t2, n, i, null, null]];
      }
      var a = [];
      for (var o = 0, u = t2.length; o < u; ++o) {
        var s = [];
        s.push(t2[o]);
        s.push(t2[o - 1] || n);
        s.push(t2[o + 1] || i);
        if (o === 0) {
          s.push(null);
          s.push(r);
        } else if (o === u - 1) {
          s.push(r);
          s.push(null);
        } else {
          s.push(r);
          s.push(r);
        }
        a.push(s);
      }
      return a;
    };
    Lexer.string = Symbol["for"]("string");
    Lexer.string_escape = Symbol["for"]("string_escape");
    Lexer.symbol = Symbol["for"]("symbol");
    Lexer.comment = Symbol["for"]("comment");
    Lexer.regex = Symbol["for"]("regex");
    Lexer.regex_init = Symbol["for"]("regex_init");
    Lexer.regex_class = Symbol["for"]("regex_class");
    Lexer.character = Symbol["for"]("character");
    Lexer.bracket = Symbol["for"]("bracket");
    Lexer.b_symbol = Symbol["for"]("b_symbol");
    Lexer.b_symbol_ex = Symbol["for"]("b_symbol_ex");
    Lexer.b_comment = Symbol["for"]("b_comment");
    Lexer.i_comment = Symbol["for"]("i_comment");
    Lexer.l_datum = Symbol["for"]("l_datum");
    Lexer.dot = Symbol["for"]("dot");
    Lexer.boundary = /^$|[\s()[\]']/;
    Lexer._rules = [[/"/, null, null, Lexer.string, null], [/"/, null, null, null, Lexer.string], [/"/, null, null, Lexer.string_escape, Lexer.string], [/\\/, null, null, Lexer.string, Lexer.string_escape], [/./, /\\/, null, Lexer.string_escape, Lexer.string], [/#/, null, /[bdxoei]/i, null, Lexer.symbol], [/#/, null, /\\/, null, Lexer.character], [/\\/, /#/, /\s/, Lexer.character, Lexer.character], [/\\/, /#/, /[()[\]]/, Lexer.character, Lexer.character], [/\s/, /\\/, null, Lexer.character, null], [/\S/, null, Lexer.boundary, Lexer.character, null], [/#/, Lexer.boundary, /\//, null, Lexer.regex_init], [/./, /\//, null, Lexer.regex_init, Lexer.regex], [/[ \t]/, null, null, Lexer.regex, Lexer.regex], [/\[/, /[^\\]/, null, Lexer.regex, Lexer.regex_class], [/\]/, /[^\\]/, null, Lexer.regex_class, Lexer.regex], [/[()[\]]/, null, null, Lexer.regex, Lexer.regex], [/\//, /\\/, null, Lexer.regex, Lexer.regex], [/\//, null, Lexer.boundary, Lexer.regex, null], [/[gimyus]/, /\//, Lexer.boundary, Lexer.regex, null], [/[gimyus]/, /\//, /[gimyus]/, Lexer.regex, Lexer.regex], [/[gimyus]/, /[gimyus]/, Lexer.boundary, Lexer.regex, null], [/;/, /^$|[^#]/, null, null, Lexer.comment], [/\n/, ";", null, Lexer.comment, null], [/[\s\S]/, null, /\n/, Lexer.comment, null], [/\s/, null, null, Lexer.comment, Lexer.comment], [/#/, null, /\|/, null, Lexer.b_comment], [/\s/, null, null, Lexer.b_comment, Lexer.b_comment], [/#/, /\|/, null, Lexer.b_comment, null], [/#/, null, /;/, null, Lexer.i_comment], [/;/, /#/, null, Lexer.i_comment, null], [/#/, null, /[0-9]/, null, Lexer.l_datum], [/=/, /[0-9]/, null, Lexer.l_datum, null], [/#/, /[0-9]/, null, Lexer.l_datum, null], [/\./, Lexer.boundary, /,/, null, null], [/\|/, null, null, null, Lexer.b_symbol], [/\s/, null, null, Lexer.b_symbol, Lexer.b_symbol], [/\|/, null, Lexer.boundary, Lexer.b_symbol, null], [/\|/, null, /\S/, Lexer.b_symbol, Lexer.b_symbol_ex], [/\S/, null, Lexer.boundary, Lexer.b_symbol_ex, null]];
    Lexer._brackets = [[/[()[\]]/, null, null, null, null]];
    Lexer._symbol_rules = [[/\S/, Lexer.boundary, Lexer.boundary, null, null], [/\S/, Lexer.boundary, null, null, Lexer.symbol], [/\S/, null, Lexer.boundary, null, null], [/\S/, null, null, null, Lexer.symbol], [/\S/, null, Lexer.boundary, Lexer.symbol, null]];
    Lexer._cache = { valid: false, rules: null };
    specials.on(["remove", "append"], function() {
      Lexer._cache.valid = false;
      Lexer._cache.rules = null;
    });
    parsable_contants = { "#null": null, "#void": void 0 };
    directives = ["#!fold-case", "#!no-fold-case"];
    hash_literals = ["#t", "#f"];
    Object.defineProperty(Lexer, "rules", { get: function e11() {
      if (Lexer._cache.valid) {
        return Lexer._cache.rules;
      }
      var t2 = Object.keys(parsable_contants).concat(directives, hash_literals);
      var r = specials.names().concat(t2).sort(function(e75, t3) {
        return t3.length - e75.length || e75.localeCompare(t3);
      });
      var n = r.reduce(function(e75, t3) {
        var r2;
        var n2 = null;
        if (t3[0] === "#") {
          if (t3.length === 1) {
            r2 = Symbol["for"](t3);
          } else {
            if (hash_literals.includes(t3)) {
              n2 = Lexer.boundary;
            }
            r2 = Symbol["for"](t3[1]);
          }
        } else {
          r2 = Symbol["for"](t3);
        }
        var i = Lexer.literal_rule(t3, r2, null, n2);
        return e75.concat(i);
      }, []);
      Lexer._cache.rules = Lexer._rules.concat(Lexer._brackets, n, Lexer._symbol_rules);
      Lexer._cache.valid = true;
      return Lexer._cache.rules;
    } });
    Parser = function() {
      function o() {
        var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t2 = e75.env, r = e75.meta, n = r === void 0 ? false : r, i = e75.formatter, a = i === void 0 ? multiline_formatter : i;
        _classCallCheck(this, o);
        read_only(this, "_formatter", a, { hidden: true });
        read_only(this, "__env__", t2);
        read_only(this, "_meta", n, { hidden: true });
        read_only(this, "_refs", [], { hidden: true });
        read_only(this, "_state", { parentheses: 0, line: 0, fold_case: false }, { hidden: true });
      }
      return _createClass(o, [{ key: "prepare", value: function e75(t2) {
        if (t2 instanceof LString) {
          t2 = t2.toString();
        }
        this._reset_state();
        read_only(this, "__lexer__", new Lexer(t2));
      } }, { key: "_with_syntax_scope", value: function e75(t2) {
        var r = get_internal(this.__env__);
        var n = r.get("stdin");
        global_env.set("lips", _objectSpread(_objectSpread({}, lips), {}, { __parser__: this }));
        r.set("stdin", new ParserInputPort(this, this.__env__));
        var i = function e76() {
          global_env.set("lips", lips);
          r.set("stdin", n);
        };
        return unpromise(t2(), function(e76) {
          i();
          return e76;
        }, i);
      } }, { key: "_reset_state", value: function e75() {
        Object.assign(this._state, { parentheses: 0, line: 0 });
      } }, { key: "_resolve", value: function e75(t2) {
        return this.__env__ && this.__env__.get(t2, { throwError: false });
      } }, { key: "_peek", value: function() {
        var e75 = _asyncToGenerator(_regeneratorRuntime.mark(function e76() {
          var r;
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                r = this.__lexer__.peek(true);
                if (!(r === eof)) {
                  t3.next = 4;
                  break;
                }
                return t3.abrupt("return", eof);
              case 4:
                if (!this._is_comment(r.token)) {
                  t3.next = 7;
                  break;
                }
                this.skip();
                return t3.abrupt("continue", 0);
              case 7:
                if (!is_directive(r.token)) {
                  t3.next = 11;
                  break;
                }
                this.skip();
                if (r.token === "#!fold-case") {
                  this._state.fold_case = true;
                } else if (r.token === "#!no-fold-case") {
                  this._state.fold_case = false;
                }
                return t3.abrupt("continue", 0);
              case 11:
                if (!(r.token === "#;")) {
                  t3.next = 18;
                  break;
                }
                this.skip();
                if (!(this.__lexer__.peek() === eof)) {
                  t3.next = 15;
                  break;
                }
                throw new Error("Lexer: syntax error eof found after comment");
              case 15:
                t3.next = 17;
                return this._read_object();
              case 17:
                return t3.abrupt("continue", 0);
              case 18:
                return t3.abrupt("break", 21);
              case 21:
                r = this._formatter(r);
                if (this._state.fold_case) {
                  r.token = foldcase_string(r.token);
                }
                return t3.abrupt("return", r);
              case 24:
              case "end":
                return t3.stop();
            }
          }, e76, this);
        }));
        function t2() {
          return e75.apply(this, arguments);
        }
        return t2;
      }() }, { key: "peek", value: function() {
        var e75 = _asyncToGenerator(_regeneratorRuntime.mark(function e76() {
          var r;
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                r = this._peek();
                if (!this._meta) {
                  t3.next = 3;
                  break;
                }
                return t3.abrupt("return", r);
              case 3:
                return t3.abrupt("return", r.token);
              case 4:
              case "end":
                return t3.stop();
            }
          }, e76, this);
        }));
        function t2() {
          return e75.apply(this, arguments);
        }
        return t2;
      }() }, { key: "_reset", value: function e75() {
        this._refs.length = 0;
      } }, { key: "skip", value: function e75() {
        this.__lexer__.skip();
      } }, { key: "_read", value: function() {
        var e75 = _asyncToGenerator(_regeneratorRuntime.mark(function e76() {
          var r;
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                t3.next = 2;
                return this._peek();
              case 2:
                r = t3.sent;
                this.skip();
                return t3.abrupt("return", r);
              case 5:
              case "end":
                return t3.stop();
            }
          }, e76, this);
        }));
        function t2() {
          return e75.apply(this, arguments);
        }
        return t2;
      }() }, { key: "read", value: function() {
        var e75 = _asyncToGenerator(_regeneratorRuntime.mark(function e76() {
          var r;
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                t3.next = 2;
                return this.peek();
              case 2:
                r = t3.sent;
                this.skip();
                return t3.abrupt("return", r);
              case 5:
              case "end":
                return t3.stop();
            }
          }, e76, this);
        }));
        function t2() {
          return e75.apply(this, arguments);
        }
        return t2;
      }() }, { key: "_match_datum_label", value: function e75(t2) {
        var r = t2.token.match(/^#([0-9]+)=$/);
        return r && r[1];
      } }, { key: "_match_datum_ref", value: function e75(t2) {
        var r = t2.token.match(/^#([0-9]+)#$/);
        return r && r[1];
      } }, { key: "_is_open", value: function e75(t2) {
        return ["(", "["].includes(t2.token);
      } }, { key: "_is_close", value: function e75(t2) {
        return [")", "]"].includes(t2.token);
      } }, { key: "_read_list", value: function() {
        var e75 = _asyncToGenerator(_regeneratorRuntime.mark(function e76() {
          var r, n, i, a, o2, u;
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                r = _nil, n = r;
              case 1:
                t3.next = 4;
                return this._peek();
              case 4:
                a = t3.sent;
                if (!(a === eof)) {
                  t3.next = 7;
                  break;
                }
                return t3.abrupt("break", 31);
              case 7:
                if (!this._is_close(a)) {
                  t3.next = 11;
                  break;
                }
                --this._state.parentheses;
                this.skip();
                return t3.abrupt("break", 31);
              case 11:
                if (!(a.token === "." && !is_nil(r))) {
                  t3.next = 19;
                  break;
                }
                this.skip();
                t3.next = 15;
                return this._read_object();
              case 15:
                n.cdr = t3.sent;
                i = true;
                t3.next = 29;
                break;
              case 19:
                if (!i) {
                  t3.next = 23;
                  break;
                }
                throw new Error("Parser: syntax error more than one element after dot");
              case 23:
                t3.next = 25;
                return this._read_object();
              case 25:
                o2 = t3.sent;
                u = new Pair(o2, _nil);
                if (is_nil(r)) {
                  r = u;
                } else {
                  n.cdr = u;
                }
                n = u;
              case 29:
                t3.next = 1;
                break;
              case 31:
                return t3.abrupt("return", r);
              case 32:
              case "end":
                return t3.stop();
            }
          }, e76, this);
        }));
        function t2() {
          return e75.apply(this, arguments);
        }
        return t2;
      }() }, { key: "_read_value", value: function() {
        var e75 = _asyncToGenerator(_regeneratorRuntime.mark(function e76() {
          var r;
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                t3.next = 2;
                return this._read();
              case 2:
                r = t3.sent;
                if (!(r === eof || r.token === eof)) {
                  t3.next = 5;
                  break;
                }
                throw new Error("Parser: Expected token eof found");
              case 5:
                return t3.abrupt("return", parse_argument(r, this._meta));
              case 6:
              case "end":
                return t3.stop();
            }
          }, e76, this);
        }));
        function t2() {
          return e75.apply(this, arguments);
        }
        return t2;
      }() }, { key: "_is_comment", value: function e75(t2) {
        return t2.match(/^;/) || t2.match(/^#\|/) && t2.match(/\|#$/);
      } }, { key: "evaluate", value: function e75(t2) {
        return _evaluate(t2, { env: this.__env__, error: function e76(t3) {
          throw t3;
        } });
      } }, { key: "read_object", value: function() {
        var e75 = _asyncToGenerator(_regeneratorRuntime.mark(function e76() {
          var r;
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                this._reset();
                t3.next = 3;
                return this._read_object();
              case 3:
                r = t3.sent;
                if (r instanceof DatumReference) {
                  r = r.valueOf();
                }
                if (!this._refs.length) {
                  t3.next = 7;
                  break;
                }
                return t3.abrupt("return", unpromise(this._resolve_object(r), function(e78) {
                  if (is_pair(e78)) {
                    e78.mark_cycles();
                  }
                  return e78;
                }));
              case 7:
                return t3.abrupt("return", r);
              case 8:
              case "end":
                return t3.stop();
            }
          }, e76, this);
        }));
        function t2() {
          return e75.apply(this, arguments);
        }
        return t2;
      }() }, { key: "balanced", value: function e75() {
        return this._state.parentheses === 0;
      } }, { key: "_ballancing_error", value: function e75(t2, r) {
        var n = this._state.parentheses;
        var i;
        if (n < 0) {
          i = new Error("Parser: unexpected parenthesis");
          if (r) {
            i.__code__ = [r.toString() + ")"];
          } else {
            i.__code__ = [")"];
          }
        } else {
          i = new Error("Parser: expected parenthesis but eof found");
          var a = new RegExp("\\){".concat(n, "}$"));
          i.__code__ = [t2.toString().replace(a, "")];
        }
        this._agument_exception(i);
        throw i;
      } }, { key: "_agument_exception", value: function e75(t2) {
        var r = this.__lexer__.__token__;
        if ("col" in r) {
          var n = r.col, i = r.offset, a = r.line;
          t2.message += " at line ".concat(a + 1, " and column ").concat(n + 1);
          read_only(t2, "__col__", n);
          read_only(t2, "__offset__", i);
          read_only(t2, "__line__", a);
        }
      } }, { key: "_resolve_object", value: function() {
        var t2 = _asyncToGenerator(_regeneratorRuntime.mark(function e76(r) {
          var n = this;
          var i;
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                if (!Array.isArray(r)) {
                  t3.next = 2;
                  break;
                }
                return t3.abrupt("return", r.map(function(e78) {
                  return n._resolve_object(e78);
                }));
              case 2:
                if (!is_plain_object(r)) {
                  t3.next = 6;
                  break;
                }
                i = {};
                Object.keys(r).forEach(function(e78) {
                  i[e78] = n._resolve_object(r[e78]);
                });
                return t3.abrupt("return", i);
              case 6:
                if (!is_pair(r)) {
                  t3.next = 8;
                  break;
                }
                return t3.abrupt("return", this._resolve_pair(r));
              case 8:
                return t3.abrupt("return", r);
              case 9:
              case "end":
                return t3.stop();
            }
          }, e76, this);
        }));
        function e75(e76) {
          return t2.apply(this, arguments);
        }
        return e75;
      }() }, { key: "_resolve_pair", value: function() {
        var t2 = _asyncToGenerator(_regeneratorRuntime.mark(function e76(r) {
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                if (!is_pair(r)) {
                  t3.next = 15;
                  break;
                }
                if (!(r.car instanceof DatumReference)) {
                  t3.next = 7;
                  break;
                }
                t3.next = 4;
                return r.car.valueOf();
              case 4:
                r.car = t3.sent;
                t3.next = 8;
                break;
              case 7:
                this._resolve_pair(r.car);
              case 8:
                if (!(r.cdr instanceof DatumReference)) {
                  t3.next = 14;
                  break;
                }
                t3.next = 11;
                return r.cdr.valueOf();
              case 11:
                r.cdr = t3.sent;
                t3.next = 15;
                break;
              case 14:
                this._resolve_pair(r.cdr);
              case 15:
                return t3.abrupt("return", r);
              case 16:
              case "end":
                return t3.stop();
            }
          }, e76, this);
        }));
        function e75(e76) {
          return t2.apply(this, arguments);
        }
        return e75;
      }() }, { key: "get_line", value: function e75() {
        return this._state.line;
      } }, { key: "_read_object", value: function() {
        var e75 = _asyncToGenerator(_regeneratorRuntime.mark(function e76() {
          var r = this;
          var n, i, a, o2, u, s, c, l, f, _, p, d, h, m, y, v;
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                t3.next = 2;
                return this._peek();
              case 2:
                n = t3.sent;
                if (!(n === eof)) {
                  t3.next = 5;
                  break;
                }
                return t3.abrupt("return", n);
              case 5:
                this._state.line = this.__lexer__.__token__.line;
                if (!is_special(n.token)) {
                  t3.next = 58;
                  break;
                }
                i = specials.get(n.token);
                a = is_builtin(n.token);
                this.skip();
                s = is_symbol_extension(n.token);
                t3.t0 = this;
                t3.next = 14;
                return this._peek();
              case 14:
                t3.t1 = t3.sent;
                c = t3.t0._is_close.call(t3.t0, t3.t1);
                if (!s) {
                  t3.next = 20;
                  break;
                }
                t3.t2 = void 0;
                t3.next = 23;
                break;
              case 20:
                t3.next = 22;
                return this._read_object();
              case 22:
                t3.t2 = t3.sent;
              case 23:
                l = t3.t2;
                if (!(l === eof)) {
                  t3.next = 26;
                  break;
                }
                throw new Unterminated("Expecting expression eof found");
              case 26:
                if (a) {
                  t3.next = 35;
                  break;
                }
                u = this.__env__.get(i.symbol);
                if (!(typeof u === "function")) {
                  t3.next = 35;
                  break;
                }
                if (is_literal(n.token)) {
                  f = [l];
                } else if (is_nil(l)) {
                  f = [];
                } else if (is_pair(l)) {
                  f = l.to_array(false);
                }
                if (!(f || s)) {
                  t3.next = 32;
                  break;
                }
                return t3.abrupt("return", this._with_syntax_scope(function() {
                  return call_function(u, s ? [] : f, { env: r.__env__, dynamic_env: r.__env__, use_dynamic: false });
                }));
              case 32:
                _ = new Error("Parse Error: Invalid parser extension " + "invocation ".concat(i.symbol));
                this._agument_exception(_);
                throw _;
              case 35:
                if (!is_literal(n.token)) {
                  t3.next = 43;
                  break;
                }
                if (!c) {
                  t3.next = 40;
                  break;
                }
                p = new Error("Parse Error: expecting datum");
                this._agument_exception(p);
                throw p;
              case 40:
                o2 = new Pair(i.symbol, new Pair(l, _nil));
                t3.next = 44;
                break;
              case 43:
                o2 = new Pair(i.symbol, l);
              case 44:
                if (!a) {
                  t3.next = 46;
                  break;
                }
                return t3.abrupt("return", o2);
              case 46:
                if (!(u instanceof Macro)) {
                  t3.next = 55;
                  break;
                }
                t3.next = 49;
                return this._with_syntax_scope(function() {
                  return r.evaluate(o2);
                });
              case 49:
                d = t3.sent;
                if (!(is_pair(d) || d instanceof LSymbol)) {
                  t3.next = 52;
                  break;
                }
                return t3.abrupt("return", Pair.fromArray([LSymbol("quote"), d]));
              case 52:
                return t3.abrupt("return", d);
              case 55:
                h = new Error("Parse Error: invalid parser extension: " + i.symbol);
                this._agument_exception(h);
                throw h;
              case 58:
                m = this._match_datum_ref(n);
                if (!(m !== null)) {
                  t3.next = 66;
                  break;
                }
                this.skip();
                if (!this._refs[m]) {
                  t3.next = 63;
                  break;
                }
                return t3.abrupt("return", new DatumReference(m, this._refs[m]));
              case 63:
                y = new Error("Parse Error: invalid datum label #".concat(m, "#"));
                this._agument_exception(y);
                throw y;
              case 66:
                v = this._match_datum_label(n);
                if (!(v !== null)) {
                  t3.next = 73;
                  break;
                }
                this.skip();
                this._refs[v] = this._read_object();
                return t3.abrupt("return", this._refs[v]);
              case 73:
                if (!this._is_close(n)) {
                  t3.next = 78;
                  break;
                }
                --this._state.parentheses;
                this.skip();
                t3.next = 85;
                break;
              case 78:
                if (!this._is_open(n)) {
                  t3.next = 84;
                  break;
                }
                ++this._state.parentheses;
                this.skip();
                return t3.abrupt("return", this._read_list());
              case 84:
                return t3.abrupt("return", this._read_value());
              case 85:
              case "end":
                return t3.stop();
            }
          }, e76, this);
        }));
        function t2() {
          return e75.apply(this, arguments);
        }
        return t2;
      }() }]);
    }();
    Unterminated = function(e75) {
      function t2() {
        _classCallCheck(this, t2);
        return _callSuper(this, t2, arguments);
      }
      _inherits(t2, e75);
      return _createClass(t2);
    }(_wrapNativeSuper(Error));
    Parser.Unterminated = Unterminated;
    DatumReference = function() {
      function r(e75, t2) {
        _classCallCheck(this, r);
        this.name = e75;
        this.data = t2;
      }
      return _createClass(r, [{ key: "valueOf", value: function e75() {
        return this.data;
      } }]);
    }();
    Formatter.defaults = { offset: 0, indent: 2, exceptions: { specials: [/^(?:#:)?(?:define(?:-values|-syntax|-macro|-class|-record-type)?|(?:call-with-(?:input-file|output-file|port))|lambda|let-env|try|catch|when|unless|while|syntax-rules|(let|letrec)(-syntax|\*?-values|\*)?)$/], shift: { 1: ["&", "#"] } } };
    Formatter.match = match;
    Formatter.prototype._options = function e12(t2) {
      var r = Formatter.defaults;
      if (typeof t2 === "undefined") {
        return Object.assign({}, r);
      }
      var n = t2 && t2.exceptions || {};
      var i = n.specials || [];
      var a = n.shift || { 1: [] };
      return _objectSpread(_objectSpread(_objectSpread({}, r), t2), {}, { exceptions: { specials: [].concat(_toConsumableArray(r.exceptions.specials), _toConsumableArray(i)), shift: _objectSpread(_objectSpread({}, a), {}, { 1: [].concat(_toConsumableArray(r.exceptions.shift[1]), _toConsumableArray(a[1])) }) } });
    };
    Formatter.prototype.indent = function e13(t2) {
      var r = tokenize(this.__code__, true);
      return this._indent(r, t2);
    };
    Formatter.exception_shift = function(a, e75) {
      function t2(e76) {
        if (!e76.length) {
          return false;
        }
        if (e76.indexOf(a) !== -1) {
          return true;
        } else {
          var t3 = e76.filter(function(e77) {
            return e77 instanceof RegExp;
          });
          if (!t3.length) {
            return false;
          }
          var r2 = _createForOfIteratorHelper(t3), n2;
          try {
            for (r2.s(); !(n2 = r2.n()).done; ) {
              var i2 = n2.value;
              if (a.match(i2)) {
                return true;
              }
            }
          } catch (e77) {
            r2.e(e77);
          } finally {
            r2.f();
          }
        }
        return false;
      }
      if (t2(e75.exceptions.specials)) {
        return e75.indent;
      }
      var r = e75.exceptions.shift;
      for (var n = 0, i = Object.entries(r); n < i.length; n++) {
        var o = _slicedToArray(i[n], 2), u = o[0], s = o[1];
        if (t2(s)) {
          return +u;
        }
      }
      return -1;
    };
    Formatter.prototype._indent = function e14(t2, r) {
      var n = this._options(r);
      var i = lineIndent(t2);
      var a = previousSexp(t2);
      var o = t2[t2.length - a.length - 1];
      var u = t2[t2.length - 1];
      if (u.token.match(/^"[\S\s]+[^"]$/)) {
        return i + n.indent;
      }
      if (a && a.length) {
        if (a[0].line > 0) {
          n.offset = 0;
        }
        if (a.toString() === t2.toString() && balanced(a)) {
          return n.offset + a[0].col;
        } else if (a.length === 1) {
          return n.offset + a[0].col + 1;
        } else {
          var s = -1;
          if (o) {
            var c = Formatter.exception_shift(o.token, n);
            if (c !== -1) {
              s = c;
            }
          }
          if (s === -1) {
            s = Formatter.exception_shift(a[1].token, n);
          }
          if (s !== -1) {
            return n.offset + a[0].col + s;
          } else if (a[0].line < a[1].line) {
            return n.offset + a[0].col + 1;
          } else if (a.length > 3 && a[1].line === a[3].line) {
            if (a[1].token === "(" || a[1].token === "[") {
              return n.offset + a[1].col;
            }
            return n.offset + a[3].col;
          } else if (a[0].line === a[1].line) {
            return n.offset + n.indent + a[0].col;
          } else {
            var l = a.slice(2);
            for (var f = 0; f < l.length; ++f) {
              var _ = l[f];
              if (_.token.trim()) {
                return _.col;
              }
            }
          }
        }
      } else {
        return 0;
      }
      return i + n.indent;
    };
    Ahead.prototype.toString = function() {
      return "#<pattern(".concat(this.pattern, ")>");
    };
    Ahead.prototype.match = function(e75) {
      return e75.match(this.pattern);
    };
    Pattern.prototype.toString = function() {
      var e75 = this.patterns.map(function(e76) {
        return to_string(e76);
      }).join("|");
      return "#<pattern(".concat(e75, " ").concat(this.flag, ")>");
    };
    Formatter.Pattern = Pattern;
    Formatter.Ahead = Ahead;
    p_o = /^[[(]$/;
    p_e = /^[\])]$/;
    not_p = /[^()[\]]/;
    not_close = new Ahead(/[^)\]]/);
    glob = Symbol["for"]("*");
    sexp_or_atom = new Pattern([p_o, glob, p_e], [not_p], "+");
    sexp = new Pattern([p_o, glob, p_e], "+");
    symbol = new Pattern([Symbol["for"]("symbol")], "?");
    symbols = new Pattern([Symbol["for"]("symbol")], "*");
    identifiers = [p_o, symbols, p_e];
    let_value = new Pattern([p_o, Symbol["for"]("symbol"), glob, p_e], "+");
    syntax_rules = keywords_re("syntax-rules");
    def_lambda_re = keywords_re("define", "lambda", "define-macro", "syntax-rules");
    non_def = /^(?!.*\b(?:[()[\]]|define(?:-macro)?|let(?:\*|rec|-env|-syntax|)?|lambda|syntax-rules)\b).*$/;
    let_re = /^(?:#:)?(let(?:\*|rec|-env|-syntax)?)$/;
    comment_re = /^;.*/;
    Formatter.rules = [[[sexp], 0, not_close], [[p_o, keywords_re("begin", "cond-expand")], 1, not_close], [[p_o, let_re, symbol, p_o, let_value, p_e], 1, not_close], [[p_o, let_re, symbol, sexp_or_atom], 1, not_close], [[p_o, let_re, p_o, let_value], 1, not_close], [[p_o, keywords_re("define-syntax"), /.+/], 1], [[p_o, syntax_rules, not_p, identifiers], 1], [[p_o, syntax_rules, not_p, identifiers, sexp], 1, not_close], [[p_o, syntax_rules, identifiers], 1], [comment_re, -1], [[p_o, syntax_rules, identifiers, sexp], 1, not_close], [[p_o, non_def, new Pattern([/[^()[\]]/], "+"), sexp], 1, not_close], [[p_o, sexp], 1, not_close], [[p_o, not_p, sexp], 1, not_close], [[p_o, keywords_re("lambda", "if"), not_p], 1, not_close], [[p_o, keywords_re("while"), not_p, sexp], 1, not_close], [[p_o, keywords_re("if"), not_p, glob], 1, not_close], [[p_o, def_lambda_re, identifiers], 0, not_close], [[p_o, def_lambda_re, identifiers, string_re], 0, not_close], [[p_o, def_lambda_re, identifiers, string_re, sexp], 0, not_close], [[p_o, def_lambda_re, identifiers, sexp], 0, not_close]];
    Formatter.prototype["break"] = function() {
      var e75 = this.__code__.replace(/\n[ \t]*/g, "\n ").trim();
      var t2 = function e76(t3) {
        if (t3.token.match(string_re) || t3.token.match(re_re)) {
          return t3.token;
        } else {
          return t3.token.replace(/\s+/, " ");
        }
      };
      var r = function e76(t3) {
        for (var r2 = t3.length; r2--; ) {
          var n2 = t3[r2];
          if (n2.trim() && !is_special(n2)) {
            return t3.length - r2 - 1;
          }
        }
      };
      var n = tokenize(e75, true).map(t2).filter(function(e76) {
        return e76 !== "\n";
      });
      var i = Formatter.rules;
      e: for (var a = 1; a < n.length; ++a) {
        if (!n[a].trim()) {
          continue;
        }
        var o = n.slice(0, a);
        var u = {};
        i.map(function(e76) {
          return e76[1];
        }).forEach(function(e76) {
          e76 = e76.valueOf();
          if (e76 > 0 && !u[e76]) {
            u[e76] = previousSexp(o, e76);
          }
        });
        var s = _createForOfIteratorHelper(i), c;
        try {
          for (s.s(); !(c = s.n()).done; ) {
            var l = _slicedToArray(c.value, 3), f = l[0], _ = l[1], p = l[2];
            var d = f === comment_re;
            _ = _.valueOf();
            var h = _ > 0 ? u[_] : o;
            var m = h.filter(function(e76) {
              return e76.trim() && !is_special(e76);
            });
            if (!m.length) {
              continue;
            }
            if (_ === -1) {
              f = [f];
              m = m.slice(-1);
            }
            var y = r(h);
            var v = match(f, m);
            var b = n.slice(a).find(function(e76) {
              return e76.trim() && !is_special(e76);
            });
            if (v && (p instanceof Ahead && p.match(b) || !p)) {
              var g = a - y;
              if (n[g] !== "\n") {
                if (!n[g].trim()) {
                  n[g] = "\n";
                } else {
                  n.splice(g, 0, "\n");
                  a++;
                }
              }
              a += y;
              continue e;
            }
          }
        } catch (e76) {
          s.e(e76);
        } finally {
          s.f();
        }
      }
      this.__code__ = n.join("");
      return this;
    };
    Formatter.prototype._spaces = function(e75) {
      return " ".repeat(e75);
    };
    Formatter.prototype.format = function e15(t2) {
      var r = this.__code__.trim().replace(/[ \t]*\n[ \t]*/g, "\n ");
      var n = tokenize(r, true);
      var i = this._options(t2);
      var a = 0;
      var o = 0;
      for (var u = 0; u < n.length; ++u) {
        var s = n[u];
        if (s.token === "\n") {
          a = this._indent(n.slice(0, u), i);
          o += a;
          if (n[u + 1]) {
            n[u + 1].token = this._spaces(a);
            a--;
            o--;
            for (var c = u + 2; c < n.length; ++c) {
              n[c].offset += o;
              n[c].col += a;
              if (n[c].token === "\n") {
                u = c - 1;
                break;
              }
            }
          }
        }
      }
      return n.map(function(e75) {
        if (e75.token.match(string_re)) {
          if (e75.token.match(/\n/)) {
            var t3 = " ".repeat(e75.col);
            var r2 = e75.token.split("\n");
            e75.token = [r2[0]].concat(r2.slice(1).map(function(e76) {
              return t3 + e76;
            })).join("\n");
          }
        }
        return e75.token;
      }).join("");
    };
    fold_case_mapping = { 65: 97, 66: 98, 67: 99, 68: 100, 69: 101, 70: 102, 71: 103, 72: 104, 73: 105, 74: 106, 75: 107, 76: 108, 77: 109, 78: 110, 79: 111, 80: 112, 81: 113, 82: 114, 83: 115, 84: 116, 85: 117, 86: 118, 87: 119, 88: 120, 89: 121, 90: 122, 181: 956, 192: 224, 193: 225, 194: 226, 195: 227, 196: 228, 197: 229, 198: 230, 199: 231, 200: 232, 201: 233, 202: 234, 203: 235, 204: 236, 205: 237, 206: 238, 207: 239, 208: 240, 209: 241, 210: 242, 211: 243, 212: 244, 213: 245, 214: 246, 216: 248, 217: 249, 218: 250, 219: 251, 220: 252, 221: 253, 222: 254, 256: 257, 258: 259, 260: 261, 262: 263, 264: 265, 266: 267, 268: 269, 270: 271, 272: 273, 274: 275, 276: 277, 278: 279, 280: 281, 282: 283, 284: 285, 286: 287, 288: 289, 290: 291, 292: 293, 294: 295, 296: 297, 298: 299, 300: 301, 302: 303, 306: 307, 308: 309, 310: 311, 313: 314, 315: 316, 317: 318, 319: 320, 321: 322, 323: 324, 325: 326, 327: 328, 330: 331, 332: 333, 334: 335, 336: 337, 338: 339, 340: 341, 342: 343, 344: 345, 346: 347, 348: 349, 350: 351, 352: 353, 354: 355, 356: 357, 358: 359, 360: 361, 362: 363, 364: 365, 366: 367, 368: 369, 370: 371, 372: 373, 374: 375, 376: 255, 377: 378, 379: 380, 381: 382, 383: 115, 385: 595, 386: 387, 388: 389, 390: 596, 391: 392, 393: 598, 394: 599, 395: 396, 398: 477, 399: 601, 400: 603, 401: 402, 403: 608, 404: 611, 406: 617, 407: 616, 408: 409, 412: 623, 413: 626, 415: 629, 416: 417, 418: 419, 420: 421, 422: 640, 423: 424, 425: 643, 428: 429, 430: 648, 431: 432, 433: 650, 434: 651, 435: 436, 437: 438, 439: 658, 440: 441, 444: 445, 452: 454, 453: 454, 455: 457, 456: 457, 458: 460, 459: 460, 461: 462, 463: 464, 465: 466, 467: 468, 469: 470, 471: 472, 473: 474, 475: 476, 478: 479, 480: 481, 482: 483, 484: 485, 486: 487, 488: 489, 490: 491, 492: 493, 494: 495, 497: 499, 498: 499, 500: 501, 502: 405, 503: 447, 504: 505, 506: 507, 508: 509, 510: 511, 512: 513, 514: 515, 516: 517, 518: 519, 520: 521, 522: 523, 524: 525, 526: 527, 528: 529, 530: 531, 532: 533, 534: 535, 536: 537, 538: 539, 540: 541, 542: 543, 544: 414, 546: 547, 548: 549, 550: 551, 552: 553, 554: 555, 556: 557, 558: 559, 560: 561, 562: 563, 570: 11365, 571: 572, 573: 410, 574: 11366, 577: 578, 579: 384, 580: 649, 581: 652, 582: 583, 584: 585, 586: 587, 588: 589, 590: 591, 837: 953, 880: 881, 882: 883, 886: 887, 895: 1011, 902: 940, 904: 941, 905: 942, 906: 943, 908: 972, 910: 973, 911: 974, 913: 945, 914: 946, 915: 947, 916: 948, 917: 949, 918: 950, 919: 951, 920: 952, 921: 953, 922: 954, 923: 955, 924: 956, 925: 957, 926: 958, 927: 959, 928: 960, 929: 961, 931: 963, 932: 964, 933: 965, 934: 966, 935: 967, 936: 968, 937: 969, 938: 970, 939: 971, 962: 963, 975: 983, 976: 946, 977: 952, 981: 966, 982: 960, 984: 985, 986: 987, 988: 989, 990: 991, 992: 993, 994: 995, 996: 997, 998: 999, 1e3: 1001, 1002: 1003, 1004: 1005, 1006: 1007, 1008: 954, 1009: 961, 1012: 952, 1013: 949, 1015: 1016, 1017: 1010, 1018: 1019, 1021: 891, 1022: 892, 1023: 893, 1024: 1104, 1025: 1105, 1026: 1106, 1027: 1107, 1028: 1108, 1029: 1109, 1030: 1110, 1031: 1111, 1032: 1112, 1033: 1113, 1034: 1114, 1035: 1115, 1036: 1116, 1037: 1117, 1038: 1118, 1039: 1119, 1040: 1072, 1041: 1073, 1042: 1074, 1043: 1075, 1044: 1076, 1045: 1077, 1046: 1078, 1047: 1079, 1048: 1080, 1049: 1081, 1050: 1082, 1051: 1083, 1052: 1084, 1053: 1085, 1054: 1086, 1055: 1087, 1056: 1088, 1057: 1089, 1058: 1090, 1059: 1091, 1060: 1092, 1061: 1093, 1062: 1094, 1063: 1095, 1064: 1096, 1065: 1097, 1066: 1098, 1067: 1099, 1068: 1100, 1069: 1101, 1070: 1102, 1071: 1103, 1120: 1121, 1122: 1123, 1124: 1125, 1126: 1127, 1128: 1129, 1130: 1131, 1132: 1133, 1134: 1135, 1136: 1137, 1138: 1139, 1140: 1141, 1142: 1143, 1144: 1145, 1146: 1147, 1148: 1149, 1150: 1151, 1152: 1153, 1162: 1163, 1164: 1165, 1166: 1167, 1168: 1169, 1170: 1171, 1172: 1173, 1174: 1175, 1176: 1177, 1178: 1179, 1180: 1181, 1182: 1183, 1184: 1185, 1186: 1187, 1188: 1189, 1190: 1191, 1192: 1193, 1194: 1195, 1196: 1197, 1198: 1199, 1200: 1201, 1202: 1203, 1204: 1205, 1206: 1207, 1208: 1209, 1210: 1211, 1212: 1213, 1214: 1215, 1216: 1231, 1217: 1218, 1219: 1220, 1221: 1222, 1223: 1224, 1225: 1226, 1227: 1228, 1229: 1230, 1232: 1233, 1234: 1235, 1236: 1237, 1238: 1239, 1240: 1241, 1242: 1243, 1244: 1245, 1246: 1247, 1248: 1249, 1250: 1251, 1252: 1253, 1254: 1255, 1256: 1257, 1258: 1259, 1260: 1261, 1262: 1263, 1264: 1265, 1266: 1267, 1268: 1269, 1270: 1271, 1272: 1273, 1274: 1275, 1276: 1277, 1278: 1279, 1280: 1281, 1282: 1283, 1284: 1285, 1286: 1287, 1288: 1289, 1290: 1291, 1292: 1293, 1294: 1295, 1296: 1297, 1298: 1299, 1300: 1301, 1302: 1303, 1304: 1305, 1306: 1307, 1308: 1309, 1310: 1311, 1312: 1313, 1314: 1315, 1316: 1317, 1318: 1319, 1320: 1321, 1322: 1323, 1324: 1325, 1326: 1327, 1329: 1377, 1330: 1378, 1331: 1379, 1332: 1380, 1333: 1381, 1334: 1382, 1335: 1383, 1336: 1384, 1337: 1385, 1338: 1386, 1339: 1387, 1340: 1388, 1341: 1389, 1342: 1390, 1343: 1391, 1344: 1392, 1345: 1393, 1346: 1394, 1347: 1395, 1348: 1396, 1349: 1397, 1350: 1398, 1351: 1399, 1352: 1400, 1353: 1401, 1354: 1402, 1355: 1403, 1356: 1404, 1357: 1405, 1358: 1406, 1359: 1407, 1360: 1408, 1361: 1409, 1362: 1410, 1363: 1411, 1364: 1412, 1365: 1413, 1366: 1414, 4256: 11520, 4257: 11521, 4258: 11522, 4259: 11523, 4260: 11524, 4261: 11525, 4262: 11526, 4263: 11527, 4264: 11528, 4265: 11529, 4266: 11530, 4267: 11531, 4268: 11532, 4269: 11533, 4270: 11534, 4271: 11535, 4272: 11536, 4273: 11537, 4274: 11538, 4275: 11539, 4276: 11540, 4277: 11541, 4278: 11542, 4279: 11543, 4280: 11544, 4281: 11545, 4282: 11546, 4283: 11547, 4284: 11548, 4285: 11549, 4286: 11550, 4287: 11551, 4288: 11552, 4289: 11553, 4290: 11554, 4291: 11555, 4292: 11556, 4293: 11557, 4295: 11559, 4301: 11565, 5112: 5104, 5113: 5105, 5114: 5106, 5115: 5107, 5116: 5108, 5117: 5109, 7296: 1074, 7297: 1076, 7298: 1086, 7299: 1089, 7300: 1090, 7301: 1090, 7302: 1098, 7303: 1123, 7304: 42571, 7312: 4304, 7313: 4305, 7314: 4306, 7315: 4307, 7316: 4308, 7317: 4309, 7318: 4310, 7319: 4311, 7320: 4312, 7321: 4313, 7322: 4314, 7323: 4315, 7324: 4316, 7325: 4317, 7326: 4318, 7327: 4319, 7328: 4320, 7329: 4321, 7330: 4322, 7331: 4323, 7332: 4324, 7333: 4325, 7334: 4326, 7335: 4327, 7336: 4328, 7337: 4329, 7338: 4330, 7339: 4331, 7340: 4332, 7341: 4333, 7342: 4334, 7343: 4335, 7344: 4336, 7345: 4337, 7346: 4338, 7347: 4339, 7348: 4340, 7349: 4341, 7350: 4342, 7351: 4343, 7352: 4344, 7353: 4345, 7354: 4346, 7357: 4349, 7358: 4350, 7359: 4351, 7680: 7681, 7682: 7683, 7684: 7685, 7686: 7687, 7688: 7689, 7690: 7691, 7692: 7693, 7694: 7695, 7696: 7697, 7698: 7699, 7700: 7701, 7702: 7703, 7704: 7705, 7706: 7707, 7708: 7709, 7710: 7711, 7712: 7713, 7714: 7715, 7716: 7717, 7718: 7719, 7720: 7721, 7722: 7723, 7724: 7725, 7726: 7727, 7728: 7729, 7730: 7731, 7732: 7733, 7734: 7735, 7736: 7737, 7738: 7739, 7740: 7741, 7742: 7743, 7744: 7745, 7746: 7747, 7748: 7749, 7750: 7751, 7752: 7753, 7754: 7755, 7756: 7757, 7758: 7759, 7760: 7761, 7762: 7763, 7764: 7765, 7766: 7767, 7768: 7769, 7770: 7771, 7772: 7773, 7774: 7775, 7776: 7777, 7778: 7779, 7780: 7781, 7782: 7783, 7784: 7785, 7786: 7787, 7788: 7789, 7790: 7791, 7792: 7793, 7794: 7795, 7796: 7797, 7798: 7799, 7800: 7801, 7802: 7803, 7804: 7805, 7806: 7807, 7808: 7809, 7810: 7811, 7812: 7813, 7814: 7815, 7816: 7817, 7818: 7819, 7820: 7821, 7822: 7823, 7824: 7825, 7826: 7827, 7828: 7829, 7835: 7777, 7840: 7841, 7842: 7843, 7844: 7845, 7846: 7847, 7848: 7849, 7850: 7851, 7852: 7853, 7854: 7855, 7856: 7857, 7858: 7859, 7860: 7861, 7862: 7863, 7864: 7865, 7866: 7867, 7868: 7869, 7870: 7871, 7872: 7873, 7874: 7875, 7876: 7877, 7878: 7879, 7880: 7881, 7882: 7883, 7884: 7885, 7886: 7887, 7888: 7889, 7890: 7891, 7892: 7893, 7894: 7895, 7896: 7897, 7898: 7899, 7900: 7901, 7902: 7903, 7904: 7905, 7906: 7907, 7908: 7909, 7910: 7911, 7912: 7913, 7914: 7915, 7916: 7917, 7918: 7919, 7920: 7921, 7922: 7923, 7924: 7925, 7926: 7927, 7928: 7929, 7930: 7931, 7932: 7933, 7934: 7935, 7944: 7936, 7945: 7937, 7946: 7938, 7947: 7939, 7948: 7940, 7949: 7941, 7950: 7942, 7951: 7943, 7960: 7952, 7961: 7953, 7962: 7954, 7963: 7955, 7964: 7956, 7965: 7957, 7976: 7968, 7977: 7969, 7978: 7970, 7979: 7971, 7980: 7972, 7981: 7973, 7982: 7974, 7983: 7975, 7992: 7984, 7993: 7985, 7994: 7986, 7995: 7987, 7996: 7988, 7997: 7989, 7998: 7990, 7999: 7991, 8008: 8e3, 8009: 8001, 8010: 8002, 8011: 8003, 8012: 8004, 8013: 8005, 8025: 8017, 8027: 8019, 8029: 8021, 8031: 8023, 8040: 8032, 8041: 8033, 8042: 8034, 8043: 8035, 8044: 8036, 8045: 8037, 8046: 8038, 8047: 8039, 8120: 8112, 8121: 8113, 8122: 8048, 8123: 8049, 8126: 953, 8136: 8050, 8137: 8051, 8138: 8052, 8139: 8053, 8152: 8144, 8153: 8145, 8154: 8054, 8155: 8055, 8168: 8160, 8169: 8161, 8170: 8058, 8171: 8059, 8172: 8165, 8184: 8056, 8185: 8057, 8186: 8060, 8187: 8061, 8486: 969, 8490: 107, 8491: 229, 8498: 8526, 8544: 8560, 8545: 8561, 8546: 8562, 8547: 8563, 8548: 8564, 8549: 8565, 8550: 8566, 8551: 8567, 8552: 8568, 8553: 8569, 8554: 8570, 8555: 8571, 8556: 8572, 8557: 8573, 8558: 8574, 8559: 8575, 8579: 8580, 9398: 9424, 9399: 9425, 9400: 9426, 9401: 9427, 9402: 9428, 9403: 9429, 9404: 9430, 9405: 9431, 9406: 9432, 9407: 9433, 9408: 9434, 9409: 9435, 9410: 9436, 9411: 9437, 9412: 9438, 9413: 9439, 9414: 9440, 9415: 9441, 9416: 9442, 9417: 9443, 9418: 9444, 9419: 9445, 9420: 9446, 9421: 9447, 9422: 9448, 9423: 9449, 11264: 11312, 11265: 11313, 11266: 11314, 11267: 11315, 11268: 11316, 11269: 11317, 11270: 11318, 11271: 11319, 11272: 11320, 11273: 11321, 11274: 11322, 11275: 11323, 11276: 11324, 11277: 11325, 11278: 11326, 11279: 11327, 11280: 11328, 11281: 11329, 11282: 11330, 11283: 11331, 11284: 11332, 11285: 11333, 11286: 11334, 11287: 11335, 11288: 11336, 11289: 11337, 11290: 11338, 11291: 11339, 11292: 11340, 11293: 11341, 11294: 11342, 11295: 11343, 11296: 11344, 11297: 11345, 11298: 11346, 11299: 11347, 11300: 11348, 11301: 11349, 11302: 11350, 11303: 11351, 11304: 11352, 11305: 11353, 11306: 11354, 11307: 11355, 11308: 11356, 11309: 11357, 11310: 11358, 11311: 11359, 11360: 11361, 11362: 619, 11363: 7549, 11364: 637, 11367: 11368, 11369: 11370, 11371: 11372, 11373: 593, 11374: 625, 11375: 592, 11376: 594, 11378: 11379, 11381: 11382, 11390: 575, 11391: 576, 11392: 11393, 11394: 11395, 11396: 11397, 11398: 11399, 11400: 11401, 11402: 11403, 11404: 11405, 11406: 11407, 11408: 11409, 11410: 11411, 11412: 11413, 11414: 11415, 11416: 11417, 11418: 11419, 11420: 11421, 11422: 11423, 11424: 11425, 11426: 11427, 11428: 11429, 11430: 11431, 11432: 11433, 11434: 11435, 11436: 11437, 11438: 11439, 11440: 11441, 11442: 11443, 11444: 11445, 11446: 11447, 11448: 11449, 11450: 11451, 11452: 11453, 11454: 11455, 11456: 11457, 11458: 11459, 11460: 11461, 11462: 11463, 11464: 11465, 11466: 11467, 11468: 11469, 11470: 11471, 11472: 11473, 11474: 11475, 11476: 11477, 11478: 11479, 11480: 11481, 11482: 11483, 11484: 11485, 11486: 11487, 11488: 11489, 11490: 11491, 11499: 11500, 11501: 11502, 11506: 11507, 42560: 42561, 42562: 42563, 42564: 42565, 42566: 42567, 42568: 42569, 42570: 42571, 42572: 42573, 42574: 42575, 42576: 42577, 42578: 42579, 42580: 42581, 42582: 42583, 42584: 42585, 42586: 42587, 42588: 42589, 42590: 42591, 42592: 42593, 42594: 42595, 42596: 42597, 42598: 42599, 42600: 42601, 42602: 42603, 42604: 42605, 42624: 42625, 42626: 42627, 42628: 42629, 42630: 42631, 42632: 42633, 42634: 42635, 42636: 42637, 42638: 42639, 42640: 42641, 42642: 42643, 42644: 42645, 42646: 42647, 42648: 42649, 42650: 42651, 42786: 42787, 42788: 42789, 42790: 42791, 42792: 42793, 42794: 42795, 42796: 42797, 42798: 42799, 42802: 42803, 42804: 42805, 42806: 42807, 42808: 42809, 42810: 42811, 42812: 42813, 42814: 42815, 42816: 42817, 42818: 42819, 42820: 42821, 42822: 42823, 42824: 42825, 42826: 42827, 42828: 42829, 42830: 42831, 42832: 42833, 42834: 42835, 42836: 42837, 42838: 42839, 42840: 42841, 42842: 42843, 42844: 42845, 42846: 42847, 42848: 42849, 42850: 42851, 42852: 42853, 42854: 42855, 42856: 42857, 42858: 42859, 42860: 42861, 42862: 42863, 42873: 42874, 42875: 42876, 42877: 7545, 42878: 42879, 42880: 42881, 42882: 42883, 42884: 42885, 42886: 42887, 42891: 42892, 42893: 613, 42896: 42897, 42898: 42899, 42902: 42903, 42904: 42905, 42906: 42907, 42908: 42909, 42910: 42911, 42912: 42913, 42914: 42915, 42916: 42917, 42918: 42919, 42920: 42921, 42922: 614, 42923: 604, 42924: 609, 42925: 620, 42926: 618, 42928: 670, 42929: 647, 42930: 669, 42931: 43859, 42932: 42933, 42934: 42935, 42936: 42937, 42938: 42939, 42940: 42941, 42942: 42943, 42944: 42945, 42946: 42947, 42948: 42900, 42949: 642, 42950: 7566, 42951: 42952, 42953: 42954, 42960: 42961, 42966: 42967, 42968: 42969, 42997: 42998, 43888: 5024, 43889: 5025, 43890: 5026, 43891: 5027, 43892: 5028, 43893: 5029, 43894: 5030, 43895: 5031, 43896: 5032, 43897: 5033, 43898: 5034, 43899: 5035, 43900: 5036, 43901: 5037, 43902: 5038, 43903: 5039, 43904: 5040, 43905: 5041, 43906: 5042, 43907: 5043, 43908: 5044, 43909: 5045, 43910: 5046, 43911: 5047, 43912: 5048, 43913: 5049, 43914: 5050, 43915: 5051, 43916: 5052, 43917: 5053, 43918: 5054, 43919: 5055, 43920: 5056, 43921: 5057, 43922: 5058, 43923: 5059, 43924: 5060, 43925: 5061, 43926: 5062, 43927: 5063, 43928: 5064, 43929: 5065, 43930: 5066, 43931: 5067, 43932: 5068, 43933: 5069, 43934: 5070, 43935: 5071, 43936: 5072, 43937: 5073, 43938: 5074, 43939: 5075, 43940: 5076, 43941: 5077, 43942: 5078, 43943: 5079, 43944: 5080, 43945: 5081, 43946: 5082, 43947: 5083, 43948: 5084, 43949: 5085, 43950: 5086, 43951: 5087, 43952: 5088, 43953: 5089, 43954: 5090, 43955: 5091, 43956: 5092, 43957: 5093, 43958: 5094, 43959: 5095, 43960: 5096, 43961: 5097, 43962: 5098, 43963: 5099, 43964: 5100, 43965: 5101, 43966: 5102, 43967: 5103, 65313: 65345, 65314: 65346, 65315: 65347, 65316: 65348, 65317: 65349, 65318: 65350, 65319: 65351, 65320: 65352, 65321: 65353, 65322: 65354, 65323: 65355, 65324: 65356, 65325: 65357, 65326: 65358, 65327: 65359, 65328: 65360, 65329: 65361, 65330: 65362, 65331: 65363, 65332: 65364, 65333: 65365, 65334: 65366, 65335: 65367, 65336: 65368, 65337: 65369, 65338: 65370, 66560: 66600, 66561: 66601, 66562: 66602, 66563: 66603, 66564: 66604, 66565: 66605, 66566: 66606, 66567: 66607, 66568: 66608, 66569: 66609, 66570: 66610, 66571: 66611, 66572: 66612, 66573: 66613, 66574: 66614, 66575: 66615, 66576: 66616, 66577: 66617, 66578: 66618, 66579: 66619, 66580: 66620, 66581: 66621, 66582: 66622, 66583: 66623, 66584: 66624, 66585: 66625, 66586: 66626, 66587: 66627, 66588: 66628, 66589: 66629, 66590: 66630, 66591: 66631, 66592: 66632, 66593: 66633, 66594: 66634, 66595: 66635, 66596: 66636, 66597: 66637, 66598: 66638, 66599: 66639, 66736: 66776, 66737: 66777, 66738: 66778, 66739: 66779, 66740: 66780, 66741: 66781, 66742: 66782, 66743: 66783, 66744: 66784, 66745: 66785, 66746: 66786, 66747: 66787, 66748: 66788, 66749: 66789, 66750: 66790, 66751: 66791, 66752: 66792, 66753: 66793, 66754: 66794, 66755: 66795, 66756: 66796, 66757: 66797, 66758: 66798, 66759: 66799, 66760: 66800, 66761: 66801, 66762: 66802, 66763: 66803, 66764: 66804, 66765: 66805, 66766: 66806, 66767: 66807, 66768: 66808, 66769: 66809, 66770: 66810, 66771: 66811, 66928: 66967, 66929: 66968, 66930: 66969, 66931: 66970, 66932: 66971, 66933: 66972, 66934: 66973, 66935: 66974, 66936: 66975, 66937: 66976, 66938: 66977, 66940: 66979, 66941: 66980, 66942: 66981, 66943: 66982, 66944: 66983, 66945: 66984, 66946: 66985, 66947: 66986, 66948: 66987, 66949: 66988, 66950: 66989, 66951: 66990, 66952: 66991, 66953: 66992, 66954: 66993, 66956: 66995, 66957: 66996, 66958: 66997, 66959: 66998, 66960: 66999, 66961: 67e3, 66962: 67001, 66964: 67003, 66965: 67004, 68736: 68800, 68737: 68801, 68738: 68802, 68739: 68803, 68740: 68804, 68741: 68805, 68742: 68806, 68743: 68807, 68744: 68808, 68745: 68809, 68746: 68810, 68747: 68811, 68748: 68812, 68749: 68813, 68750: 68814, 68751: 68815, 68752: 68816, 68753: 68817, 68754: 68818, 68755: 68819, 68756: 68820, 68757: 68821, 68758: 68822, 68759: 68823, 68760: 68824, 68761: 68825, 68762: 68826, 68763: 68827, 68764: 68828, 68765: 68829, 68766: 68830, 68767: 68831, 68768: 68832, 68769: 68833, 68770: 68834, 68771: 68835, 68772: 68836, 68773: 68837, 68774: 68838, 68775: 68839, 68776: 68840, 68777: 68841, 68778: 68842, 68779: 68843, 68780: 68844, 68781: 68845, 68782: 68846, 68783: 68847, 68784: 68848, 68785: 68849, 68786: 68850, 71840: 71872, 71841: 71873, 71842: 71874, 71843: 71875, 71844: 71876, 71845: 71877, 71846: 71878, 71847: 71879, 71848: 71880, 71849: 71881, 71850: 71882, 71851: 71883, 71852: 71884, 71853: 71885, 71854: 71886, 71855: 71887, 71856: 71888, 71857: 71889, 71858: 71890, 71859: 71891, 71860: 71892, 71861: 71893, 71862: 71894, 71863: 71895, 71864: 71896, 71865: 71897, 71866: 71898, 71867: 71899, 71868: 71900, 71869: 71901, 71870: 71902, 71871: 71903, 93760: 93792, 93761: 93793, 93762: 93794, 93763: 93795, 93764: 93796, 93765: 93797, 93766: 93798, 93767: 93799, 93768: 93800, 93769: 93801, 93770: 93802, 93771: 93803, 93772: 93804, 93773: 93805, 93774: 93806, 93775: 93807, 93776: 93808, 93777: 93809, 93778: 93810, 93779: 93811, 93780: 93812, 93781: 93813, 93782: 93814, 93783: 93815, 93784: 93816, 93785: 93817, 93786: 93818, 93787: 93819, 93788: 93820, 93789: 93821, 93790: 93822, 93791: 93823, 125184: 125218, 125185: 125219, 125186: 125220, 125187: 125221, 125188: 125222, 125189: 125223, 125190: 125224, 125191: 125225, 125192: 125226, 125193: 125227, 125194: 125228, 125195: 125229, 125196: 125230, 125197: 125231, 125198: 125232, 125199: 125233, 125200: 125234, 125201: 125235, 125202: 125236, 125203: 125237, 125204: 125238, 125205: 125239, 125206: 125240, 125207: 125241, 125208: 125242, 125209: 125243, 125210: 125244, 125211: 125245, 125212: 125246, 125213: 125247, 125214: 125248, 125215: 125249, 125216: 125250, 125217: 125251 };
    Nil.prototype.toString = function() {
      return "()";
    };
    Nil.prototype.valueOf = function() {
      return void 0;
    };
    Nil.prototype.serialize = function() {
      return 0;
    };
    Nil.prototype.to_object = function() {
      return {};
    };
    Nil.prototype.append = function(e75) {
      return new Pair(e75, _nil);
    };
    Nil.prototype.to_array = function() {
      return [];
    };
    _nil = new Nil();
    Pair.prototype.flatten = function() {
      return Pair.fromArray(flatten(this.to_array()));
    };
    Pair.prototype.length = function() {
      var e75 = 0;
      var t2 = this;
      while (true) {
        if (!t2 || is_nil(t2) || !is_pair(t2) || t2.have_cycles("cdr")) {
          break;
        }
        e75++;
        t2 = t2.cdr;
      }
      return e75;
    };
    Pair.prototype.freeze = function() {
      var e75 = this;
      while (true) {
        read_only(e75, "car", e75.car);
        if (is_pair(e75.car) && !e75.have_cycles("car")) {
          e75.car.freeze();
        }
        read_only(e75, "cdr", e75.cdr);
        if (e75.have_cycles("cdr")) {
          break;
        }
        e75 = e75.cdr;
        if (!is_pair(e75)) {
          break;
        }
      }
    };
    Pair.match = function(e75, t2) {
      if (e75 instanceof LSymbol) {
        return LSymbol.is(e75, t2);
      } else if (is_pair(e75)) {
        return Pair.match(e75.car, t2) || Pair.match(e75.cdr, t2);
      } else if (Array.isArray(e75)) {
        return e75.some(function(e76) {
          return Pair.match(e76, t2);
        });
      } else if (is_plain_object(e75)) {
        return Object.values(e75).some(function(e76) {
          return Pair.match(e76, t2);
        });
      }
      return false;
    };
    Pair.prototype.find = function(e75) {
      return Pair.match(this, e75);
    };
    Pair.prototype.clone = function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var n = /* @__PURE__ */ new Map();
      function i(e75) {
        if (is_pair(e75)) {
          if (n.has(e75)) {
            return n.get(e75);
          }
          var t2 = new Pair();
          n.set(e75, t2);
          if (r) {
            t2.car = i(e75.car);
          } else {
            t2.car = e75.car;
          }
          t2.cdr = i(e75.cdr);
          t2[__cycles__] = e75[__cycles__];
          return t2;
        }
        return e75;
      }
      return i(this);
    };
    Pair.prototype.last_pair = function() {
      var e75 = this;
      while (true) {
        if (!is_pair(e75.cdr)) {
          return e75;
        }
        if (e75.have_cycles("cdr")) {
          break;
        }
        e75 = e75.cdr;
      }
    };
    Pair.prototype.to_array = function() {
      var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var t2 = [];
      if (is_pair(this.car)) {
        if (e75) {
          t2.push(this.car.to_array());
        } else {
          t2.push(this.car);
        }
      } else {
        t2.push(this.car.valueOf());
      }
      if (is_pair(this.cdr)) {
        t2 = t2.concat(this.cdr.to_array(e75));
      }
      return t2;
    };
    Pair.fromArray = function(e75) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (is_pair(e75) || r && e75 instanceof Array && e75[__data__]) {
        return e75;
      }
      if (t2 === false) {
        var n = _nil;
        for (var i = e75.length; i--; ) {
          n = new Pair(e75[i], n);
        }
        return n;
      }
      if (e75.length && !(e75 instanceof Array)) {
        e75 = _toConsumableArray(e75);
      }
      var a = _nil;
      var o = e75.length;
      while (o--) {
        var u = e75[o];
        if (u instanceof Array) {
          u = Pair.fromArray(u, t2, r);
        } else if (typeof u === "string") {
          u = LString(u);
        } else if (typeof u === "number" && !Number.isNaN(u)) {
          u = LNumber(u);
        }
        a = new Pair(u, a);
      }
      return a;
    };
    Pair.prototype.to_object = function() {
      var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var t2 = this;
      var r = {};
      while (true) {
        if (is_pair(t2) && is_pair(t2.car)) {
          var n = t2.car;
          var i = n.car;
          if (i instanceof LSymbol) {
            i = i.__name__;
          }
          if (i instanceof LString) {
            i = i.valueOf();
          }
          var a = n.cdr;
          if (is_pair(a)) {
            a = a.to_object(e75);
          }
          if (is_native(a)) {
            if (!e75) {
              a = a.valueOf();
            }
          }
          r[i] = a;
          t2 = t2.cdr;
        } else {
          break;
        }
      }
      return r;
    };
    Pair.fromPairs = function(e75) {
      return e75.reduce(function(e76, t2) {
        return new Pair(new Pair(new LSymbol(t2[0]), t2[1]), e76);
      }, _nil);
    };
    Pair.fromObject = function(t2) {
      var e75 = Object.keys(t2).map(function(e76) {
        return [e76, t2[e76]];
      });
      return Pair.fromPairs(e75);
    };
    Pair.prototype.reduce = function(e75) {
      var t2 = this;
      var r = _nil;
      while (true) {
        if (!is_nil(t2)) {
          r = e75(r, t2.car);
          t2 = t2.cdr;
        } else {
          break;
        }
      }
      return r;
    };
    Pair.prototype.reverse = function() {
      if (this.have_cycles()) {
        throw new Error("You can't reverse list that have cycles");
      }
      var e75 = this;
      var t2 = _nil;
      while (!is_nil(e75)) {
        var r = e75.cdr;
        e75.cdr = t2;
        t2 = e75;
        e75 = r;
      }
      return t2;
    };
    Pair.prototype.transform = function(n) {
      function i(e75) {
        if (is_pair(e75)) {
          if (e75.replace) {
            delete e75.replace;
            return e75;
          }
          var t2 = n(e75.car);
          if (is_pair(t2)) {
            t2 = i(t2);
          }
          var r = n(e75.cdr);
          if (is_pair(r)) {
            r = i(r);
          }
          return new Pair(t2, r);
        }
        return e75;
      }
      return i(this);
    };
    Pair.prototype.map = function(e75) {
      if (typeof this.car !== "undefined") {
        return new Pair(e75(this.car), is_nil(this.cdr) ? _nil : this.cdr.map(e75));
      } else {
        return _nil;
      }
    };
    repr = /* @__PURE__ */ new Map();
    props = Object.getOwnPropertyNames(Array.prototype);
    array_methods = [];
    props.forEach(function(e75) {
      array_methods.push(Array[e75], Array.prototype[e75]);
    });
    str_mapping = /* @__PURE__ */ new Map();
    [[true, "#t"], [false, "#f"], [null, "#null"], [void 0, "#void"]].forEach(function(e75) {
      var t2 = _slicedToArray(e75, 2), r = t2[0], n = t2[1];
      str_mapping.set(r, n);
    });
    instances = /* @__PURE__ */ new Map();
    [[Error, function(e75) {
      return e75.message;
    }], [Pair, function(e75, t2) {
      var r = t2.quote, n = t2.skip_cycles, i = t2.pair_args;
      if (!n) {
        e75.mark_cycles();
      }
      return e75.toString.apply(e75, [r].concat(_toConsumableArray(i)));
    }], [LCharacter, function(e75, t2) {
      var r = t2.quote;
      if (r) {
        return e75.toString();
      }
      return e75.valueOf();
    }], [LString, function(e75, t2) {
      var r = t2.quote;
      e75 = e75.toString();
      if (r) {
        return JSON.stringify(e75).replace(/\\n/g, "\n");
      }
      return e75;
    }], [RegExp, function(e75) {
      return "#" + e75.toString();
    }]].forEach(function(e75) {
      var t2 = _slicedToArray(e75, 2), r = t2[0], n = t2[1];
      instances.set(r, n);
    });
    native_types = [LSymbol, Macro, InputPort, OutputPort, Environment, QuotedPromise];
    Pair.prototype.mark_cycles = function() {
      mark_cycles(this);
      return this;
    };
    Pair.prototype.have_cycles = function() {
      var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (!e75) {
        return this.have_cycles("car") || this.have_cycles("cdr");
      }
      return !!(this[__cycles__] && this[__cycles__][e75]);
    };
    Pair.prototype.is_cycle = function() {
      return is_cycle(this);
    };
    Pair.prototype.toString = function(e75) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = t2.nested, n = r === void 0 ? false : r;
      var i = [];
      if (this[__ref__]) {
        i.push(this[__ref__] + "(");
      } else if (!n) {
        i.push("(");
      }
      var a;
      if (this[__cycles__] && this[__cycles__].car) {
        a = this[__cycles__].car;
      } else {
        a = to_string(this.car, e75, true);
      }
      if (a !== void 0) {
        i.push(a);
      }
      if (is_pair(this.cdr)) {
        if (this[__cycles__] && this[__cycles__].cdr) {
          i.push(" . ");
          i.push(this[__cycles__].cdr);
        } else {
          if (this.cdr[__ref__]) {
            i.push(" . ");
          } else {
            i.push(" ");
          }
          var o = this.cdr.toString(e75, { nested: true });
          i.push(o);
        }
      } else if (!is_nil(this.cdr)) {
        i = i.concat([" . ", to_string(this.cdr, e75, true)]);
      }
      if (!n || this[__ref__]) {
        i.push(")");
      }
      return i.join("");
    };
    Pair.prototype.set = function(e75, t2) {
      this[e75] = t2;
      if (is_pair(t2)) {
        this.mark_cycles();
      }
    };
    Pair.prototype.append = function(e75) {
      if (e75 instanceof Array) {
        return this.append(Pair.fromArray(e75));
      }
      var t2 = this;
      if (t2.car === void 0) {
        if (is_pair(e75)) {
          this.car = e75.car;
          this.cdr = e75.cdr;
        } else {
          this.car = e75;
        }
      } else if (!is_nil(e75)) {
        while (true) {
          if (is_pair(t2) && !is_nil(t2.cdr)) {
            t2 = t2.cdr;
          } else {
            break;
          }
        }
        t2.cdr = e75;
      }
      return this;
    };
    Pair.prototype.serialize = function() {
      return [this.car, this.cdr];
    };
    Pair.prototype[Symbol.iterator] = function() {
      var r = this;
      return { next: function e75() {
        var t2 = r;
        r = t2.cdr;
        if (is_nil(t2)) {
          return { value: void 0, done: true };
        } else {
          return { value: t2.car, done: false };
        }
      } };
    };
    truncate = function() {
      if (Math.trunc) {
        return Math.trunc;
      } else {
        return function(e75) {
          if (e75 === 0) {
            return 0;
          } else if (e75 < 0) {
            return Math.ceil(e75);
          } else {
            return Math.floor(e75);
          }
        };
      }
    }();
    Macro.defmacro = function(e75, t2, r, n) {
      var i = new Macro(e75, t2, r, n);
      i.__defmacro__ = true;
      return i;
    };
    Macro.prototype.invoke = function(e75, t2, r) {
      var n = t2.env, i = _objectWithoutProperties(t2, _excluded2);
      var a = _objectSpread(_objectSpread({}, i), {}, { macro_expand: r });
      var o = this.__fn__.call(n, e75, a, this.__name__);
      return o;
    };
    Macro.prototype.toString = function() {
      return "#<macro:".concat(this.__name__, ">");
    };
    macro = "define-macro";
    recur_guard = -1e4;
    Syntax.__merge_env__ = Symbol["for"]("merge");
    Syntax.prototype = Object.create(Macro.prototype);
    Syntax.prototype.invoke = function(e75, t2, r) {
      var n = t2.error, i = t2.env, a = t2.use_dynamic;
      var o = { error: n, env: i, use_dynamic: a, dynamic_env: this.__env__, macro_expand: r };
      return this.__fn__.call(i, e75, o, this.__name__ || "syntax");
    };
    Syntax.prototype.constructor = Syntax;
    Syntax.prototype.toString = function() {
      if (this.__name__) {
        return "#<syntax:".concat(this.__name__, ">");
      }
      return "#<syntax>";
    };
    SyntaxParameter = _createClass(function e16(t2) {
      _classCallCheck(this, e16);
      read_only(this, "_syntax", t2, { hidden: true });
      read_only(this._syntax, "_param", true, { hidden: true });
    });
    Syntax.Parameter = SyntaxParameter;
    __context__ = Symbol["for"]("__context__");
    __fn__ = Symbol["for"]("__fn__");
    __data__ = Symbol["for"]("__data__");
    __ref__ = Symbol["for"]("__ref__");
    __cycles__ = Symbol["for"]("__cycles__");
    __class__ = Symbol["for"]("__class__");
    __method__ = Symbol["for"]("__method__");
    __prototype__ = Symbol["for"]("__prototype__");
    __lambda__ = Symbol["for"]("__lambda__");
    exluded_names = ["name", "length", "caller", "callee", "arguments", "prototype"];
    single_math_op = curry(limit_math_op, 1);
    binary_math_op = curry(limit_math_op, 2);
    LCharacter.is = function(e75, t2) {
      return e75 instanceof LCharacter && e75.__char__ === t2;
    };
    LCharacter.__names__ = characters;
    LCharacter.__rev_names__ = {};
    Object.keys(LCharacter.__names__).forEach(function(e75) {
      var t2 = LCharacter.__names__[e75];
      LCharacter.__rev_names__[t2] = e75;
    });
    LCharacter.prototype.toUpperCase = function() {
      return LCharacter(this.__char__.toUpperCase());
    };
    LCharacter.prototype.toLowerCase = function() {
      return LCharacter(this.__char__.toLowerCase());
    };
    LCharacter.prototype.toString = function() {
      return "#\\" + (this.__name__ || this.__char__);
    };
    LCharacter.prototype.valueOf = LCharacter.prototype.serialize = function() {
      return this.__char__;
    };
    {
      ignore = ["length", "constructor"];
      _keys = Object.getOwnPropertyNames(String.prototype).filter(function(e75) {
        return !ignore.includes(e75);
      });
      wrap = function e75(n) {
        return function() {
          for (var e76 = arguments.length, t2 = new Array(e76), r = 0; r < e76; r++) {
            t2[r] = arguments[r];
          }
          return n.apply(this.__string__, t2);
        };
      };
      _iterator10 = _createForOfIteratorHelper(_keys);
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
          key = _step10.value;
          LString.prototype[key] = wrap(String.prototype[key]);
        }
      } catch (e75) {
        _iterator10.e(e75);
      } finally {
        _iterator10.f();
      }
    }
    LString.prototype[Symbol.iterator] = _regeneratorRuntime.mark(function e17() {
      var r, n, i, a;
      return _regeneratorRuntime.wrap(function e75(t2) {
        while (1) switch (t2.prev = t2.next) {
          case 0:
            r = Array.from(this.__string__);
            n = 0, i = r;
          case 2:
            if (!(n < i.length)) {
              t2.next = 9;
              break;
            }
            a = i[n];
            t2.next = 6;
            return LCharacter(a);
          case 6:
            n++;
            t2.next = 2;
            break;
          case 9:
          case "end":
            return t2.stop();
        }
      }, e17, this);
    });
    LString.prototype.serialize = function() {
      return this.valueOf();
    };
    LString.is = function(e75, t2) {
      return e75 instanceof LString && e75.__string__ === t2;
    };
    LString.isString = function(e75) {
      return e75 instanceof LString || typeof e75 === "string";
    };
    LString.prototype.freeze = function() {
      var e75 = this.__string__;
      delete this.__string__;
      read_only(this, "__string__", e75);
    };
    LString.prototype.get = function(e75) {
      typecheck("LString::get", e75, "number");
      return Array.from(this.__string__)[e75.valueOf()];
    };
    LString.prototype.cmp = function(e75) {
      typecheck("LString::cmp", e75, "string");
      var t2 = this.valueOf();
      var r = e75.valueOf();
      if (t2 < r) {
        return -1;
      } else if (t2 === r) {
        return 0;
      } else {
        return 1;
      }
    };
    LString.prototype.lower = function() {
      return LString(this.__string__.toLowerCase());
    };
    LString.prototype.upper = function() {
      return LString(this.__string__.toUpperCase());
    };
    LString.prototype.set = function(e75, t2) {
      typecheck("LString::set", e75, "number");
      typecheck("LString::set", t2, ["string", "character"]);
      e75 = e75.valueOf();
      if (t2 instanceof LCharacter) {
        t2 = t2.__char__;
      }
      var r = [];
      if (e75 > 0) {
        r.push(this.__string__.substring(0, e75));
      }
      r.push(t2);
      if (e75 < this.__string__.length - 1) {
        r.push(this.__string__.substring(e75 + 1));
      }
      this.__string__ = r.join("");
    };
    Object.defineProperty(LString.prototype, "length", { get: function e18() {
      return this.__string__.length;
    } });
    LString.prototype.clone = function() {
      return LString(this.valueOf());
    };
    LString.prototype.fill = function(e75) {
      typecheck("LString::fill", e75, ["string", "character"]);
      if (e75 instanceof LCharacter) {
        e75 = e75.valueOf();
      }
      var t2 = this.__string__.length;
      this.__string__ = e75.repeat(t2);
    };
    LNumber.prototype.constant = function(e75, t2) {
      enumerable(this, "__value__", e75);
      enumerable(this, "__type__", t2);
    };
    LNumber.types = { float: function e19(t2) {
      return new LFloat(t2);
    }, complex: function e20(t2) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!LNumber.isComplex(t2)) {
        t2 = { im: 0, re: t2 };
      }
      return new LComplex(t2, r);
    }, rational: function e21(t2) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!LNumber.isRational(t2)) {
        t2 = { num: t2, denom: 1 };
      }
      return new LRational(t2, r);
    } };
    LNumber.prototype.serialize = function() {
      return this.__value__;
    };
    LNumber.prototype.isNaN = function() {
      return Number.isNaN(this.__value__);
    };
    LNumber.prototype.gcd = function(e75) {
      var t2 = this.abs();
      e75 = e75.abs();
      if (e75.cmp(t2) === 1) {
        var r = t2;
        t2 = e75;
        e75 = r;
      }
      while (true) {
        t2 = t2.rem(e75);
        if (t2.cmp(0) === 0) {
          return e75;
        }
        e75 = e75.rem(t2);
        if (e75.cmp(0) === 0) {
          return t2;
        }
      }
    };
    LNumber.isFloat = function e22(t2) {
      return t2 instanceof LFloat || Number(t2) === t2 && t2 % 1 !== 0;
    };
    LNumber.isNumber = function(e75) {
      return e75 instanceof LNumber || LNumber.isNative(e75) || LNumber.isBN(e75);
    };
    LNumber.isComplex = function(e75) {
      if (!e75) {
        return false;
      }
      var t2 = e75 instanceof LComplex || (LNumber.isNumber(e75.im) || LNumber.isRational(e75.im) || Number.isNaN(e75.im)) && (LNumber.isNumber(e75.re) || LNumber.isRational(e75.re) || Number.isNaN(e75.re));
      return t2;
    };
    LNumber.isRational = function(e75) {
      if (!e75) {
        return false;
      }
      return e75 instanceof LRational || LNumber.isNumber(e75.num) && LNumber.isNumber(e75.denom);
    };
    LNumber.isInteger = function(e75) {
      if (!(LNumber.isNative(e75) || e75 instanceof LNumber)) {
        return false;
      }
      if (LNumber.isFloat(e75)) {
        return false;
      }
      if (LNumber.isRational(e75)) {
        return false;
      }
      if (LNumber.isComplex(e75)) {
        return false;
      }
      return true;
    };
    LNumber.isNative = function(e75) {
      return typeof e75 === "bigint" || typeof e75 === "number";
    };
    LNumber.isBigInteger = function(e75) {
      return e75 instanceof LBigInteger || typeof e75 === "bigint" || LNumber.isBN(e75);
    };
    LNumber.isBN = function(e75) {
      return typeof BN !== "undefined" && e75 instanceof BN;
    };
    LNumber.getArgsType = function(e75, t2) {
      if (e75 instanceof LFloat || t2 instanceof LFloat) {
        return LFloat;
      }
      if (e75 instanceof LBigInteger || t2 instanceof LBigInteger) {
        return LBigInteger;
      }
      return LNumber;
    };
    LNumber.prototype.toString = function(e75) {
      if (Number.isNaN(this.__value__)) {
        return "+nan.0";
      }
      if (e75 >= 2 && e75 < 36) {
        return this.__value__.toString(e75);
      }
      return this.__value__.toString();
    };
    LNumber.prototype.asType = function(e75) {
      var t2 = LNumber.getType(this);
      return LNumber.types[t2] ? LNumber.types[t2](e75) : LNumber(e75);
    };
    LNumber.prototype.isBigNumber = function() {
      return typeof this.__value__ === "bigint" || typeof BN !== "undefined" && !(this.value instanceof BN);
    };
    ["floor", "ceil", "round"].forEach(function(e75) {
      LNumber.prototype[e75] = function() {
        if (this["float"] || LNumber.isFloat(this.__value__)) {
          return LNumber(Math[e75](this.__value__));
        } else {
          return LNumber(Math[e75](this.valueOf()));
        }
      };
    });
    LNumber.prototype.valueOf = function() {
      if (LNumber.isNative(this.__value__)) {
        return Number(this.__value__);
      } else if (LNumber.isBN(this.__value__)) {
        return this.__value__.toNumber();
      }
    };
    matrix = function() {
      var e75 = function e76(t3, r) {
        return [t3, r];
      };
      return { bigint: { bigint: e75, float: function e76(t3, r) {
        return [LFloat(t3.valueOf()), r];
      }, rational: function e76(t3, r) {
        return [{ num: t3, denom: 1 }, r];
      }, complex: function e76(t3, r) {
        return [{ im: 0, re: t3 }, r];
      } }, integer: { integer: e75, float: function e76(t3, r) {
        return [LFloat(t3.valueOf()), r];
      }, rational: function e76(t3, r) {
        return [{ num: t3, denom: 1 }, r];
      }, complex: function e76(t3, r) {
        return [{ im: 0, re: t3 }, r];
      } }, float: { bigint: function e76(t3, r) {
        return [t3, r && LFloat(r.valueOf())];
      }, integer: function e76(t3, r) {
        return [t3, r && LFloat(r.valueOf())];
      }, float: e75, rational: function e76(t3, r) {
        return [t3, r && LFloat(r.valueOf())];
      }, complex: function e76(t3, r) {
        return [{ re: t3, im: LFloat(0) }, r];
      } }, complex: { bigint: t2("bigint"), integer: t2("integer"), float: t2("float"), rational: t2("rational"), complex: function e76(t3, r) {
        var n = LNumber.coerce(t3.__re__, r.__re__), i = _slicedToArray(n, 2), a = i[0], o = i[1];
        var u = LNumber.coerce(t3.__im__, r.__im__), s = _slicedToArray(u, 2), c = s[0], l = s[1];
        return [{ im: c, re: a }, { im: l, re: o }];
      } }, rational: { bigint: function e76(t3, r) {
        return [t3, r && { num: r, denom: 1 }];
      }, integer: function e76(t3, r) {
        return [t3, r && { num: r, denom: 1 }];
      }, float: function e76(t3, r) {
        return [LFloat(t3.valueOf()), r];
      }, rational: e75, complex: function e76(t3, r) {
        return [{ im: coerce(t3.__type__, r.__im__.__type__, 0)[0], re: coerce(t3.__type__, r.__re__.__type__, t3)[0] }, { im: coerce(t3.__type__, r.__im__.__type__, r.__im__)[0], re: coerce(t3.__type__, r.__re__.__type__, r.__re__)[0] }];
      } } };
      function t2(r) {
        return function(e76, t3) {
          return [{ im: coerce(r, e76.__im__.__type__, 0, e76.__im__)[1], re: coerce(r, e76.__re__.__type__, 0, e76.__re__)[1] }, { im: coerce(r, e76.__im__.__type__, 0, 0)[1], re: coerce(r, t3.__type__, 0, t3)[1] }];
        };
      }
    }();
    LNumber.coerce = function(e75, t2) {
      var r = LNumber.getType(e75);
      var n = LNumber.getType(t2);
      if (!matrix[r]) {
        throw new Error("LNumber::coerce unknown lhs type ".concat(r));
      } else if (!matrix[r][n]) {
        throw new Error("LNumber::coerce unknown rhs type ".concat(n));
      }
      var i = matrix[r][n](e75, t2);
      return i.map(function(e76) {
        return LNumber(e76, true);
      });
    };
    LNumber.prototype.coerce = function(e75) {
      if (!(typeof e75 === "number" || e75 instanceof LNumber)) {
        throw new Error("LNumber: you can't coerce ".concat(type(e75)));
      }
      if (typeof e75 === "number") {
        e75 = LNumber(e75);
      }
      return LNumber.coerce(this, e75);
    };
    LNumber.getType = function(e75) {
      if (e75 instanceof LNumber) {
        return e75.__type__;
      }
      if (LNumber.isFloat(e75)) {
        return "float";
      }
      if (LNumber.isComplex(e75)) {
        return "complex";
      }
      if (LNumber.isRational(e75)) {
        return "rational";
      }
      if (typeof e75 === "number") {
        return "integer";
      }
      if (typeof BigInt !== "undefined" && typeof e75 !== "bigint" || typeof BN !== "undefined" && !(e75 instanceof BN)) {
        return "bigint";
      }
    };
    LNumber.prototype.isFloat = function() {
      return !!(LNumber.isFloat(this.__value__) || this["float"]);
    };
    mapping = { add: "+", sub: "-", mul: "*", div: "/", rem: "%", or: "|", and: "&", neg: "~", shl: ">>", shr: "<<" };
    rev_mapping = {};
    Object.keys(mapping).forEach(function(t2) {
      rev_mapping[mapping[t2]] = t2;
      LNumber.prototype[t2] = function(e75) {
        return this.op(mapping[t2], e75);
      };
    });
    LNumber._ops = { "*": function e23(t2, r) {
      return t2 * r;
    }, "+": function e24(t2, r) {
      return t2 + r;
    }, "-": function e25(t2, r) {
      if (typeof r === "undefined") {
        return -t2;
      }
      return t2 - r;
    }, "/": function e26(t2, r) {
      return t2 / r;
    }, "%": function e27(t2, r) {
      return t2 % r;
    }, "|": function e28(t2, r) {
      return t2 | r;
    }, "&": function e29(t2, r) {
      return t2 & r;
    }, "~": function e30(t2) {
      return ~t2;
    }, ">>": function e31(t2, r) {
      return t2 >> r;
    }, "<<": function e32(t2, r) {
      return t2 << r;
    } };
    LNumber.prototype.op = function(e75, t2) {
      if (typeof t2 === "undefined") {
        return LNumber(LNumber._ops[e75](this.valueOf()));
      }
      if (typeof t2 === "number") {
        t2 = LNumber(t2);
      }
      if (Number.isNaN(this.__value__) && !LNumber.isComplex(t2) || !LNumber.isComplex(this) && Number.isNaN(t2.__value__)) {
        return LNumber(NaN);
      }
      var r = this.coerce(t2), n = _slicedToArray(r, 2), i = n[0], a = n[1];
      if (i._op) {
        return i._op(e75, a);
      }
      return LNumber(LNumber._ops[e75](i, a));
    };
    LNumber.prototype.sqrt = function() {
      var e75 = this.valueOf();
      if (this.cmp(0) < 0) {
        var t2 = Math.sqrt(-e75);
        return LComplex({ re: 0, im: t2 });
      }
      return LNumber(Math.sqrt(e75));
    };
    pow = function e33(t2, r) {
      return Math.pow(t2, r);
    };
    try {
      exp_op = new Function("a,b", "return a ** b");
      if (exp_op(2, 2) === 4) {
        pow = exp_op;
      }
    } catch (e75) {
    }
    LNumber.prototype.pow = function(e75) {
      var t2;
      var r = this.coerce(e75), n = _slicedToArray(r, 2), i = n[0], a = n[1];
      if (LNumber.isNative(i.__value__) && LNumber.isNative(a.__value__)) {
        t2 = pow(i.__value__, a.__value__);
      } else if (LNumber.isBN(i.__value__) && LNumber.isBN(a.__value__)) {
        t2 = this.__value__.pow(e75.__value__);
      } else if (i.pow) {
        return i.pow(a);
      }
      return LNumber(t2);
    };
    LNumber.prototype.abs = function() {
      var e75 = this.__value__;
      if (LNumber.isNative(this.__value__)) {
        if (e75 < 0) {
          e75 = -e75;
        }
      } else if (LNumber.isBN(e75)) {
        e75.iabs();
      }
      return new LNumber(e75);
    };
    LNumber.prototype.isOdd = function() {
      if (LNumber.isNative(this.__value__)) {
        if (this.isBigNumber()) {
          return this.__value__ % BigInt(2) === BigInt(1);
        }
        if (this.__type__ === "float") {
          throw new Error("Invalid number float");
        }
        return this.__value__ % 2 === 1;
      } else if (LNumber.isBN(this.__value__)) {
        return this.__value__.isOdd();
      }
      throw new Error("Invalid number ".concat(this.__type__));
    };
    LNumber.prototype.isEven = function() {
      return !this.isOdd();
    };
    LNumber.prototype.cmp = function(e75) {
      var t2 = this.coerce(e75), r = _slicedToArray(t2, 2), n = r[0], i = r[1];
      function a(e76, t3) {
        if (e76.__value__ < t3.__value__) {
          return -1;
        } else if (e76.__value__ === t3.__value__) {
          return 0;
        } else {
          return 1;
        }
      }
      if (n.__type__ === "bigint") {
        if (LNumber.isNative(n.__value__)) {
          return a(n, i);
        } else if (LNumber.isBN(n.__value__)) {
          return this.__value__.cmp(i.__value__);
        }
      } else if (n instanceof LFloat) {
        return a(n, i);
      }
    };
    LComplex.prototype = Object.create(LNumber.prototype);
    LComplex.prototype.constructor = LComplex;
    LComplex.prototype.constant = function(e75, t2) {
      enumerable(this, "__im__", e75);
      enumerable(this, "__re__", t2);
      enumerable(this, "__type__", "complex");
    };
    LComplex.prototype.abs = function() {
      return LNumber(this.modulus());
    };
    LComplex.prototype.serialize = function() {
      return { re: this.__re__, im: this.__im__ };
    };
    LComplex.prototype.toRational = function(e75) {
      var t2 = this.__im__, r = this.__re__;
      if (LNumber.isFloat(this.__im__)) {
        t2 = LFloat(this.__im__).toRational(e75);
      }
      if (LNumber.isFloat(this.__re__)) {
        r = LFloat(this.__re__).toRational(e75);
      }
      return LComplex({ im: t2, re: r });
    };
    LComplex.prototype.pow = function(e75) {
      e75.cmp(0);
      if (e75 === 0) {
        return LNumber(1);
      }
      var t2 = LNumber(Math.atan2(this.__im__.valueOf(), this.__re__.valueOf()));
      var r = LNumber(this.modulus());
      if (LNumber.isComplex(e75) && e75.__im__.cmp(0) !== 0) {
        var n = e75.mul(Math.log(r.valueOf())).add(LComplex.i.mul(t2).mul(e75));
        if (!LNumber.isComplex(n)) {
          return LFloat(Math.E).pow(n);
        }
        var i = LFloat(Math.E).pow(n.__re__.valueOf());
        return LComplex({ re: i.mul(Math.cos(n.__im__.valueOf())), im: i.mul(Math.sin(n.__im__.valueOf())) });
      }
      var a = e75.__re__.cmp(0) > 0;
      e75 = e75.__re__.valueOf();
      if (LNumber.isInteger(e75) && a) {
        var o = this;
        while (--e75) {
          o = o.mul(this);
        }
        return o;
      }
      var u = r.pow(e75);
      var s = t2.mul(e75);
      return LComplex({ re: u.mul(Math.cos(s)), im: u.mul(Math.sin(s)) });
    };
    LComplex.prototype.add = function(e75) {
      return this.complex_op("add", e75, function(e76, t2, r, n) {
        return { re: e76.add(t2), im: r.add(n) };
      });
    };
    LComplex.prototype.factor = function() {
      if (this.__im__ instanceof LFloat || this.__im__ instanceof LFloat) {
        var e75 = this.__re__, t2 = this.__im__;
        var r, n;
        if (e75 instanceof LFloat) {
          r = e75.toRational().mul(e75.toRational());
        } else {
          r = e75.mul(e75);
        }
        if (t2 instanceof LFloat) {
          n = t2.toRational().mul(t2.toRational());
        } else {
          n = t2.mul(t2);
        }
        return r.add(n);
      } else {
        return this.__re__.mul(this.__re__).add(this.__im__.mul(this.__im__));
      }
    };
    LComplex.prototype.modulus = function() {
      return this.factor().sqrt();
    };
    LComplex.prototype.conjugate = function() {
      return LComplex({ re: this.__re__, im: this.__im__.sub() });
    };
    LComplex.prototype.sqrt = function() {
      var e75 = this.modulus();
      var t2, r;
      if (e75.cmp(0) === 0) {
        t2 = r = e75;
      } else if (this.__re__.cmp(0) === 1) {
        t2 = LFloat(0.5).mul(e75.add(this.__re__)).sqrt();
        r = this.__im__.div(t2).div(2);
      } else {
        r = LFloat(0.5).mul(e75.sub(this.__re__)).sqrt();
        if (this.__im__.cmp(0) === -1) {
          r = r.sub();
        }
        t2 = this.__im__.div(r).div(2);
      }
      return LComplex({ im: r, re: t2 });
    };
    LComplex.prototype.div = function(e75) {
      if (LNumber.isNumber(e75) && !LNumber.isComplex(e75)) {
        if (!(e75 instanceof LNumber)) {
          e75 = LNumber(e75);
        }
        var t2 = this.__re__.div(e75);
        var r = this.__im__.div(e75);
        return LComplex({ re: t2, im: r });
      } else if (!LNumber.isComplex(e75)) {
        throw new Error("[LComplex::div] Invalid value");
      }
      if (this.cmp(e75) === 0) {
        var n = this.coerce(e75), i = _slicedToArray(n, 2), a = i[0], o = i[1];
        var u = a.__im__.div(o.__im__);
        return u.coerce(o.__re__)[0];
      }
      var s = this.coerce(e75), c = _slicedToArray(s, 2), l = c[0], f = c[1];
      var _ = f.factor();
      var p = f.conjugate();
      var d = l.mul(p);
      if (!LNumber.isComplex(d)) {
        return d.div(_);
      }
      var h = d.__re__.op("/", _);
      var m = d.__im__.op("/", _);
      return LComplex({ re: h, im: m });
    };
    LComplex.prototype.sub = function(e75) {
      return this.complex_op("sub", e75, function(e76, t2, r, n) {
        return { re: e76.sub(t2), im: r.sub(n) };
      });
    };
    LComplex.prototype.mul = function(e75) {
      return this.complex_op("mul", e75, function(e76, t2, r, n) {
        var i = { re: e76.mul(t2).sub(r.mul(n)), im: e76.mul(n).add(t2.mul(r)) };
        return i;
      });
    };
    LComplex.prototype.complex_op = function(e75, t2, i) {
      var a = this;
      var r = function e76(t3, r2) {
        var n2 = i(a.__re__, t3, a.__im__, r2);
        if ("im" in n2 && "re" in n2) {
          if (n2.im.cmp(0) === 0) {
            return n2.re;
          }
          return LComplex(n2, true);
        }
        return n2;
      };
      if (typeof t2 === "undefined") {
        return r();
      }
      if (LNumber.isNumber(t2) && !LNumber.isComplex(t2)) {
        if (!(t2 instanceof LNumber)) {
          t2 = LNumber(t2);
        }
        var n = t2.asType(0);
        t2 = { __im__: n, __re__: t2 };
      } else if (!LNumber.isComplex(t2)) {
        throw new Error("[LComplex::".concat(e75, "] Invalid value"));
      }
      var o = t2.__re__ instanceof LNumber ? t2.__re__ : this.__re__.asType(t2.__re__);
      var u = t2.__im__ instanceof LNumber ? t2.__im__ : this.__im__.asType(t2.__im__);
      return r(o, u);
    };
    LComplex._op = { "+": "add", "-": "sub", "*": "mul", "/": "div" };
    LComplex.prototype._op = function(e75, t2) {
      var r = LComplex._op[e75];
      return this[r](t2);
    };
    LComplex.prototype.cmp = function(e75) {
      var t2 = this.coerce(e75), r = _slicedToArray(t2, 2), n = r[0], i = r[1];
      var a = n.__re__.coerce(i.__re__), o = _slicedToArray(a, 2), u = o[0], s = o[1];
      var c = u.cmp(s);
      if (c !== 0) {
        return c;
      } else {
        var l = n.__im__.coerce(i.__im__), f = _slicedToArray(l, 2), _ = f[0], p = f[1];
        return _.cmp(p);
      }
    };
    LComplex.prototype.valueOf = function() {
      return [this.__re__, this.__im__].map(function(e75) {
        return e75.valueOf();
      });
    };
    LComplex.prototype.toString = function() {
      var e75;
      if (this.__re__.cmp(0) !== 0) {
        e75 = [to_string(this.__re__)];
      } else {
        e75 = [];
      }
      var t2 = this.__im__.valueOf();
      var r = [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY].includes(t2);
      var n = to_string(this.__im__);
      if (!r && !Number.isNaN(t2)) {
        var i = this.__im__.cmp(0);
        if (i < 0 || i === 0 && this.__im__._minus) {
          e75.push("-");
        } else {
          e75.push("+");
        }
        n = n.replace(/^-/, "");
      }
      e75.push(n);
      e75.push("i");
      return e75.join("");
    };
    LFloat.prototype = Object.create(LNumber.prototype);
    LFloat.prototype.constructor = LFloat;
    LFloat.prototype.toString = function(e75) {
      if (this.__value__ === Number.NEGATIVE_INFINITY) {
        return "-inf.0";
      }
      if (this.__value__ === Number.POSITIVE_INFINITY) {
        return "+inf.0";
      }
      if (Number.isNaN(this.__value__)) {
        return "+nan.0";
      }
      e75 && (e75 = e75.valueOf());
      var t2 = this.__value__.toString(e75);
      if (!t2.match(/e[+-]?[0-9]+$/i)) {
        var r = t2.replace(/^-/, "");
        var n = this.__value__ < 0 ? "-" : "";
        if (t2.match(/^-?0\.0{3}/)) {
          var i = r.match(/^[.0]+/g)[0].length - 1;
          var a = r.replace(/^[.0]+/, "").replace(/^([0-9a-f])/i, "$1.");
          return "".concat(n).concat(a, "e-").concat(i.toString(e75));
        }
        if (t2.match(/^-?[0-9a-f]{7,}\.?/i)) {
          var o = r.match(/^[0-9a-f]+/gi)[0].length - 1;
          var u = r.replace(/\./, "").replace(/^([0-9a-f])/i, "$1.").replace(/0+$/, "").replace(/\.$/, ".0");
          return "".concat(n).concat(u, "e+").concat(o.toString(e75));
        }
        if (!LNumber.isFloat(this.__value__)) {
          var s = t2 + ".0";
          return this._minus ? "-" + s : s;
        }
      }
      return t2.replace(/^([0-9]+)e/, "$1.0e");
    };
    LFloat.prototype._op = function(e75, t2) {
      if (t2 instanceof LNumber) {
        t2 = t2.__value__;
      }
      var r = LNumber._ops[e75];
      if (e75 === "/" && this.__value__ === 0 && t2 === 0) {
        return NaN;
      }
      return LFloat(r(this.__value__, t2));
    };
    LFloat.prototype.toRational = function() {
      var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (e75 === null) {
        return toRational(this.__value__.valueOf());
      }
      return approxRatio(e75.valueOf())(this.__value__.valueOf());
    };
    LFloat.prototype.sqrt = function() {
      var e75 = this.valueOf();
      if (this.cmp(0) < 0) {
        var t2 = LFloat(Math.sqrt(-e75));
        return LComplex({ re: 0, im: t2 });
      }
      return LFloat(Math.sqrt(e75));
    };
    LFloat.prototype.abs = function() {
      var e75 = this.valueOf();
      if (e75 < 0) {
        e75 = -e75;
      }
      return LFloat(e75);
    };
    toRational = approxRatio(1e-10);
    LRational.prototype = Object.create(LNumber.prototype);
    LRational.prototype.constructor = LRational;
    LRational.prototype.constant = function(e75, t2) {
      enumerable(this, "__num__", e75);
      enumerable(this, "__denom__", t2);
      enumerable(this, "__type__", "rational");
    };
    LRational.prototype.serialize = function() {
      return { num: this.__num__, denom: this.__denom__ };
    };
    LRational.prototype.pow = function(e75) {
      if (LNumber.isRational(e75)) {
        return LNumber(pow(this.valueOf(), e75.valueOf()));
      }
      var t2 = e75.cmp(0);
      if (t2 === 0) {
        return LNumber(1);
      }
      if (t2 === -1) {
        e75 = e75.sub();
        var r = this.__denom__.pow(e75);
        var n = this.__num__.pow(e75);
        return LRational({ num: r, denom: n });
      }
      var i = this;
      e75 = e75.valueOf();
      while (e75 > 1) {
        i = i.mul(this);
        e75--;
      }
      return i;
    };
    LRational.prototype.sqrt = function() {
      var e75 = this.__num__.sqrt();
      var t2 = this.__denom__.sqrt();
      if (e75 instanceof LFloat || t2 instanceof LFloat) {
        return e75.div(t2);
      }
      return LRational({ num: e75, denom: t2 });
    };
    LRational.prototype.abs = function() {
      var e75 = this.__num__;
      var t2 = this.__denom__;
      if (e75.cmp(0) === -1) {
        e75 = e75.sub();
      }
      if (t2.cmp(0) !== 1) {
        t2 = t2.sub();
      }
      return LRational({ num: e75, denom: t2 });
    };
    LRational.prototype.cmp = function(e75) {
      return LNumber(this.valueOf(), true).cmp(e75);
    };
    LRational.prototype.toString = function() {
      var e75 = this.__num__.gcd(this.__denom__);
      var t2, r;
      if (e75.cmp(1) !== 0) {
        t2 = this.__num__.div(e75);
        if (t2 instanceof LRational) {
          t2 = LNumber(t2.valueOf(true));
        }
        r = this.__denom__.div(e75);
        if (r instanceof LRational) {
          r = LNumber(r.valueOf(true));
        }
      } else {
        t2 = this.__num__;
        r = this.__denom__;
      }
      var n = this.cmp(0) < 0;
      if (n) {
        if (t2.abs().cmp(r.abs()) === 0) {
          return t2.toString();
        }
      } else if (t2.cmp(r) === 0) {
        return t2.toString();
      }
      return t2.toString() + "/" + r.toString();
    };
    LRational.prototype.valueOf = function(e75) {
      if (this.__denom__.cmp(0) === 0) {
        if (this.__num__.cmp(0) < 0) {
          return Number.NEGATIVE_INFINITY;
        }
        return Number.POSITIVE_INFINITY;
      }
      if (e75) {
        return LNumber._ops["/"](this.__num__.value, this.__denom__.value);
      }
      return LFloat(this.__num__.valueOf()).div(this.__denom__.valueOf());
    };
    LRational.prototype.mul = function(e75) {
      if (!(e75 instanceof LNumber)) {
        e75 = LNumber(e75);
      }
      if (LNumber.isRational(e75)) {
        var t2 = this.__num__.mul(e75.__num__);
        var r = this.__denom__.mul(e75.__denom__);
        return LRational({ num: t2, denom: r });
      }
      var n = LNumber.coerce(this, e75), i = _slicedToArray(n, 2), a = i[0], o = i[1];
      return a.mul(o);
    };
    LRational.prototype.div = function(e75) {
      if (!(e75 instanceof LNumber)) {
        e75 = LNumber(e75);
      }
      if (LNumber.isRational(e75)) {
        var t2 = this.__num__.mul(e75.__denom__);
        var r = this.__denom__.mul(e75.__num__);
        return LRational({ num: t2, denom: r });
      }
      var n = LNumber.coerce(this, e75), i = _slicedToArray(n, 2), a = i[0], o = i[1];
      var u = a.div(o);
      return u;
    };
    LRational.prototype._op = function(e75, t2) {
      return this[rev_mapping[e75]](t2);
    };
    LRational.prototype.sub = function(e75) {
      if (typeof e75 === "undefined") {
        return this.mul(-1);
      }
      if (!(e75 instanceof LNumber)) {
        e75 = LNumber(e75);
      }
      if (LNumber.isRational(e75)) {
        var t2 = e75.__num__.sub();
        var r = e75.__denom__;
        return this.add(LRational({ num: t2, denom: r }));
      }
      if (!(e75 instanceof LNumber)) {
        e75 = LNumber(e75).sub();
      } else {
        e75 = e75.sub();
      }
      var n = LNumber.coerce(this, e75), i = _slicedToArray(n, 2), a = i[0], o = i[1];
      return a.add(o);
    };
    LRational.prototype.add = function(e75) {
      if (!(e75 instanceof LNumber)) {
        e75 = LNumber(e75);
      }
      if (LNumber.isRational(e75)) {
        var t2 = this.__denom__;
        var r = e75.__denom__;
        var n = this.__num__;
        var i = e75.__num__;
        var a, o;
        if (t2 !== r) {
          o = r.mul(n).add(i.mul(t2));
          a = t2.mul(r);
        } else {
          o = n.add(i);
          a = t2;
        }
        return LRational({ num: o, denom: a });
      }
      if (LNumber.isFloat(e75)) {
        return LFloat(this.valueOf()).add(e75);
      }
      var u = LNumber.coerce(this, e75), s = _slicedToArray(u, 2), c = s[0], l = s[1];
      return c.add(l);
    };
    LBigInteger.prototype = Object.create(LNumber.prototype);
    LBigInteger.prototype.constructor = LBigInteger;
    LBigInteger.bn_op = { "+": "iadd", "-": "isub", "*": "imul", "/": "idiv", "%": "imod", "|": "ior", "&": "iand", "~": "inot", "<<": "ishrn", ">>": "ishln" };
    LBigInteger.prototype.serialize = function() {
      return this.__value__.toString();
    };
    LBigInteger.prototype._op = function(e75, t2) {
      if (typeof t2 === "undefined") {
        if (LNumber.isBN(this.__value__)) {
          e75 = LBigInteger.bn_op[e75];
          return LBigInteger(this.__value__.clone()[e75](), false);
        }
        return LBigInteger(LNumber._ops[e75](this.__value__), true);
      }
      if (LNumber.isBN(this.__value__) && LNumber.isBN(t2.__value__)) {
        e75 = LBigInteger.bn_op[e75];
        return LBigInteger(this.__value__.clone()[e75](t2), false);
      }
      var r = LNumber._ops[e75](this.__value__, t2.__value__);
      if (e75 === "/") {
        var n = this.op("%", t2).cmp(0) === 0;
        if (n) {
          return LNumber(r);
        }
        return LRational({ num: this, denom: t2 });
      }
      return LBigInteger(r, true);
    };
    LBigInteger.prototype.sqrt = function() {
      var e75;
      var t2 = this.cmp(0) < 0;
      if (LNumber.isNative(this.__value__)) {
        e75 = LNumber(Math.sqrt(t2 ? -this.valueOf() : this.valueOf()));
      } else if (LNumber.isBN(this.__value__)) {
        e75 = t2 ? this.__value__.neg().sqrt() : this.__value__.sqrt();
      }
      if (t2) {
        return LComplex({ re: 0, im: e75 });
      }
      return e75;
    };
    LNumber.NaN = LNumber(NaN);
    LComplex.i = LComplex({ im: 1, re: 0 });
    InputPort.prototype._make_defaults = function() {
      this.read = this._with_parser(function(e75) {
        return e75.read_object();
      });
      this.read_line = this._with_parser(function(e75) {
        return e75.__lexer__.read_line();
      });
      this.read_char = this._with_parser(function(e75) {
        return e75.__lexer__.read_char();
      });
      this.read_string = this._with_parser(function(e75, t2) {
        if (!LNumber.isInteger(t2)) {
          var r = LNumber.getType(t2);
          typeErrorMessage("read-string", r, "integer");
        }
        return e75.__lexer__.read_string(t2.valueOf());
      });
      this.peek_char = this._with_parser(function(e75) {
        return e75.__lexer__.peek_char();
      });
    };
    InputPort.prototype._with_init_parser = function(u, s) {
      var c = this;
      return _asyncToGenerator(_regeneratorRuntime.mark(function e75() {
        var r, n, i, a, o = arguments;
        return _regeneratorRuntime.wrap(function e76(t2) {
          while (1) switch (t2.prev = t2.next) {
            case 0:
              t2.next = 2;
              return u.call(c);
            case 2:
              r = t2.sent;
              for (n = o.length, i = new Array(n), a = 0; a < n; a++) {
                i[a] = o[a];
              }
              return t2.abrupt("return", s.apply(void 0, [r].concat(i)));
            case 5:
            case "end":
              return t2.stop();
          }
        }, e75);
      }));
    };
    InputPort.prototype.is_open = function() {
      return this._with_parser !== null;
    };
    InputPort.prototype.close = function() {
      var t2 = this;
      this.__parser__ = null;
      this._with_parser = null;
      ["read", "close", "read_char", "peek-char", "read_line"].forEach(function(e75) {
        t2[e75] = function() {
          throw new Error("input-port: port is closed");
        };
      });
      this.char_ready = function() {
        return false;
      };
    };
    InputPort.prototype.toString = function() {
      return "#<input-port>";
    };
    OutputPort.prototype.is_open = function() {
      return this._closed !== true;
    };
    OutputPort.prototype.close = function() {
      Object.defineProperty(this, "_closed", { get: function e75() {
        return true;
      }, set: function e75() {
      }, configurable: false, enumerable: false });
      this.write = function() {
        throw new Error("output-port: port is closed");
      };
    };
    OutputPort.prototype.flush = function() {
    };
    OutputPort.prototype.toString = function() {
      return "#<output-port>";
    };
    BufferedOutputPort = function(e75) {
      function r(e76) {
        var t2;
        _classCallCheck(this, r);
        t2 = _callSuper(this, r, [function() {
          var e77;
          return (e77 = t2)._write.apply(e77, arguments);
        }]);
        typecheck("BufferedOutputPort", e76, "function");
        read_only(t2, "_fn", e76, { hidden: true });
        read_only(t2, "_buffer", [], { hidden: true });
        return t2;
      }
      _inherits(r, e75);
      return _createClass(r, [{ key: "flush", value: function e76() {
        if (this._buffer.length) {
          this._fn(this._buffer.join(""));
          this._buffer.length = 0;
        }
      } }, { key: "_write", value: function e76() {
        var t2 = this;
        for (var r2 = arguments.length, n = new Array(r2), i = 0; i < r2; i++) {
          n[i] = arguments[i];
        }
        if (n.length) {
          n.forEach(function(e77) {
            t2._buffer.push(e77);
          });
          var a = this._buffer[this._buffer.length - 1];
          if (a.match(/\n$/)) {
            this._buffer[this._buffer.length - 1] = a.replace(/\n$/, "");
            this.flush();
          }
        }
      } }]);
    }(OutputPort);
    OutputStringPort.prototype = Object.create(OutputPort.prototype);
    OutputStringPort.prototype.constructor = OutputStringPort;
    OutputStringPort.prototype.toString = function() {
      return "#<output-port (string)>";
    };
    OutputStringPort.prototype.valueOf = function() {
      return this.__buffer__.map(function(e75) {
        return e75.valueOf();
      }).join("");
    };
    OutputFilePort.prototype = Object.create(OutputPort.prototype);
    OutputFilePort.prototype.constructor = OutputFilePort;
    OutputFilePort.prototype.fs = function() {
      if (!this._fs) {
        this._fs = this.internal("fs");
      }
      return this._fs;
    };
    OutputFilePort.prototype.internal = function(e75) {
      return user_env.get("**internal-env**").get(e75);
    };
    OutputFilePort.prototype.close = function() {
      var n = this;
      return new Promise(function(t2, r) {
        n.fs().close(n._fd, function(e75) {
          if (e75) {
            r(e75);
          } else {
            read_only(n, "_fd", null, { hidden: true });
            OutputPort.prototype.close.call(n);
            t2();
          }
        });
      });
    };
    OutputFilePort.prototype.toString = function() {
      return "#<output-port ".concat(this.__filename__, ">");
    };
    InputStringPort.prototype.char_ready = function() {
      return true;
    };
    InputStringPort.prototype = Object.create(InputPort.prototype);
    InputStringPort.prototype.constructor = InputStringPort;
    InputStringPort.prototype.toString = function() {
      return "#<input-port (string)>";
    };
    ParserInputPort.prototype.char_ready = function() {
      return true;
    };
    ParserInputPort.prototype = Object.create(InputPort.prototype);
    ParserInputPort.prototype.constructor = ParserInputPort;
    ParserInputPort.prototype.toString = function() {
      return "#<input-port (parser)>";
    };
    InputByteVectorPort.prototype = Object.create(InputPort.prototype);
    InputByteVectorPort.prototype.constructor = InputByteVectorPort;
    InputByteVectorPort.prototype.toString = function() {
      return "#<input-port (bytevector)>";
    };
    InputByteVectorPort.prototype.close = function() {
      var t2 = this;
      read_only(this, "__vector__", _nil);
      var r = function e75() {
        throw new Error("Input-binary-port: port is closed");
      };
      ["read_u8", "close", "peek_u8", "read_u8_vector"].forEach(function(e75) {
        t2[e75] = r;
      });
      this.u8_ready = this.char_ready = function() {
        return false;
      };
    };
    InputByteVectorPort.prototype.u8_ready = function() {
      return true;
    };
    InputByteVectorPort.prototype.peek_u8 = function() {
      if (this.__index__ >= this.__vector__.length) {
        return eof;
      }
      return this.__vector__[this.__index__];
    };
    InputByteVectorPort.prototype.skip = function() {
      if (this.__index__ <= this.__vector__.length) {
        ++this.__index__;
      }
    };
    InputByteVectorPort.prototype.read_u8 = function() {
      var e75 = this.peek_u8();
      this.skip();
      return e75;
    };
    InputByteVectorPort.prototype.read_u8_vector = function(e75) {
      if (typeof e75 === "undefined") {
        e75 = this.__vector__.length;
      } else if (e75 > this.__index__ + this.__vector__.length) {
        e75 = this.__index__ + this.__vector__.length;
      }
      if (this.peek_u8() === eof) {
        return eof;
      }
      return this.__vector__.slice(this.__index__, e75);
    };
    OutputByteVectorPort.prototype = Object.create(OutputPort.prototype);
    OutputByteVectorPort.prototype.constructor = OutputByteVectorPort;
    OutputByteVectorPort.prototype.close = function() {
      OutputPort.prototype.close.call(this);
      read_only(this, "_buffer", null, { hidden: true });
    };
    OutputByteVectorPort.prototype._close_guard = function() {
      if (this._closed) {
        throw new Error("output-port: binary port is closed");
      }
    };
    OutputByteVectorPort.prototype.write_u8 = function(e75) {
      typecheck("OutputByteVectorPort::write_u8", e75, "number");
      this.write(e75);
    };
    OutputByteVectorPort.prototype.write_u8_vector = function(e75) {
      typecheck("OutputByteVectorPort::write_u8_vector", e75, "uint8array");
      this.write(e75);
    };
    OutputByteVectorPort.prototype.toString = function() {
      return "#<output-port (bytevector)>";
    };
    OutputByteVectorPort.prototype.valueOf = function() {
      return this.__buffer__;
    };
    InputFilePort.prototype = Object.create(InputStringPort.prototype);
    InputFilePort.prototype.constructor = InputFilePort;
    InputFilePort.prototype.toString = function() {
      return "#<input-port (".concat(this.__filename__, ")>");
    };
    InputBinaryFilePort.prototype = Object.create(InputByteVectorPort.prototype);
    InputBinaryFilePort.prototype.constructor = InputBinaryFilePort;
    InputBinaryFilePort.prototype.toString = function() {
      return "#<input-binary-port (".concat(this.__filename__, ")>");
    };
    OutputBinaryFilePort.prototype = Object.create(OutputFilePort.prototype);
    OutputBinaryFilePort.prototype.constructor = OutputBinaryFilePort;
    OutputBinaryFilePort.prototype.write_u8 = function(e75) {
      typecheck("OutputByteVectorPort::write_u8", e75, "number");
      this.write(e75);
    };
    OutputBinaryFilePort.prototype.write_u8_vector = function(e75) {
      typecheck("OutputByteVectorPort::write_u8_vector", e75, "uint8array");
      this.write(e75);
    };
    binary_port = Symbol["for"]("binary");
    text_port = Symbol["for"]("text");
    eof = new EOF();
    EOF.prototype.toString = function() {
      return "#<eof>";
    };
    Interpreter.prototype.exec = function() {
      var t2 = _asyncToGenerator(function(s) {
        var c = this;
        var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return _regeneratorRuntime.mark(function e75() {
          var r, n, i, a, o, u;
          return _regeneratorRuntime.wrap(function e76(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                r = l.use_dynamic, n = r === void 0 ? false : r, i = l.dynamic_env, a = l.env;
                typecheck("Interpreter::exec", s, ["string", "array"], 1);
                typecheck("Interpreter::exec", n, "boolean", 2);
                if (!a) {
                  a = c.__env__;
                }
                if (!i) {
                  i = a;
                }
                global_env.set("**interaction-environment**", c.__env__);
                if (!Array.isArray(s)) {
                  t3.next = 10;
                  break;
                }
                return t3.abrupt("return", exec(s, { env: a, dynamic_env: i, use_dynamic: n }));
              case 10:
                t3.prev = 10;
                c.__parser__.prepare(s);
                t3.next = 14;
                return exec(c.__parser__, { env: a, dynamic_env: i, use_dynamic: n });
              case 14:
                return t3.abrupt("return", t3.sent);
              case 17:
                t3.prev = 17;
                t3.t0 = t3["catch"](10);
                if (!((o = t3.t0.message) !== null && o !== void 0 && o.includes("at line"))) {
                  u = " at line ".concat(c.__parser__.get_line() + 1);
                  t3.t0.message += u;
                }
                throw t3.t0;
              case 21:
              case "end":
                return t3.stop();
            }
          }, e75, null, [[10, 17]]);
        })();
      });
      return function(e75) {
        return t2.apply(this, arguments);
      };
    }();
    Interpreter.prototype.get = function(e75) {
      var t2 = this.__env__.get(e75);
      if (is_function(t2)) {
        var r = new LambdaContext({ env: this.__env__ });
        return t2.bind(r);
      }
      return t2;
    };
    Interpreter.prototype.set = function(e75, t2) {
      return this.__env__.set(e75, t2);
    };
    Interpreter.prototype.constant = function(e75, t2) {
      return this.__env__.constant(e75, t2);
    };
    LipsError.prototype = new Error();
    LipsError.prototype.constructor = LipsError;
    IgnoreException = function(e75) {
      function t2() {
        _classCallCheck(this, t2);
        return _callSuper(this, t2, arguments);
      }
      _inherits(t2, e75);
      return _createClass(t2);
    }(_wrapNativeSuper(Error));
    Environment.prototype.list = function() {
      return get_props(this.__env__);
    };
    Environment.prototype.fs = function() {
      return this.get("**fs**");
    };
    Environment.prototype.unset = function(e75) {
      if (e75 instanceof LSymbol) {
        e75 = e75.valueOf();
      }
      if (e75 instanceof LString) {
        e75 = e75.valueOf();
      }
      delete this.__env__[e75];
    };
    Environment.prototype.inherit = function(e75) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (_typeof$1(e75) === "object") {
        t2 = e75;
      }
      if (!e75 || _typeof$1(e75) === "object") {
        e75 = "child of " + (this.__name__ || "unknown");
      }
      return new Environment(t2 || {}, this, e75);
    };
    Environment.prototype.doc = function(e75) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (e75 instanceof LSymbol) {
        e75 = e75.__name__;
      }
      if (e75 instanceof LString) {
        e75 = e75.valueOf();
      }
      if (t2) {
        if (!r) {
          t2 = trim_lines(t2);
        }
        this.__docs__.set(e75, t2);
        return this;
      }
      if (this.__docs__.has(e75)) {
        return this.__docs__.get(e75);
      }
      if (this.__parent__) {
        return this.__parent__.doc(e75);
      }
    };
    Environment.prototype.new_frame = function(e75, t2) {
      var n = this.inherit("__frame__");
      n.set("parent.frame", doc("parent.frame", function() {
        var e76 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        e76 = e76.valueOf();
        var t3 = n.__parent__;
        if (!is_env(t3)) {
          return _nil;
        }
        if (e76 <= 0) {
          return t3;
        }
        var r = t3.get("parent.frame");
        return r(e76 - 1);
      }, global_env.__env__["parent.frame"].__doc__));
      t2.callee = e75;
      n.set("arguments", t2);
      return n;
    };
    Environment.prototype._lookup = function(e75) {
      if (e75 instanceof LSymbol) {
        e75 = e75.__name__;
      }
      if (e75 instanceof LString) {
        e75 = e75.valueOf();
      }
      if (this.__env__.hasOwnProperty(e75)) {
        return Value(this.__env__[e75]);
      }
      if (this.__parent__) {
        return this.__parent__._lookup(e75);
      }
    };
    Environment.prototype.toString = function() {
      return "#<environment:" + this.__name__ + ">";
    };
    Environment.prototype.clone = function() {
      var t2 = this;
      var r = {};
      Object.keys(this.__env__).forEach(function(e75) {
        r[e75] = t2.__env__[e75];
      });
      return new Environment(r, this.__parent__, this.__name__);
    };
    Environment.prototype.merge = function(e75) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "merge";
      typecheck("Environment::merge", e75, "environment");
      return this.inherit(t2, e75.__env__);
    };
    Value.isUndefined = function(e75) {
      return e75 instanceof Value && typeof e75.value === "undefined";
    };
    Value.prototype.valueOf = function() {
      return this.value;
    };
    Values.prototype.toString = function() {
      return this.__values__.map(function(e75) {
        return to_string(e75);
      }).join("\n");
    };
    Values.prototype.valueOf = function() {
      return this.__values__;
    };
    Environment.prototype.get = function(e75) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      typecheck("Environment::get", e75, ["symbol", "string"]);
      var r = t2.throwError, n = r === void 0 ? true : r;
      var i = e75;
      if (i instanceof LSymbol || i instanceof LString) {
        i = i.valueOf();
      }
      var a = this._lookup(i);
      if (a instanceof Value) {
        if (Value.isUndefined(a)) {
          return void 0;
        }
        return patch_value(a.valueOf());
      }
      var o;
      if (e75 instanceof LSymbol && e75[LSymbol.object]) {
        o = e75[LSymbol.object];
      } else if (typeof i === "string") {
        o = i.split(".").filter(Boolean);
      }
      if (o && o.length > 0) {
        var u = o, s = _toArray(u), c = s[0], l = s.slice(1);
        a = this._lookup(c);
        if (l.length) {
          try {
            if (a instanceof Value) {
              a = a.valueOf();
            } else {
              a = get2(root, c);
              if (is_function(a)) {
                a = unbind(a);
              }
            }
            if (typeof a !== "undefined") {
              return get2.apply(void 0, [a].concat(_toConsumableArray(l)));
            }
          } catch (e76) {
            throw e76;
          }
        } else if (a instanceof Value) {
          return patch_value(a.valueOf());
        }
        a = get2(root, i);
      }
      if (typeof a !== "undefined") {
        return a;
      }
      if (n) {
        throw new Error("Unbound variable `" + i.toString() + "'");
      }
    };
    Environment.prototype.set = function(e75, t2) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      typecheck("Environment::set", e75, ["string", "symbol"]);
      if (LNumber.isNumber(t2)) {
        t2 = LNumber(t2);
      }
      if (e75 instanceof LSymbol) {
        e75 = e75.__name__;
      }
      if (e75 instanceof LString) {
        e75 = e75.valueOf();
      }
      this.__env__[e75] = t2;
      if (r) {
        this.doc(e75, r, true);
      }
      return this;
    };
    Environment.prototype.constant = function(t2, e75) {
      var r = this;
      if (this.__env__.hasOwnProperty(t2)) {
        throw new Error("Environment::constant: ".concat(t2, " already exists"));
      }
      if (arguments.length === 1 && is_plain_object(arguments[0])) {
        var n = arguments[0];
        Object.keys(n).forEach(function(e76) {
          r.constant(t2, n[e76]);
        });
      } else {
        enumerable(this.__env__, t2, e75);
      }
      return this;
    };
    Environment.prototype.has = function(e75) {
      return this.__env__.hasOwnProperty(e75);
    };
    Environment.prototype.ref = function(e75) {
      var t2 = this;
      while (true) {
        if (!t2) {
          break;
        }
        if (t2.has(e75)) {
          return t2;
        }
        t2 = t2.__parent__;
      }
    };
    Environment.prototype.parents = function() {
      var e75 = this;
      var t2 = [];
      while (e75) {
        t2.unshift(e75);
        e75 = e75.__parent__;
      }
      return t2;
    };
    native_lambda = _parse(tokenize('(lambda ()\n                                        "[native code]"\n                                        (throw "Invalid Invocation"))'))[0];
    get2 = doc("get", function e34(t2) {
      var r;
      for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) {
        i[a - 1] = arguments[a];
      }
      var o = i.length;
      while (i.length) {
        if (is_function(t2) && _typeof$1(i[0]) !== "symbol") {
          t2 = unbind(t2);
        }
        var u = i.shift();
        var s = unbox(u);
        if (s === "then" && t2 instanceof QuotedPromise) {
          r = QuotedPromise.prototype.then;
        } else if (s === "__code__" && is_function(t2) && typeof t2.__code__ === "undefined") {
          r = native_lambda;
        } else {
          r = t2[s];
        }
        if (typeof r === "undefined") {
          if (i.length) {
            throw new Error("Try to get ".concat(i[0], " from undefined"));
          }
          return r;
        } else {
          var c;
          if (i.length - 1 < o) {
            c = t2;
          }
          r = patch_value(r, c);
        }
        t2 = r;
      }
      return r;
    }, "(. obj . args)\n    (get obj . args)\n\n    This function uses an object as a base and keeps using arguments to get the\n    property of JavaScript object. Arguments need to be a strings.\n    e.g. `(. console \"log\")` if you use any function inside LIPS it\n    will be weakly bound (can be rebound), so you can call this log function\n    without problem unlike in JavaScript when you use\n    `var log = console.log`.\n    `get` is an alias because . doesn't work everywhere, e.g. you can't\n    pass it as an argument.");
    internal_env = new Environment({ stdout: new BufferedOutputPort(function() {
      var e75;
      (e75 = console).log.apply(e75, arguments);
    }), stderr: new BufferedOutputPort(function() {
      var e75;
      (e75 = console).error.apply(e75, arguments);
    }), "command-line": [], stdin: InputPort(function() {
      return Promise.resolve(prompt(""));
    }), "letter-unicode-regex": /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])/, "numeral-unicode-regex": /(?:[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDD40-\uDD49\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDED0-\uDEE3\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2\uDD50-\uDD59\uDFF0-\uDFF9]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDF50-\uDF59\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD818[\uDD30-\uDD39]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDD70-\uDD79\uDE80-\uDE96]|\uD833[\uDCF0-\uDCF9]|\uD834[\uDEC0-\uDED3\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD839[\uDCF0-\uDCF9\uDDF1-\uDDFA]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9])/, "space-unicode-regex": /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/ }, void 0, "internal");
    nan = LNumber(NaN);
    constants = _objectSpread({ "#t": true, "#f": false, "#true": true, "#false": false, "+inf.0": Number.POSITIVE_INFINITY, "-inf.0": Number.NEGATIVE_INFINITY, "+nan.0": nan, "-nan.0": nan }, parsable_contants);
    global_env = new Environment({ eof, undefined: void 0, "peek-char": doc("peek-char", function() {
      var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (e75 === null) {
        e75 = internal(this, "stdin");
      }
      typecheck_text_port("peek-char", e75, "input-port");
      return e75.peek_char();
    }, "(peek-char port)\n\n        This function reads and returns a character from the string\n        port, or, if there is no more data in the string port, it\n        returns an EOF."), "read-line": doc("read-line", function() {
      var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (e75 === null) {
        e75 = internal(this, "stdin");
      }
      typecheck_text_port("read-line", e75, "input-port");
      return e75.read_line();
    }, "(read-line port)\n\n        This function reads and returns the next line from the input\n        port."), "read-char": doc("read-char", function() {
      var e75 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (e75 === null) {
        e75 = internal(this, "stdin");
      }
      typecheck_text_port("read-char", e75, "input-port");
      return e75.read_char();
    }, "(read-char port)\n\n        This function reads and returns the next character from the\n        input port."), read: doc("read", function() {
      var e75 = _asyncToGenerator(function() {
        var i = this;
        var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return _regeneratorRuntime.mark(function e76() {
          var r, n;
          return _regeneratorRuntime.wrap(function e77(t3) {
            while (1) switch (t3.prev = t3.next) {
              case 0:
                r = i.env;
                if (a === null) {
                  n = internal(r, "stdin");
                } else {
                  n = a;
                }
                typecheck_text_port("read", n, "input-port");
                return t3.abrupt("return", n.read.call(r));
              case 4:
              case "end":
                return t3.stop();
            }
          }, e76);
        })();
      });
      function t2() {
        return e75.apply(this, arguments);
      }
      return t2;
    }(), "(read [port])\n\n        This function, if called with a port, it will parse the next\n        item from the port. If called without an input, it will read\n        a string from standard input (using the browser's prompt or\n        a user defined input method) and parse it. This function can be\n        used together with `eval` to evaluate code from port."), pprint: doc("pprint", function e35(t2) {
      if (is_pair(t2)) {
        t2 = new lips.Formatter(t2.toString(true))["break"]().format();
        global_env.get("display").call(global_env, t2);
      } else {
        global_env.get("write").call(global_env, t2);
      }
      global_env.get("newline").call(global_env);
    }, "(pprint expression)\n\n        This function will pretty print its input to stdout. If it is called\n        with a non-list, it will just call the print function on its\n        input."), print: doc("print", function e36() {
      var t2 = global_env.get("display");
      var r = global_env.get("newline");
      var n = this.use_dynamic;
      var i = global_env;
      var a = global_env;
      for (var o = arguments.length, u = new Array(o), s = 0; s < o; s++) {
        u[s] = arguments[s];
      }
      u.forEach(function(e75) {
        call_function(t2, [e75], { env: i, dynamic_env: a, use_dynamic: n });
        call_function(r, [], { env: i, dynamic_env: a, use_dynamic: n });
      });
    }, "(print . args)\n\n        This function converts each input into a string and prints\n        the result to the standard output (by default it's the\n        console but it can be defined in user code). This function\n        calls `(newline)` after printing each input."), format: doc("format", function e37(t2) {
      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) {
        n[i - 1] = arguments[i];
      }
      typecheck("format", t2, "string");
      var a = /(~[as%~])/g;
      var o = t2.match(/(~[as])/g);
      if (o && o.length > n.length) {
        throw new Error("Not enough arguments");
      }
      var u = 0;
      var s = global_env.get("repr");
      t2 = t2.replace(a, function(e75) {
        var t3 = e75[1];
        if (t3 === "~") {
          return "~";
        } else if (t3 === "%") {
          return "\n";
        } else {
          var r2 = n[u++];
          if (t3 === "a") {
            return s(r2);
          } else {
            return s(r2, true);
          }
        }
      });
      o = t2.match(/~([\S])/);
      if (o) {
        throw new Error("format: Unrecognized escape sequence ".concat(o[1]));
      }
      return t2;
    }, "(format string n1 n2 ...)\n\n        This function accepts a string template and replaces any\n        escape sequences in its inputs:\n\n        * ~a value as if printed with `display`\n        * ~s value as if printed with `write`\n        * ~% newline character\n        * ~~ literal tilde '~'\n\n        If there are missing inputs or other escape characters it\n        will error."), newline: doc("newline", function e38() {
      var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      var r = global_env.get("display");
      var n = this.use_dynamic;
      var i = global_env;
      var a = global_env;
      call_function(r, ["\n", t2], { env: i, dynamic_env: a, use_dynamic: n });
    }, "(newline [port])\n\n        Write newline character to standard output or given port"), display: doc("display", function e39(t2) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (r === null) {
        r = internal(this, "stdout");
      } else {
        typecheck("display", r, "output-port");
      }
      var n = t2;
      if (!(r instanceof OutputBinaryFilePort)) {
        n = global_env.get("repr")(t2);
      }
      r.write.call(global_env, n);
    }, "(display string [port])\n\n        This function outputs the string to the standard output or\n        the port if given. No newline."), "display-error": doc("display-error", function e40() {
      var t2 = internal(this, "stderr");
      var r = global_env.get("repr");
      for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++) {
        i[a] = arguments[a];
      }
      var o = i.map(r).join(" ");
      t2.write.call(global_env, o);
      global_env.get("newline").call(this, t2);
    }, "(display-error . args)\n\n        Display an error message on stderr."), "%foldcase-string": doc("%foldcase-string", foldcase_string, "(%foldcase-string string)\n\n         Same as string-foldcase but without typechecking"), "%same-functions": doc("%same-functions", function(e75, t2) {
      if (!is_function(e75)) {
        return false;
      }
      if (!is_function(t2)) {
        return false;
      }
      return unbind(e75) === unbind(t2);
    }, "(%same-functions a b)\n\n        A helper function that checks if the two input functions are\n        the same."), help: doc(new Macro("help", function(e75, t2) {
      var r = t2.dynamic_env, n = t2.use_dynamic, i = t2.error;
      var a;
      if (e75.car instanceof LSymbol) {
        a = e75.car;
      } else if (is_pair(e75.car) && e75.car.car instanceof LSymbol) {
        a = e75.car.car;
      } else {
        var o = this;
        r = this;
        var u = _evaluate(e75.car, { env: o, error: i, dynamic_env: r, use_dynamic: n });
        if (u && u.__doc__) {
          return u.__doc__;
        }
        return;
      }
      var s;
      var c = this.get(a);
      s = c && c.__doc__;
      if (s) {
        return s;
      }
      var l = this.ref(a);
      if (l) {
        s = l.doc(a);
        if (s) {
          return s;
        }
      }
    }), "(help object)\n\n         This macro returns documentation for a function, macro, or a variable."), cons: doc("cons", function e41(t2, r) {
      return new Pair(t2, r);
    }, "(cons left right)\n\n        This function returns a new list with the first appended\n        before the second. If the second is not a list cons will\n        return a dotted pair."), car: doc("car", function e42(t2) {
      typecheck("car", t2, "pair");
      return t2.car;
    }, "(car pair)\n\n        This function returns the car (item 1) of the list."), cdr: doc("cdr", function e43(t2) {
      typecheck("cdr", t2, "pair");
      return t2.cdr;
    }, "(cdr pair)\n\n        This function returns the cdr (all but first) of the list."), "set!": doc(new Macro("set!", function(e75) {
      var a = this;
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = t2.use_dynamic, n = _objectWithoutProperties(t2, _excluded4);
      var i = this;
      var o = this;
      var u;
      var s = _objectSpread(_objectSpread({}, n), {}, { env: this, dynamic_env: i, use_dynamic: r });
      var c = _evaluate(e75.cdr.car, s);
      c = resolve_promises(c);
      function l(t3, r2, n2) {
        if (is_promise(t3)) {
          return t3.then(function(e76) {
            return l(t3, e76, n2);
          });
        }
        if (is_promise(r2)) {
          return r2.then(function(e76) {
            return l(t3, e76, n2);
          });
        }
        if (is_promise(n2)) {
          return n2.then(function(e76) {
            return l(t3, r2, e76);
          });
        }
        o.get("set-obj!").call(o, t3, r2, n2);
        return n2;
      }
      if (is_pair(e75.car) && LSymbol.is(e75.car.car, ".")) {
        var f = e75.car.cdr.car;
        var _ = e75.car.cdr.cdr.car;
        var p = _evaluate(f, s);
        var d = _evaluate(_, s);
        return l(p, d, c);
      }
      if (!(e75.car instanceof LSymbol)) {
        throw new Error("set! first argument need to be a symbol or dot accessor that evaluate to object.");
      }
      var h = e75.car.valueOf();
      u = this.ref(e75.car.__name__);
      return unpromise(c, function(e76) {
        if (!u) {
          var t3 = h.split(".");
          if (t3.length > 1) {
            var r2 = t3.pop();
            var n2 = t3.join(".");
            var i2 = a.get(n2, { throwError: false });
            if (i2) {
              l(i2, r2, e76);
              return;
            }
          }
          throw new Error("Unbound variable `" + h + "'");
        }
        u.set(h, e76);
      });
    }), "(set! name value)\n\n         Macro that can be used to set the value of the variable or slot (mutate it).\n         set! searches the scope chain until it finds first non empty slot and sets it."), "unset!": doc(new Macro("set!", function(e75) {
      if (!(e75.car instanceof LSymbol)) {
        throw new Error("unset! first argument need to be a symbol or dot accessor that evaluate to object.");
      }
      var t2 = e75.car;
      var r = this.ref(t2);
      if (r) {
        delete r.__env__[t2.__name__];
      }
    }), "(unset! name)\n\n         Function to delete the specified name from environment.\n         Trying to access the name afterwards will error."), "set-car!": doc("set-car!", function(e75, t2) {
      typecheck("set-car!", e75, "pair");
      e75.car = t2;
    }, "(set-car! obj value)\n\n         Function that sets the car (first item) of the list/pair to specified value.\n         The old value is lost."), "set-cdr!": doc("set-cdr!", function(e75, t2) {
      typecheck("set-cdr!", e75, "pair");
      e75.cdr = t2;
    }, "(set-cdr! obj value)\n\n         Function that sets the cdr (tail) of the list/pair to specified value.\n         It will destroy the list. The old tail is lost."), "empty?": doc("empty?", function(e75) {
      return typeof e75 === "undefined" || is_nil(e75);
    }, "(empty? object)\n\n         Function that returns #t if value is nil (an empty list) or undefined."), gensym: doc("gensym", gensym, "(gensym)\n\n         Generates a unique symbol that is not bound anywhere,\n         to use with macros as meta name."), load: doc("load", function e44(c, t2) {
      typecheck("load", c, "string");
      var l = this;
      if (l.__name__ === "__frame__") {
        l = l.__parent__;
      }
      if (!(t2 instanceof Environment)) {
        if (l === global_env) {
          t2 = l;
        } else {
          t2 = this.get("**interaction-environment**");
        }
      }
      var f = "@lips";
      var _ = c.startsWith(f);
      var p = "**module-path**";
      var d = global_env.get(p, { throwError: false });
      c = c.valueOf();
      if (!c.match(/.[^.]+$/)) {
        c += ".scm";
      }
      var r = c.match(/\.xcb$/);
      function h(e75) {
        if (r) {
          e75 = unserialize_bin(e75);
        } else {
          if (type(e75) === "buffer") {
            e75 = e75.toString();
          }
          e75 = e75.replace(/^(#!.*)/, function(e76, t3) {
            if (is_directive(t3)) {
              return t3;
            }
            return "";
          });
          if (e75.match(/^\{/)) {
            e75 = unserialize(e75);
          }
        }
        return exec(e75, { env: t2 });
      }
      function n(e75) {
        return root.fetch(e75).then(function(e76) {
          return r ? e76.arrayBuffer() : e76.text();
        }).then(function(e76) {
          if (r) {
            e76 = new Uint8Array(e76);
          }
          return e76;
        });
      }
      function m() {
        var e75 = global_env.get("__dirname");
        return e75.replace(/[^/]+$/, "");
      }
      if (is_node()) {
        return new Promise(function() {
          var r2 = _asyncToGenerator(_regeneratorRuntime.mark(function e75(r3, n2) {
            var i2, a2, o2, u2, s;
            return _regeneratorRuntime.wrap(function e76(t3) {
              while (1) switch (t3.prev = t3.next) {
                case 0:
                  t3.prev = 0;
                  t3.next = 3;
                  return node_ready;
                case 3:
                  i2 = nodeRequire("path");
                  a2 = nodeRequire("fs");
                  o2 = m();
                  if (_) {
                    c = c.replace(f, o2);
                  }
                  if (!d) {
                    t3.next = 12;
                    break;
                  }
                  d = d.valueOf();
                  if (!c.startsWith("/")) {
                    c = i2.join(d, c);
                  }
                  t3.next = 19;
                  break;
                case 12:
                  if (c.startsWith("/")) {
                    t3.next = 19;
                    break;
                  }
                  u2 = l.get("command-line", { throwError: false });
                  if (!u2) {
                    t3.next = 18;
                    break;
                  }
                  t3.next = 17;
                  return u2();
                case 17:
                  s = t3.sent;
                case 18:
                  if (s && !is_nil(s)) {
                    process.cwd();
                    c = i2.join(i2.dirname(s.car.valueOf()), c);
                  }
                case 19:
                  global_env.set(p, i2.dirname(c));
                  a2.readFile(c, function(e77, t4) {
                    if (e77) {
                      n2(e77);
                      global_env.set(p, d);
                    } else {
                      try {
                        h(t4).then(function() {
                          r3();
                          global_env.set(p, d);
                        })["catch"](n2);
                      } catch (e78) {
                        n2(e78);
                      }
                    }
                  });
                  t3.next = 26;
                  break;
                case 23:
                  t3.prev = 23;
                  t3.t0 = t3["catch"](0);
                  console.error(t3.t0);
                case 26:
                case "end":
                  return t3.stop();
              }
            }, e75, null, [[0, 23]]);
          }));
          return function(e75, t3) {
            return r2.apply(this, arguments);
          };
        }());
      }
      if (_) {
        var i, a;
        var o = (i = global_env.get("__dirname", { throwError: false })) !== null && i !== void 0 ? i : current_script;
        (a = o) !== null && a !== void 0 ? a : o = current_script;
        var u = o.replace(/dist\/?[^\/]*$/, "");
        c = c.replace(f, u);
      }
      if (d) {
        d = d.valueOf();
        if (!c.startsWith("/")) {
          c = d + "/" + c.replace(/^\.?\/?/, "");
        }
      }
      return n(c).then(function(e75) {
        global_env.set(p, c.replace(/\/[^/]*$/, ""));
        return h(e75);
      }).then(function() {
      })["finally"](function() {
        global_env.set(p, d);
      });
    }, "(load filename)\n        (load filename environment)\n\n        Fetches the file (from disk or network) and evaluates its content as LIPS code.\n        If the second argument is provided and it's an environment the evaluation\n        will happen in that environment."), while: doc(new Macro("while", function(e75, t2) {
      var r = e75.car;
      var n = _objectSpread(_objectSpread({}, t2), {}, { env: this });
      var i = new Pair(new LSymbol("begin"), e75.cdr);
      return function t3() {
        return unpromise(_evaluate(r, n), function(e76) {
          if (e76) {
            return unpromise(_evaluate(i, n), t3);
          }
        });
      }();
    }), "(while cond body)\n\n         Creates a loop, it executes cond and body until cond expression is false."), do: doc(new Macro("do", function() {
      var r = _asyncToGenerator(function(_, e75) {
        var p = this;
        var d = e75.use_dynamic, h = e75.error;
        return _regeneratorRuntime.mark(function e76() {
          var u, r2, s, c, n, l, f, i, a, o;
          return _regeneratorRuntime.wrap(function e77(t2) {
            while (1) switch (t2.prev = t2.next) {
              case 0:
                u = p;
                r2 = u;
                s = u.inherit("do");
                c = _.car;
                n = _.cdr.car;
                l = _.cdr.cdr;
                if (!is_nil(l)) {
                  l = new Pair(LSymbol("begin"), l);
                }
                f = { env: u, dynamic_env: r2, use_dynamic: d, error: h };
                i = c;
              case 9:
                if (is_nil(i)) {
                  t2.next = 20;
                  break;
                }
                a = i.car;
                t2.t0 = s;
                t2.t1 = a.car;
                t2.next = 15;
                return _evaluate(a.cdr.car, f);
              case 15:
                t2.t2 = t2.sent;
                t2.t0.set.call(t2.t0, t2.t1, t2.t2);
                i = i.cdr;
                t2.next = 9;
                break;
              case 20:
                f = { env: s, dynamic_env: r2, error: h };
                o = _regeneratorRuntime.mark(function e78() {
                  var r3, n2, i2, a2, o2;
                  return _regeneratorRuntime.wrap(function e79(t3) {
                    while (1) switch (t3.prev = t3.next) {
                      case 0:
                        if (is_nil(l)) {
                          t3.next = 3;
                          break;
                        }
                        t3.next = 3;
                        return lips.evaluate(l, f);
                      case 3:
                        r3 = c;
                        n2 = {};
                      case 5:
                        if (is_nil(r3)) {
                          t3.next = 15;
                          break;
                        }
                        i2 = r3.car;
                        if (is_nil(i2.cdr.cdr)) {
                          t3.next = 12;
                          break;
                        }
                        t3.next = 10;
                        return _evaluate(i2.cdr.cdr.car, f);
                      case 10:
                        a2 = t3.sent;
                        n2[i2.car.valueOf()] = a2;
                      case 12:
                        r3 = r3.cdr;
                        t3.next = 5;
                        break;
                      case 15:
                        o2 = Object.getOwnPropertySymbols(n2);
                        f.env = s = u.inherit("do");
                        Object.keys(n2).concat(o2).forEach(function(e80) {
                          s.set(e80, n2[e80]);
                        });
                      case 18:
                      case "end":
                        return t3.stop();
                    }
                  }, e78);
                });
              case 22:
                t2.next = 24;
                return _evaluate(n.car, f);
              case 24:
                t2.t3 = t2.sent;
                if (!(t2.t3 === false)) {
                  t2.next = 29;
                  break;
                }
                return t2.delegateYield(o(), "t4", 27);
              case 27:
                t2.next = 22;
                break;
              case 29:
                if (is_nil(n.cdr)) {
                  t2.next = 33;
                  break;
                }
                t2.next = 32;
                return _evaluate(n.cdr.car, f);
              case 32:
                return t2.abrupt("return", t2.sent);
              case 33:
              case "end":
                return t2.stop();
            }
          }, e76);
        })();
      });
      return function(e75, t2) {
        return r.apply(this, arguments);
      };
    }()), "(do ((<var> <init> <next>)) (test return) . body)\n\n         Iteration macro that evaluates the expression body in scope of the variables.\n         On each loop it changes the variables according to the <next> expression and runs\n         test to check if the loop should continue. If test is a single value, the macro\n         will return undefined. If the test is a pair of expressions the macro will\n         evaluate and return the second expression after the loop exits."), if: doc(new Macro("if", function(r, e75) {
      var t2 = e75.error, n = e75.use_dynamic;
      var i = this;
      var a = this;
      var o = { env: a, dynamic_env: i, use_dynamic: n, error: t2 };
      var u = function e76(t3) {
        if (is_false(t3)) {
          return _evaluate(r.cdr.cdr.car, o);
        } else {
          return _evaluate(r.cdr.car, o);
        }
      };
      if (is_nil(r)) {
        throw new Error("too few expressions for `if`");
      }
      var s = _evaluate(r.car, o);
      return unpromise(s, u);
    }), "(if cond true-expr false-expr)\n\n         Macro that evaluates cond expression and if the value is true, it\n         evaluates and returns true-expression, if not it evaluates and returns\n         false-expression."), "let-env": new Macro("let-env", function(t2) {
      var e75 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var r = e75.dynamic_env, n = e75.use_dynamic, i = e75.error;
      typecheck("let-env", t2, "pair");
      var a = _evaluate(t2.car, { env: this, dynamic_env: r, error: i, use_dynamic: n });
      return unpromise(a, function(e76) {
        typecheck("let-env", e76, "environment");
        return _evaluate(Pair(LSymbol("begin"), t2.cdr), { env: e76, dynamic_env: r, error: i });
      });
    }, "(let-env env . body)\n\n        Special macro that evaluates body in context of given environment\n        object."), letrec: doc(let_macro(Symbol["for"]("letrec")), "(letrec ((a value-a) (b value-b) ...) . body)\n\n         Macro that creates a new environment, then evaluates and assigns values to\n         names and then evaluates the body in context of that environment.\n         Values are evaluated sequentially and the next value can access the\n         previous values/names."), "letrec*": doc(let_macro(Symbol["for"]("letrec")), "(letrec* ((a value-a) (b value-b) ...) . body)\n\n         Same as letrec but the order of execution of the binding is guaranteed,\n         so you can use recursive code as well as referencing the previous binding.\n\n         In LIPS both letrec and letrec* behave the same."), "let*": doc(let_macro(Symbol["for"]("let*")), "(let* ((a value-a) (b value-b) ...) . body)\n\n         Macro similar to `let`, but the subsequent bindings after the first\n         are evaluated in the environment including the previous let variables,\n         so you can define one variable, and use it in the next's definition."), let: doc(let_macro(Symbol["for"]("let")), "(let ((a value-a) (b value-b) ...) . body)\n\n         Macro that creates a new environment, then evaluates and assigns values to names,\n         and then evaluates the body in context of that environment.  Values are evaluated\n         sequentially but you can't access previous values/names when the next are\n         evaluated. You can only get them in the body of the let expression.  (If you want\n         to define multiple variables and use them in each other's definitions, use\n         `let*`.)"), "begin*": doc(parallel("begin*", function(e75) {
      return e75.pop();
    }), "(begin* . body)\n\n         This macro is a parallel version of begin. It evaluates each expression\n         in the body and if it's a promise it will await it in parallel and return\n         the value of the last expression (i.e. it uses Promise.all())."), shuffle: doc("shuffle", function(e75) {
      typecheck("shuffle", e75, ["pair", "nil", "array"]);
      var t2 = global_env.get("random");
      if (is_nil(e75)) {
        return _nil;
      }
      if (Array.isArray(e75)) {
        return shuffle(e75.slice(), t2);
      }
      var r = global_env.get("list->array")(e75);
      r = shuffle(r, t2);
      return global_env.get("array->list")(r);
    }, "(shuffle obj)\n\n        Order items in vector or list in random order."), begin: doc(new Macro("begin", function(e75, t2) {
      var n = _objectSpread(_objectSpread({}, t2), {}, { env: this });
      var i = global_env.get("list->array")(e75);
      var a;
      return function t3() {
        if (i.length) {
          var e76 = i.shift();
          var r = _evaluate(e76, n);
          return unpromise(r, function(e77) {
            a = e77;
            return t3();
          });
        } else {
          return a;
        }
      }();
    }), "(begin . args)\n\n         Macro that runs a list of expressions in order and returns the value\n         of the last one. It can be used in places where you can only have a\n         single expression, like (if)."), ignore: new Macro("ignore", function(e75, t2) {
      var r = _objectSpread(_objectSpread({}, t2), {}, { env: this, dynamic_env: this });
      _evaluate(new Pair(new LSymbol("begin"), e75), r);
    }, "(ignore . body)\n\n        Macro that will evaluate the expression and swallow any promises that may\n        be created. It will discard any value that may be returned by the last body\n        expression. The code should have side effects and/or when it's promise\n        it should resolve to undefined."), "call/cc": doc(Macro.defmacro("call/cc", function(e75) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var r = _objectSpread({ env: this }, t2);
      return unpromise(_evaluate(e75.car, r), function(e76) {
        if (is_function(e76)) {
          return e76(new Continuation(null));
        }
      });
    }), "(call/cc proc)\n\n         Call-with-current-continuation.\n\n         NOT SUPPORTED BY LIPS RIGHT NOW"), parameterize: doc(new Macro("parameterize", function(t2, e75) {
      var i = e75.dynamic_env;
      var a = i.inherit("parameterize").new_frame(null, {});
      var o = _objectSpread(_objectSpread({}, e75), {}, { env: this });
      var u = t2.car;
      if (!is_pair(u)) {
        var r = type(u);
        throw new Error("Invalid syntax for parameterize expecting pair got ".concat(r));
      }
      function s() {
        var e76 = new Pair(new LSymbol("begin"), t2.cdr);
        return _evaluate(e76, _objectSpread(_objectSpread({}, o), {}, { dynamic_env: a }));
      }
      return function r2() {
        var e76 = u.car;
        var n = e76.car.valueOf();
        return unpromise(_evaluate(e76.cdr.car, o), function(e77) {
          var t3 = i.get(n, { throwError: false });
          if (!is_parameter(t3)) {
            throw new Error("Unknown parameter ".concat(n));
          }
          a.set(n, t3.inherit(e77));
          if (!is_null(u.cdr)) {
            u = u.cdr;
            return r2();
          } else {
            return s();
          }
        });
      }();
    }), "(parameterize ((name value) ...)\n\n         Macro that change the dynamic variable created by make-parameter."), "make-parameter": doc(new Macro("make-parameter", function(e75, t2) {
      t2.dynamic_env;
      var r = _evaluate(e75.car, t2);
      var n;
      if (is_pair(e75.cdr.car)) {
        n = _evaluate(e75.cdr.car, t2);
      }
      return new Parameter(r, n);
    }), "(make-parameter init converter)\n\n    Function creates new dynamic variable that can be custimized with parameterize\n    macro. The value should be assigned to a variable e.g.:\n\n    (define radix (make-parameter 10))\n\n    The result value is a procedure that return the value of dynamic variable."), "define-syntax-parameter": doc(new Macro("define-syntax-parameter", function(e75, t2) {
      var r = e75.car;
      var n = this;
      if (!(r instanceof LSymbol)) {
        throw new Error("define-syntax-parameter: invalid syntax expecting symbol got ".concat(type(r)));
      }
      var i = _evaluate(e75.cdr.car, _objectSpread({ env: n }, t2));
      typecheck("define-syntax-parameter", i, "syntax", 2);
      i.__name__ = r.valueOf();
      if (i.__name__ instanceof LString) {
        i.__name__ = i.__name__.valueOf();
      }
      var a;
      if (is_pair(e75.cdr.cdr) && LString.isString(e75.cdr.cdr.car)) {
        a = e75.cdr.cdr.car.valueOf();
      }
      n.set(e75.car, new SyntaxParameter(i), a, true);
    }), "(define-syntax-parameter name syntax [__doc__])\n\n         Binds <keyword> to the transformer obtained by evaluating <transformer spec>.\n         The transformer provides the default expansion for the syntax parameter,\n         and in the absence of syntax-parameterize, is functionally equivalent to\n         define-syntax."), "syntax-parameterize": doc(new Macro("syntax-parameterize", function(e75, t2) {
      var r = global_env.get("list->array")(e75.car);
      var n = this.inherit("syntax-parameterize");
      while (r.length) {
        var i = r.shift();
        if (!(is_pair(i) || i.car instanceof LSymbol)) {
          var a = "invalid syntax for syntax-parameterize: ".concat(repr(e75, true));
          throw new Error("syntax-parameterize: ".concat(a));
        }
        var o = _evaluate(i.cdr.car, _objectSpread(_objectSpread({}, t2), {}, { env: this }));
        var u = i.car;
        typecheck("syntax-parameterize", o, ["syntax"]);
        typecheck("syntax-parameterize", u, "symbol");
        o.__name__ = u.valueOf();
        if (o.__name__ instanceof LString) {
          o.__name__ = o.__name__.valueOf();
        }
        var s = new SyntaxParameter(o);
        if (u.is_gensym()) {
          var c = u.literal();
          var l = this.get(c, { throwError: false });
          if (l instanceof SyntaxParameter) {
            n.set(c, s);
          }
        }
        n.set(u, s);
      }
      var f = hygienic_begin([n, t2.dynamic_env], e75.cdr);
      return _evaluate(f, _objectSpread(_objectSpread({}, t2), {}, { env: n }));
    }), "(syntax-parameterize (bindings) body)\n\n         Macro work similar to let-syntax but the the bindnds will be exposed to the user.\n         With syntax-parameterize you can define anaphoric macros."), define: doc(Macro.defmacro("define", function(r, e75) {
      var n = this;
      if (is_pair(r.car) && r.car.car instanceof LSymbol) {
        var t2 = new Pair(new LSymbol("define"), new Pair(r.car.car, new Pair(new Pair(new LSymbol("lambda"), new Pair(r.car.cdr, r.cdr)))));
        return t2;
      } else if (e75.macro_expand) {
        return;
      }
      e75.dynamic_env = this;
      e75.env = n;
      var i = r.cdr.car;
      var a;
      if (is_pair(i)) {
        i = _evaluate(i, e75);
        a = true;
      } else if (i instanceof LSymbol) {
        i = n.get(i);
      }
      typecheck("define", r.car, "symbol");
      return unpromise(i, function(e76) {
        if (n.__name__ === Syntax.__merge_env__) {
          n = n.__parent__;
        }
        if (a && (is_function(e76) && is_lambda(e76) || e76 instanceof Syntax || is_parameter(e76))) {
          e76.__name__ = r.car.valueOf();
          if (e76.__name__ instanceof LString) {
            e76.__name__ = e76.__name__.valueOf();
          }
        }
        var t3;
        if (is_pair(r.cdr.cdr) && LString.isString(r.cdr.cdr.car)) {
          t3 = r.cdr.cdr.car.valueOf();
        }
        n.set(r.car, e76, t3, true);
      });
    }), '(define name expression)\n         (define name expression "doc string")\n         (define (function-name . args) . body)\n\n         Macro for defining values. It can be used to define variables,\n         or functions. If the first argument is list it will create a function\n         with name being first element of the list. This form expands to\n         `(define function-name (lambda args body))`'), "set-obj!": doc("set-obj!", function(e75, t2, r) {
      var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      var i = _typeof$1(e75);
      if (is_null(e75) || i !== "object" && i !== "function") {
        var a = typeErrorMessage("set-obj!", type(e75), ["object", "function"]);
        throw new Error(a);
      }
      typecheck("set-obj!", t2, ["string", "symbol", "number"]);
      e75 = unbind(e75);
      t2 = t2.valueOf();
      if (arguments.length === 2) {
        delete e75[t2];
      } else if (is_prototype(e75) && is_function(r)) {
        e75[t2] = unbind(r);
        e75[t2][__prototype__] = true;
      } else if (is_function(r) || is_native(r) || is_nil(r)) {
        e75[t2] = r;
      } else {
        e75[t2] = r && !is_prototype(r) ? r.valueOf() : r;
      }
      if (props) {
        var o = e75[t2];
        Object.defineProperty(e75, t2, _objectSpread(_objectSpread({}, n), {}, { value: o }));
      }
    }, "(set-obj! obj key value)\n        (set-obj! obj key value props)\n\n        Function set a property of a JavaScript object. props should be a vector of pairs,\n        passed to Object.defineProperty."), "null-environment": doc("null-environment", function() {
      return global_env.inherit("null");
    }, "(null-environment)\n\n        Returns a clean environment with only the standard library."), values: doc("values", function e45() {
      for (var t2 = arguments.length, r = new Array(t2), n = 0; n < t2; n++) {
        r[n] = arguments[n];
      }
      return Values(r);
    }, "(values a1 a2 ...)\n\n        If called with more then one element it will create a special\n        Values object that can be used in the call-with-values function."), "call-with-values": doc("call-with-values", function(e75, t2) {
      typecheck("call-with-values", e75, "function", 1);
      typecheck("call-with-values", t2, "function", 2);
      var r = e75.apply(this);
      if (r instanceof Values) {
        return t2.apply(this, r.valueOf());
      }
      return t2.call(this, r);
    }, "(call-with-values producer consumer)\n\n        Calls the producer procedure with no arguments, then calls the\n        consumer procedure with the returned value as an argument -- unless\n        the returned value is a special Values object created by (values), if it is\n        the values are unpacked and the consumer is called with multiple arguments."), "current-environment": doc("current-environment", function() {
      if (this.__name__ === "__frame__") {
        return this.__parent__;
      }
      return this;
    }, "(current-environment)\n\n        Function that returns the current environment (they're first-class objects!)"), "parent.frame": doc("parent.frame", function() {
      return user_env;
    }, "(parent.frame)\n\n        Returns the parent environment if called from inside a function.\n        If no parent frame can be found it returns nil."), eval: doc("eval", function(n, i) {
      i = i || this.get("interaction-environment").call(this);
      return new Promise(function(e75, t2) {
        var r = _evaluate(n, { env: i, dynamic_env: i, error: t2 });
        e75(r);
      });
    }, "(eval expr)\n        (eval expr environment)\n\n        Function that evaluates LIPS Scheme code. If the second argument is provided\n        it will be the environment that the code is evaluated in."), lambda: new Macro("lambda", function(m) {
      var e75 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, y = e75.use_dynamic, v = e75.error;
      var b = this;
      var g;
      if (is_pair(m.cdr) && LString.isString(m.cdr.car) && !is_nil(m.cdr.cdr)) {
        g = m.cdr.car.valueOf();
      }
      function w() {
        var e76 = is_context(this) ? this : { dynamic_env: b }, r = e76.dynamic_env;
        var n = b.inherit("lambda");
        r = r.inherit("lambda");
        if (this && !is_context(this)) {
          if (this && !this.__instance__) {
            Object.defineProperty(this, "__instance__", { enumerable: false, get: function e77() {
              return true;
            }, set: function e77() {
            }, configurable: false });
          }
          n.set("this", this);
        }
        for (var t3 = arguments.length, i = new Array(t3), a = 0; a < t3; a++) {
          i[a] = arguments[a];
        }
        if (this instanceof LambdaContext) {
          var o = { throwError: false };
          n.set("arguments", this.env.get("arguments", o));
          n.set("parent.frame", this.env.get("parent.frame", o));
        } else {
          var u = i.slice();
          u.callee = w;
          u.env = n;
          n.set("arguments", u);
        }
        function s(e77, t4) {
          n.__env__[e77.__name__] = t4;
          r.__env__[e77.__name__] = t4;
        }
        var c = m.car;
        var l = 0;
        if (c instanceof LSymbol || !is_nil(c)) {
          while (true) {
            if (!is_nil(c.car)) {
              if (c instanceof LSymbol) {
                var f = quote(Pair.fromArray(i.slice(l), false));
                s(c, f);
                break;
              } else if (is_pair(c)) {
                var _ = i[l];
                s(c.car, _);
              }
            }
            if (is_nil(c.cdr)) {
              break;
            }
            l++;
            c = c.cdr;
          }
        }
        var p = g ? m.cdr.cdr : m.cdr;
        var d = hygienic_begin([n, r], p);
        var h = { env: n, dynamic_env: r, use_dynamic: y, error: v };
        return _evaluate(d, h);
      }
      var t2 = is_pair(m.car) ? m.car.length() : null;
      w.__code__ = new Pair(new LSymbol("lambda"), m);
      w[__lambda__] = true;
      if (!is_pair(m.car)) {
        return doc(w, g, true);
      }
      return doc(set_fn_length(w, t2), g, true);
    }, "(lambda (a b) body)\n        (lambda args body)\n        (lambda (a b . rest) body)\n\n        The lambda macro creates a new anonymous function. If the first element of\n        the body is a string and there is more elements the string is used as the\n        documentation string, that can be read using (help fn)."), macroexpand: doc(new Macro("macroexpand", macro_expand()), "(macroexpand expr)\n\n         Macro that expand all macros inside and return single expression as output."), "macroexpand-1": doc(new Macro("macroexpand-1", macro_expand(true)), "(macroexpand-1 expr)\n\n         Macro similar to macroexpand but it expand macros only one level\n         and return single expression as output."), "define-macro": doc(new Macro(macro, function(e75, t2) {
      var r = t2.use_dynamic, n = t2.error;
      var i, a, o, u;
      if (is_named_macro(e75)) {
        i = e75.car.car.__name__;
        o = e75.cdr;
        u = e75.car.cdr;
      }
      if (is_lambda_macro(e75)) {
        i = e75.car.__name__;
        var s = e75.cdr.car;
        u = s.cdr.car;
        o = s.cdr.cdr;
      }
      if (i && o && u) {
        if (LString.isString(o.car) && is_pair(o.cdr)) {
          a = o.car.valueOf();
          o = o.cdr;
        }
        var c = define_macro(i, u, o, a, { use_dynamic: r, error: n });
        this.set(i, c);
      } else {
        throw new Error("Syntax Error: Invalid `define-macro` expression");
      }
    }), "(define-macro (name . args) body)\n\n         The meta-macro, that creates new macros. If the return value is a list structure\n         it will be evaluated where the macro is invoked from. You can use quasiquote `\n         and unquote , and unquote-splicing ,@ inside to create an expression that will be\n         evaluated at runtime. Macros works like this: if you pass any expression to a\n         macro the arguments will not be evaluated unless the macro's body explicitly\n         calls (eval) on it. Because of this a macro can manipulate the expression\n         (arguments) as lists."), "syntax-rules": new Macro("syntax-rules", function(b, e75) {
      var g = e75.use_dynamic, w = e75.error;
      var D = this;
      function x(e76) {
        var t3 = [];
        while (!is_nil(e76)) {
          var r2 = e76.car;
          t3.push(r2.valueOf());
          e76 = e76.cdr;
        }
        return t3;
      }
      function t2(e76) {
        while (!is_nil(e76)) {
          var t3 = e76.car;
          if (!(t3 instanceof LSymbol)) {
            throw new Error("syntax-rules: wrong identifier");
          }
          e76 = e76.cdr;
        }
      }
      if (b.car instanceof LSymbol) {
        t2(b.cdr.car);
      } else {
        t2(b.car);
      }
      var r = new Syntax(function(e76, t3) {
        var r2 = t3.macro_expand;
        log(">> SYNTAX");
        log(e76);
        log(b);
        var n = D.inherit("syntax");
        var i = n;
        var a = this;
        if (a.__name__ === Syntax.__merge_env__) {
          var o = Object.getOwnPropertySymbols(a.__env__);
          o.forEach(function(e77) {
            a.__parent__.set(e77, a.__env__[e77]);
          });
          a = a.__parent__;
        }
        var u = { env: n, dynamic_env: i, use_dynamic: g, error: w };
        var s, c, l;
        if (b.car instanceof LSymbol) {
          s = b.car;
          l = x(b.cdr.car);
          c = b.cdr.cdr;
        } else {
          s = "...";
          l = x(b.car);
          c = b.cdr;
        }
        try {
          while (!is_nil(c)) {
            var f = c.car.car;
            var _ = c.car.cdr.car;
            log("[[[ RULE");
            log(f);
            var p = extract_patterns(f, e76, l, s, { expansion: this, define: D });
            if (p) {
              if (is_debug()) {
                console.log(JSON.stringify(symbolize(p), true, 2));
                console.log("PATTERN: " + f.toString(true));
                console.log("MACRO: " + e76.toString(true));
              }
              var d = [];
              var h = transform_syntax({ bindings: p, expr: _, symbols: l, scope: n, lex_scope: a, names: d, ellipsis: s });
              log("OUPUT>>> ", h);
              if (h) {
                _ = h;
              }
              var m = a.merge(n, Syntax.__merge_env__);
              if (r2) {
                return { expr: _, scope: m };
              }
              var y = _evaluate(_, _objectSpread(_objectSpread({}, u), {}, { env: m }));
              return clear_gensyms(y, d);
            }
            c = c.cdr;
          }
        } catch (e77) {
          var v = "\nin macro:\n  ".concat(b.toString(true));
          if (!e77.message.includes(v)) {
            e77.message += v;
          }
          throw e77;
        }
        throw new Error("syntax-rules: no matching syntax in macro ".concat(e76.toString(true)));
      }, D);
      r.__code__ = b;
      return r;
    }, "(syntax-rules () (pattern expression) ...)\n\n        Base of hygienic macros, it will return a new syntax expander\n        that works like Lisp macros."), quote: doc(new Macro("quote", function(e75) {
      return quote(e75.car);
    }), "(quote expression) or 'expression\n\n         Macro that returns a single LIPS expression as data (it won't evaluate the\n         argument). It will return a list if put in front of LIPS code.\n         And if put in front of a symbol it will return the symbol itself, not the value\n         bound to that name."), "unquote-splicing": doc("unquote-splicing", function() {
      throw new Error("You can't call `unquote-splicing` outside of quasiquote");
    }, "(unquote-splicing code) or ,@code\n\n        Special form used in the quasiquote macro. It evaluates the expression inside and\n        splices the list into quasiquote's result. If it is not the last element of the\n        expression, the computed value must be a pair."), unquote: doc("unquote", function() {
      throw new Error("You can't call `unquote` outside of quasiquote");
    }, "(unquote code) or ,code\n\n        Special form used in the quasiquote macro. It evaluates the expression inside and\n        substitutes the value into quasiquote's result."), quasiquote: Macro.defmacro("quasiquote", function(e75, t2) {
      var u = t2.use_dynamic, s = t2.error;
      var c = this;
      var l = c;
      function a(e76) {
        return is_pair(e76) || is_plain_object(e76) || Array.isArray(e76);
      }
      function f(e76, t3) {
        var r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : a;
        if (is_pair(e76)) {
          var n2 = e76.car;
          var i2 = e76.cdr;
          if (r2(n2)) {
            n2 = t3(n2);
          }
          if (r2(i2)) {
            i2 = t3(i2);
          }
          if (is_promise(n2) || is_promise(i2)) {
            return promise_all([n2, i2]).then(function(e77) {
              var t4 = _slicedToArray(e77, 2), r3 = t4[0], n3 = t4[1];
              return new Pair(r3, n3);
            });
          } else {
            return new Pair(n2, i2);
          }
        }
        return e76;
      }
      function o(e76, t3) {
        if (is_pair(e76)) {
          if (!is_nil(t3)) {
            e76.append(t3);
          }
        } else {
          e76 = new Pair(e76, t3);
        }
        return e76;
      }
      function r(e76) {
        return !!e76.filter(function(e77) {
          return is_pair(e77) && LSymbol.is(e77.car, /^(unquote|unquote-splicing)$/);
        }).length;
      }
      function _(e76, n2, i2) {
        return e76.reduce(function(e77, t3) {
          if (!is_pair(t3)) {
            e77.push(t3);
            return e77;
          }
          if (LSymbol.is(t3.car, "unquote-splicing")) {
            var r2;
            if (n2 + 1 < i2) {
              r2 = m(t3.cdr, n2 + 1, i2);
            } else {
              r2 = _evaluate(t3.cdr.car, { env: c, use_dynamic: u, dynamic_env: l, error: s });
            }
            if (!is_pair(r2)) {
              throw new Error("Expecting list ".concat(type(t3), " found"));
            }
            return e77.concat(r2.to_array());
          }
          e77.push(m(t3, n2, i2));
          return e77;
        }, []);
      }
      function p(n2, i2, a2) {
        var o2 = {};
        i2++;
        Object.keys(n2).forEach(function(e76) {
          var t3 = n2[e76];
          if (is_pair(t3)) {
            if (LSymbol.is(t3.car, "unquote-splicing")) {
              throw new Error("You can't call `unquote-splicing` inside object");
            }
            var r2;
            if (i2 < a2) {
              r2 = m(t3.cdr.car, i2, a2);
            } else {
              r2 = _evaluate(t3.cdr.car, { env: c, dynamic_env: l, use_dynamic: u, error: s });
            }
            o2[e76] = r2;
          } else {
            o2[e76] = t3;
          }
        });
        if (Object.isFrozen(n2)) {
          Object.freeze(o2);
        }
        return o2;
      }
      function d(i2, e76, t3) {
        if (e76 < t3) {
          var r2 = _nil;
          if (!is_nil(i2.cdr)) {
            r2 = m(i2.cdr, e76 - 1, t3);
          }
          return new Pair(new Pair(i2.car.car, m(i2.car.cdr, e76, t3)), r2);
        }
        var n2 = [];
        return function e77(t4) {
          var r3 = _evaluate(t4.car, { env: c, dynamic_env: l, use_dynamic: u, error: s });
          n2.push(r3);
          if (is_pair(t4.cdr)) {
            return e77(t4.cdr);
          }
          return unpromise(n2, function(r4) {
            if (r4.some(function(e79) {
              return !is_pair(e79);
            })) {
              if (is_pair(i2.cdr) && LSymbol.is(i2.cdr.car, ".") && is_pair(i2.cdr.cdr) && is_nil(i2.cdr.cdr.cdr)) {
                return i2.cdr.cdr.car;
              }
              if (!(is_nil(i2.cdr) || is_pair(i2.cdr))) {
                var e78 = "You can't splice atom inside list";
                throw new Error(e78);
              }
              if (r4.length > 1) {
                var t5 = "You can't splice multiple atoms inside list";
                throw new Error(t5);
              }
              if (!(is_pair(i2.cdr) && is_nil(r4[0]))) {
                return r4[0];
              }
            }
            r4 = r4.map(function(e79) {
              if (h.has(e79)) {
                return e79.clone();
              } else {
                h.add(e79);
                return e79;
              }
            });
            var n3 = m(i2.cdr, 0, 1);
            if (is_nil(n3) && is_nil(r4[0])) {
              return void 0;
            }
            return unpromise(n3, function(e79) {
              if (is_nil(r4[0])) {
                return e79;
              }
              if (r4.length === 1) {
                return o(r4[0], e79);
              }
              var t6 = r4.reduce(function(e80, t7) {
                return o(e80, t7);
              });
              return o(t6, e79);
            });
          });
        }(i2.car.cdr);
      }
      var h = /* @__PURE__ */ new Set();
      function m(e76, t3, r2) {
        if (is_pair(e76)) {
          if (is_pair(e76.car)) {
            if (LSymbol.is(e76.car.car, "unquote-splicing")) {
              return d(e76, t3 + 1, r2);
            }
            if (LSymbol.is(e76.car.car, "unquote")) {
              if (t3 + 2 === r2 && is_pair(e76.car.cdr) && is_pair(e76.car.cdr.car) && LSymbol.is(e76.car.cdr.car.car, "unquote-splicing")) {
                var n2 = e76.car.cdr;
                return new Pair(new Pair(new LSymbol("unquote"), d(n2, t3 + 2, r2)), _nil);
              } else if (is_pair(e76.car.cdr) && !is_nil(e76.car.cdr.cdr)) {
                if (is_pair(e76.car.cdr.car)) {
                  var i2 = [];
                  return function t4(r3) {
                    if (is_nil(r3)) {
                      return Pair.fromArray(i2);
                    }
                    return unpromise(_evaluate(r3.car, { env: c, dynamic_env: l, use_dynamic: u, error: s }), function(e77) {
                      i2.push(e77);
                      return t4(r3.cdr);
                    });
                  }(e76.car.cdr);
                } else {
                  return e76.car.cdr;
                }
              }
            }
          }
          if (LSymbol.is(e76.car, "quasiquote")) {
            var a2 = m(e76.cdr, t3, r2 + 1);
            return new Pair(e76.car, a2);
          }
          if (LSymbol.is(e76.car, "quote")) {
            return new Pair(e76.car, m(e76.cdr, t3, r2));
          }
          if (LSymbol.is(e76.car, "unquote")) {
            t3++;
            if (t3 < r2) {
              return new Pair(new LSymbol("unquote"), m(e76.cdr, t3, r2));
            }
            if (t3 > r2) {
              throw new Error("You can't call `unquote` outside of quasiquote");
            }
            if (is_pair(e76.cdr)) {
              if (!is_nil(e76.cdr.cdr)) {
                if (is_pair(e76.cdr.car)) {
                  var o2 = [];
                  return function t4(r3) {
                    if (is_nil(r3)) {
                      return Pair.fromArray(o2);
                    }
                    return unpromise(_evaluate(r3.car, { env: c, dynamic_env: l, use_dynamic: u, error: s }), function(e77) {
                      o2.push(e77);
                      return t4(r3.cdr);
                    });
                  }(e76.cdr);
                } else {
                  return e76.cdr;
                }
              } else {
                return _evaluate(e76.cdr.car, { env: c, dynamic_env: l, error: s });
              }
            } else {
              return e76.cdr;
            }
          }
          return f(e76, function(e77) {
            return m(e77, t3, r2);
          });
        } else if (is_plain_object(e76)) {
          return p(e76, t3, r2);
        } else if (e76 instanceof Array) {
          return _(e76, t3, r2);
        }
        return e76;
      }
      function n(e76) {
        if (is_pair(e76)) {
          delete e76[__data__];
          if (!e76.have_cycles("car")) {
            n(e76.car);
          }
          if (!e76.have_cycles("cdr")) {
            n(e76.cdr);
          }
        }
      }
      if (is_plain_object(e75.car) && !r(Object.values(e75.car))) {
        return quote(e75.car);
      }
      if (Array.isArray(e75.car) && !r(e75.car)) {
        return quote(e75.car);
      }
      if (is_pair(e75.car) && !e75.car.find("unquote") && !e75.car.find("unquote-splicing") && !e75.car.find("quasiquote")) {
        return quote(e75.car);
      }
      var i = m(e75.car, 0, 1);
      return unpromise(i, function(e76) {
        n(e76);
        return quote(e76);
      });
    }, "(quasiquote list)\n\n        Similar macro to `quote` but inside it you can use special expressions (unquote\n        x) abbreviated to ,x that will evaluate x and insert its value verbatim or\n        (unquote-splicing x) abbreviated to ,@x that will evaluate x and splice the value\n        into the result. Best used with macros but it can be used outside."), clone: doc("clone", function e46(t2) {
      typecheck("clone", t2, "pair");
      return t2.clone();
    }, "(clone list)\n\n        Function that returns a clone of the list, that does not share any pairs with the\n        original, so the clone can be safely mutated without affecting the original."), append: doc("append", function e47() {
      var t2;
      for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) {
        n[i] = arguments[i];
      }
      n = n.map(function(e75) {
        if (is_pair(e75)) {
          return e75.clone();
        }
        return e75;
      });
      return (t2 = global_env.get("append!")).call.apply(t2, [this].concat(_toConsumableArray(n)));
    }, "(append item ...)\n\n        Function that creates a new list with each argument appended end-to-end.\n        It will always return a new list and not modify its arguments."), "append!": doc("append!", function() {
      var r = global_env.get("list?");
      for (var e75 = arguments.length, t2 = new Array(e75), n = 0; n < e75; n++) {
        t2[n] = arguments[n];
      }
      return t2.reduce(function(e76, t3) {
        typecheck("append!", e76, ["nil", "pair"]);
        if ((is_pair(t3) || is_nil(t3)) && !r(t3)) {
          throw new Error("append!: Invalid argument, value is not a list");
        }
        if (is_nil(e76)) {
          if (is_nil(t3)) {
            return _nil;
          }
          return t3;
        }
        if (is_null(t3)) {
          return e76;
        }
        return e76.append(t3);
      }, _nil);
    }, "(append! arg1 ...)\n\n        Destructive version of append, it can modify the lists in place. It returns\n        a new list where each argument is appended to the end. It may modify\n        lists added as arguments."), reverse: doc("reverse", function e48(t2) {
      typecheck("reverse", t2, ["array", "pair", "nil"]);
      if (is_nil(t2)) {
        return _nil;
      }
      if (is_pair(t2)) {
        var r = global_env.get("list->array")(t2).reverse();
        return global_env.get("array->list")(r);
      } else if (Array.isArray(t2)) {
        return t2.reverse();
      } else {
        throw new Error(typeErrorMessage("reverse", type(t2), "array or pair"));
      }
    }, "(reverse list)\n\n        Function that reverses the list or array. If value is not a list\n        or array it will error."), nth: doc("nth", function e49(t2, r) {
      typecheck("nth", t2, "number");
      typecheck("nth", r, ["array", "pair"]);
      if (is_pair(r)) {
        var n = r;
        var i = 0;
        while (i < t2) {
          if (!n.cdr || is_nil(n.cdr) || n.have_cycles("cdr")) {
            return _nil;
          }
          n = n.cdr;
          i++;
        }
        return n.car;
      } else if (r instanceof Array) {
        return r[t2];
      } else {
        throw new Error(typeErrorMessage("nth", type(r), "array or pair", 2));
      }
    }, "(nth index obj)\n\n        Function that returns the nth element of the list or array.\n        If used with a non-indexable value it will error."), list: doc("list", function e50() {
      for (var t2 = arguments.length, r = new Array(t2), n = 0; n < t2; n++) {
        r[n] = arguments[n];
      }
      return r.reverse().reduce(function(e75, t3) {
        return new Pair(t3, e75);
      }, _nil);
    }, "(list . args)\n\n        Function that creates a new list out of its arguments."), substring: doc("substring", function e51(t2, r, n) {
      typecheck("substring", t2, "string");
      typecheck("substring", r, "number");
      typecheck("substring", n, ["number", "void"]);
      return t2.substring(r.valueOf(), n && n.valueOf());
    }, "(substring string start end)\n\n        Function that returns the slice of the string starting at start and ending\n        with end."), concat: doc("concat", function e52() {
      for (var t2 = arguments.length, r = new Array(t2), n = 0; n < t2; n++) {
        r[n] = arguments[n];
      }
      r.forEach(function(e75, t3) {
        return typecheck("concat", e75, "string", t3 + 1);
      });
      return r.join("");
    }, "(concat . strings)\n\n        Function that creates a new string by joining its arguments."), join: doc("join", function e53(t2, r) {
      typecheck("join", t2, "string");
      typecheck("join", r, ["pair", "nil"]);
      return global_env.get("list->array")(r).join(t2);
    }, "(join separator list)\n\n        Function that returns a string by joining elements of the list using separator."), split: doc("split", function e54(t2, r) {
      typecheck("split", t2, ["regex", "string"]);
      typecheck("split", r, "string");
      return global_env.get("array->list")(r.split(t2));
    }, "(split separator string)\n\n        Function that creates a list by splitting string by separator which can\n        be a string or regular expression."), replace: doc("replace", function e55(t2, r, n) {
      typecheck("replace", t2, ["regex", "string"]);
      typecheck("replace", r, ["string", "function"]);
      typecheck("replace", n, "string");
      if (is_function(r)) {
        var i = [];
        n.replace(t2, function() {
          i.push(r.apply(void 0, arguments));
        });
        return unpromise(i, function(e75) {
          return n.replace(t2, function() {
            return e75.shift();
          });
        });
      }
      return n.replace(t2, r);
    }, "(replace pattern replacement string)\n\n        Function that changes pattern to replacement inside string. Pattern can be a\n        string or regex and replacement can be function or string. See Javascript\n        String.replace()."), match: doc("match", function e56(t2, r) {
      typecheck("match", t2, ["regex", "string"]);
      typecheck("match", r, "string");
      var n = r.match(t2);
      return n ? global_env.get("array->list")(n) : false;
    }, "(match pattern string)\n\n        Function that returns a match object from JavaScript as a list or #f if\n        no match."), search: doc("search", function e57(t2, r) {
      typecheck("search", t2, ["regex", "string"]);
      typecheck("search", r, "string");
      return r.search(t2);
    }, "(search pattern string)\n\n        Function that returns the first found index of the pattern inside a string."), repr: doc("repr", function e58(t2, r) {
      return to_string(t2, r);
    }, "(repr obj)\n\n        Function that returns a LIPS code representation of the object as a string."), "escape-regex": doc("escape-regex", function(e75) {
      typecheck("escape-regex", e75, "string");
      return escape_regex(e75.valueOf());
    }, "(escape-regex string)\n\n        Function that returns a new string where all special operators used in regex,\n        are escaped with backslashes so they can be used in the RegExp constructor\n        to match a literal string."), env: doc("env", function e59(e59) {
      e59 = e59 || this.env;
      var t2 = Object.keys(e59.__env__).map(LSymbol);
      var r;
      if (t2.length) {
        r = Pair.fromArray(t2);
      } else {
        r = _nil;
      }
      if (e59.__parent__ instanceof Environment) {
        return global_env.get("env").call(this, e59.__parent__).append(r);
      }
      return r;
    }, "(env)\n        (env obj)\n\n        Function that returns a list of names (functions, macros and variables)\n        that are bound in the current environment or one of its parents."), new: doc("new", function(e75) {
      var t2 = unbind(e75);
      var r;
      for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) {
        i[a - 1] = arguments[a];
      }
      if (t2[Symbol["for"]("__class__")]) {
        r = _construct(t2, i);
      } else {
        r = _construct(t2, _toConsumableArray(i.map(function(e76) {
          return unbox(e76);
        })));
      }
      return r;
    }, "(new obj . args)\n\n        Function that creates new JavaScript instance of an object."), typecheck: doc(typecheck, "(typecheck label value type [position])\n\n         Checks the type of value and errors if the type is not one allowed.  Type can be\n         string or list of strings. The position optional argument is used to create a\n         proper error message for the nth argument of function calls."), "typecheck-number": doc(typecheck_number, "(typecheck-number label value type [position])\n\n         Function similar to typecheck but checks if the argument is a number\n         and specific type of number e.g. complex."), "unset-special!": doc("unset-special!", function(e75) {
      typecheck("remove-special!", e75, "string");
      delete specials.remove(e75.valueOf());
    }, "(unset-special! name)\n\n        Function that removes a special symbol from parser added by `set-special!`,\n        name must be a string."), "set-special!": doc("set-special!", function(e75, t2) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : specials.LITERAL;
      typecheck("set-special!", e75, "string", 1);
      typecheck("set-special!", t2, "symbol", 2);
      specials.append(e75.valueOf(), t2, r);
    }, '(set-special! symbol name [type])\n\n        Add a special symbol to the list of transforming operators by the parser.\n        e.g.: `(add-special! "#" \'x)` will allow to use `#(1 2 3)` and it will be\n        transformed into (x (1 2 3)) so you can write x macro that will process\n        the list. 3rd argument is optional, and it can be one of two values:\n        lips.specials.LITERAL, which is the default behavior, or\n        lips.specials.SPLICE which causes the value to be unpacked into the expression.\n        This can be used for e.g. to make `#(1 2 3)` into (x 1 2 3) that is needed\n        by # that defines vectors.'), get: get2, ".": get2, unbind: doc(unbind, "(unbind fn)\n\n         Function that removes the weak 'this' binding from a function so you\n         can get properties from the actual function object."), type: doc(type, "(type object)\n\n         Function that returns the type of an object as string."), debugger: doc("debugger", function() {
      debugger;
    }, '(debugger)\n\n        Function that triggers the JavaScript debugger (e.g. the browser devtools)\n        using the "debugger;" statement. If a debugger is not running this\n        function does nothing.'), in: doc("in", function(e75, t2) {
      if (e75 instanceof LSymbol || e75 instanceof LString || e75 instanceof LNumber) {
        e75 = e75.valueOf();
      }
      return e75 in unbox(t2);
    }, '(in key value)\n\n        Function that uses the Javascript "in" operator to check if key is\n        a valid property in the value.'), "instance?": doc("instance?", function(e75) {
      return is_instance(e75);
    }, "(instance? obj)\n\n        Checks if object is an instance, created with a new operator"), instanceof: doc("instanceof", function(e75, t2) {
      return t2 instanceof unbind(e75);
    }, "(instanceof type obj)\n\n        Predicate that tests if the obj is an instance of type."), "prototype?": doc("prototype?", is_prototype, "(prototype? obj)\n\n         Predicate that tests if value is a valid JavaScript prototype,\n         i.e. calling (new) with it will not throw '<x> is not a constructor'."), "macro?": doc("macro?", function(e75) {
      return e75 instanceof Macro;
    }, "(macro? expression)\n\n        Predicate that tests if value is a macro."), "continuation?": doc("continuation?", is_continuation, "(continuation? expression)\n\n         Predicate that tests if value is a callable continuation."), "function?": doc("function?", is_function, "(function? expression)\n\n         Predicate that tests if value is a callable function."), "real?": doc("real?", function(e75) {
      if (type(e75) !== "number") {
        return false;
      }
      if (e75 instanceof LNumber) {
        return e75.isFloat();
      }
      return LNumber.isFloat(e75);
    }, "(real? number)\n\n        Predicate that tests if value is a real number (not complex)."), "number?": doc("number?", function(e75) {
      return Number.isNaN(e75) || LNumber.isNumber(e75);
    }, "(number? expression)\n\n        Predicate that tests if value is a number or NaN value."), "string?": doc("string?", function(e75) {
      return LString.isString(e75);
    }, "(string? expression)\n\n        Predicate that tests if value is a string."), "pair?": doc("pair?", is_pair, "(pair? expression)\n\n         Predicate that tests if value is a pair or list structure."), "regex?": doc("regex?", function(e75) {
      return e75 instanceof RegExp;
    }, "(regex? expression)\n\n        Predicate that tests if value is a regular expression."), "null?": doc("null?", function(e75) {
      return is_null(e75);
    }, "(null? expression)\n\n        Predicate that tests if value is null-ish (i.e. undefined, nil, or\n        Javascript null)."), "boolean?": doc("boolean?", function(e75) {
      return typeof e75 === "boolean";
    }, "(boolean? expression)\n\n        Predicate that tests if value is a boolean (#t or #f)."), "symbol?": doc("symbol?", function(e75) {
      return e75 instanceof LSymbol;
    }, "(symbol? expression)\n\n        Predicate that tests if value is a LIPS symbol."), "array?": doc("array?", function(e75) {
      return e75 instanceof Array;
    }, "(array? expression)\n\n        Predicate that tests if value is an array."), "object?": doc("object?", function(e75) {
      return !is_nil(e75) && e75 !== null && !(e75 instanceof LCharacter) && !(e75 instanceof RegExp) && !(e75 instanceof LString) && !is_pair(e75) && !(e75 instanceof LNumber) && _typeof$1(e75) === "object" && !(e75 instanceof Array);
    }, "(object? expression)\n\n        Predicate that tests if value is an plain object (not another LIPS type)."), flatten: doc("flatten", function e60(t2) {
      typecheck("flatten", t2, "pair");
      return t2.flatten();
    }, "(flatten list)\n\n        Returns a shallow list from tree structure (pairs)."), "vector-append": doc("vector-append", function() {
      for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
        t2[r] = arguments[r];
      }
      if (!t2.length) {
        return [];
      }
      typecheck_args("vector-append", t2, "array");
      var n = t2[0], i = t2.slice(1);
      return n.concat.apply(n, _toConsumableArray(i));
    }, "(vector-append v1 v2 ...)\n\n         Returns new vector by combining it's arguments that should be vectors."), "array->list": doc("array->list", function(e75) {
      typecheck("array->list", e75, "array");
      return Pair.fromArray(e75);
    }, "(array->list array)\n\n        Function that converts a JavaScript array to a LIPS cons list."), "tree->array": doc("tree->array", to_array("tree->array", true), "(tree->array list)\n\n         Function that converts a LIPS cons tree structure into a JavaScript array."), "list->array": doc("list->array", to_array("list->array"), "(list->array list)\n\n         Function that converts a LIPS list into a JavaScript array."), apply: doc("apply", function e61(t2) {
      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) {
        n[i - 1] = arguments[i];
      }
      typecheck("apply", t2, "function", 1);
      var a = n.pop();
      typecheck("apply", a, ["pair", "nil"], n.length + 2);
      n = n.concat(global_env.get("list->array").call(this, a));
      return t2.apply(this, prepare_fn_args(t2, n));
    }, "(apply fn list)\n\n        Function that calls fn with the list of arguments."), length: doc("length", function e62(t2) {
      if (!t2 || is_nil(t2)) {
        return 0;
      }
      if (is_pair(t2)) {
        return t2.length();
      }
      if ("length" in t2) {
        return t2.length;
      }
    }, '(length expression)\n\n        Function that returns the length of the object. The object can be a LIPS\n        list or any object that has a "length" property. Returns undefined if the\n        length could not be found.'), "string->number": doc("string->number", function(e75) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
      typecheck("string->number", e75, "string", 1);
      typecheck("string->number", t2, "number", 2);
      e75 = e75.valueOf();
      t2 = t2.valueOf();
      if (e75.match(rational_bare_re) || e75.match(rational_re)) {
        return parse_rational(e75, t2);
      } else if (e75.match(complex_bare_re) || e75.match(complex_re)) {
        return parse_complex(e75, t2);
      } else {
        var r = t2 === 10 && !e75.match(/e/i) || t2 === 16;
        if (e75.match(int_bare_re) && r || e75.match(int_re)) {
          return parse_integer(e75, t2);
        }
        if (e75.match(float_re)) {
          return parse_float(e75);
        }
      }
      return false;
    }, "(string->number number [radix])\n\n        Function that parses a string into a number."), try: doc(new Macro("try", function(r, e75) {
      var f = this;
      var _ = e75.use_dynamic;
      e75.error;
      return new Promise(function(t2, u) {
        var s, n;
        if (LSymbol.is(r.cdr.car.car, "catch")) {
          s = r.cdr.car;
          if (is_pair(r.cdr.cdr) && LSymbol.is(r.cdr.cdr.car.car, "finally")) {
            n = r.cdr.cdr.car;
          }
        } else if (LSymbol.is(r.cdr.car.car, "finally")) {
          n = r.cdr.car;
        }
        if (!(n || s)) {
          throw new Error("try: invalid syntax");
        }
        function c(e77) {
          t2(e77);
          throw new IgnoreException("[CATCH]");
        }
        var l = function e77(t3, r2) {
          r2(t3);
        };
        if (n) {
          l = function e77(t3, r2) {
            l = u;
            i.error = function(e78) {
              throw e78;
            };
            unpromise(_evaluate(new Pair(new LSymbol("begin"), n.cdr), i), function() {
              r2(t3);
            });
          };
        }
        var i = { env: f, use_dynamic: _, dynamic_env: f, error: function e77(t3) {
          if (t3 instanceof IgnoreException) {
            throw t3;
          }
          if (s) {
            var r2 = f.inherit("try");
            var n2 = s.cdr.car.car;
            if (!(n2 instanceof LSymbol)) {
              throw new Error("try: invalid syntax: catch require variable name");
            }
            r2.set(n2, t3);
            var i2;
            var a = { env: r2, use_dynamic: _, dynamic_env: f, error: function e78(t4) {
              i2 = true;
              u(t4);
              throw new IgnoreException("[CATCH]");
            } };
            var o = _evaluate(new Pair(new LSymbol("begin"), s.cdr.cdr), a);
            unpromise(o, function e78(t4) {
              if (!i2) {
                l(t4, c);
              }
            });
          } else {
            l(void 0, function() {
              u(t3);
            });
          }
        } };
        var e76 = _evaluate(r.car, i);
        unpromise(e76, function(e77) {
          l(e77, t2);
        }, i.error);
      });
    }), "(try expr (catch (e) code))\n         (try expr (catch (e) code) (finally code))\n         (try expr (finally code))\n\n         Macro that executes expr and catches any exceptions thrown. If catch is provided\n         it's executed when an error is thrown. If finally is provided it's always\n         executed at the end."), raise: doc("raise", function(e75) {
      throw e75;
    }, "(raise obj)\n\n        Throws the object verbatim (no wrapping an a new Error)."), throw: doc("throw", function(e75) {
      throw new Error(e75);
    }, "(throw string)\n\n        Throws a new exception."), find: doc("find", function t(r, n) {
      typecheck("find", n, ["pair", "nil"]);
      if (is_null(n)) {
        return false;
      }
      var e75 = matcher("find", r);
      return unpromise(e75(n.car), function(e76) {
        if (e76 && !is_nil(e76)) {
          return n.car;
        }
        return t(r, n.cdr);
      });
    }, "(find fn list)\n        (find regex list)\n        (find atom list)\n\n        Higher-order function that finds the first value for which fn return true.\n        If called with a regex or any atom it will create a matcher function."), "for-each": doc("for-each", function(e75) {
      var t2;
      typecheck("for-each", e75, "function");
      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) {
        n[i - 1] = arguments[i];
      }
      n.forEach(function(e76, t3) {
        typecheck("for-each", e76, ["pair", "nil"], t3 + 1);
      });
      var a = (t2 = global_env.get("map")).call.apply(t2, [this, e75].concat(n));
      if (is_promise(a)) {
        return a.then(function() {
        });
      }
    }, "(for-each fn . lists)\n\n        Higher-order function that calls function `fn` on each\n        value of the argument. If you provide more than one list\n        it will take each value from each list and call `fn` function\n        with that many arguments as number of list arguments."), map: doc("map", function e63(r) {
      var n = this;
      for (var t2 = arguments.length, i = new Array(t2 > 1 ? t2 - 1 : 0), a = 1; a < t2; a++) {
        i[a - 1] = arguments[a];
      }
      typecheck("map", r, "function");
      var o = global_env.get("list?");
      i.forEach(function(e75, t3) {
        typecheck("map", e75, ["pair", "nil"], t3 + 1);
        if (is_pair(e75) && !o.call(n, e75)) {
          throw new Error("map: argument ".concat(t3 + 1, " is not a list"));
        }
      });
      if (i.length === 0) {
        return _nil;
      }
      if (i.some(is_nil)) {
        return _nil;
      }
      var u = i.map(function(e75) {
        return e75.car;
      });
      var s = this.env, c = this.dynamic_env, l = this.use_dynamic;
      var f = call_function(r, u, { env: s, dynamic_env: c, use_dynamic: l });
      return unpromise(f, function(t3) {
        return unpromise(e63.call.apply(e63, [n, r].concat(_toConsumableArray(i.map(function(e75) {
          return e75.cdr;
        })))), function(e75) {
          return new Pair(t3, e75);
        });
      });
    }, "(map fn . lists)\n\n        Higher-order function that calls function `fn` with each\n        value of the list. If you provide more then one list as argument\n        it will take each value from each list and call `fn` function\n        with that many argument as number of list arguments. The return\n        values of the fn calls are accumulated in a result list and\n        returned by map."), "list?": doc("list?", function(e75) {
      var t2 = e75;
      while (true) {
        if (is_nil(t2)) {
          return true;
        }
        if (!is_pair(t2)) {
          return false;
        }
        if (t2.have_cycles("cdr")) {
          return false;
        }
        t2 = t2.cdr;
      }
    }, '(list? obj)\n\n        Predicate that tests if value is a proper linked list structure.\n        The car of each pair can be any value. It returns false on cyclic lists."'), fold: doc("fold", fold("fold", function(e75, t2, r) {
      for (var n = arguments.length, i = new Array(n > 3 ? n - 3 : 0), a = 3; a < n; a++) {
        i[a - 3] = arguments[a];
      }
      typecheck("fold", t2, "function");
      i.forEach(function(e76, t3) {
        typecheck("fold", e76, ["pair", "nil"], t3 + 1);
      });
      if (i.some(is_nil)) {
        return r;
      }
      var o = e75.call.apply(e75, [this, t2, r].concat(_toConsumableArray(i.map(function(e76) {
        return e76.cdr;
      }))));
      return unpromise(o, function(e76) {
        return t2.apply(void 0, _toConsumableArray(i.map(function(e77) {
          return e77.car;
        })).concat([e76]));
      });
    }), "(fold fn init . lists)\n\n         Function fold is left-to-right reversal of reduce. It call `fn`\n         on each pair of elements of the list and returns a single value.\n         e.g. it computes (fn 'a 'x (fn 'b 'y (fn 'c 'z 'foo)))\n         for: (fold fn 'foo '(a b c) '(x y z))"), pluck: doc("pluck", function e64() {
      for (var t2 = arguments.length, a = new Array(t2), r = 0; r < t2; r++) {
        a[r] = arguments[r];
      }
      return function(t3) {
        a = a.map(function(e76) {
          return e76 instanceof LSymbol ? e76.__name__ : e76;
        });
        if (a.length === 0) {
          return _nil;
        } else if (a.length === 1) {
          var e75 = a, r2 = _slicedToArray(e75, 1), n = r2[0];
          return t3[n];
        }
        var i = {};
        a.forEach(function(e76) {
          i[e76] = t3[e76];
        });
        return i;
      };
    }, "(pluck . strings)\n\n        If called with a single string it will return a function that when\n        called with an object will return that key from the object.\n        If called with more then one string the returned function will\n        create a new object by copying all properties from the given object."), reduce: doc("reduce", fold("reduce", function(t2, r, e75) {
      var n = this;
      for (var i = arguments.length, a = new Array(i > 3 ? i - 3 : 0), o = 3; o < i; o++) {
        a[o - 3] = arguments[o];
      }
      typecheck("reduce", r, "function");
      a.forEach(function(e76, t3) {
        typecheck("reduce", e76, ["pair", "nil"], t3 + 1);
      });
      if (a.some(is_nil)) {
        return e75;
      }
      return unpromise(r.apply(void 0, _toConsumableArray(a.map(function(e76) {
        return e76.car;
      })).concat([e75])), function(e76) {
        return t2.call.apply(t2, [n, r, e76].concat(_toConsumableArray(a.map(function(e77) {
          return e77.cdr;
        }))));
      });
    }), "(reduce fn init list . lists)\n\n         Higher-order function that takes each element of the list and calls\n         the fn with result of previous call or init and the next element\n         of the list until each element is processed, and returns a single value\n         as result of last call to `fn` function.\n         e.g. it computes (fn 'c 'z (fn 'b 'y (fn 'a 'x 'foo)))\n         for: (reduce fn 'foo '(a b c) '(x y z))"), filter: doc("filter", function e65(t2, r) {
      typecheck("filter", t2, ["regex", "function"]);
      typecheck("filter", r, ["pair", "nil"]);
      var i = global_env.get("list->array")(r);
      var a = [];
      var o = matcher("filter", t2);
      return function t3(r2) {
        function e75(e76) {
          if (e76 && !is_nil(e76)) {
            a.push(n);
          }
          return t3(++r2);
        }
        if (r2 === i.length) {
          return Pair.fromArray(a);
        }
        var n = i[r2];
        return unpromise(o(n), e75);
      }(0);
    }, "(filter fn list)\n        (filter regex list)\n\n        Higher-order function that calls `fn` for each element of the list\n        and return a new list for only those elements for which fn returns\n        a truthy value. If called with a regex it will create a matcher function."), compose: doc(compose, "(compose . fns)\n\n         Higher-order function that creates a new function that applies all functions\n         from right to left and returns the last value. Reverse of pipe.\n         e.g.:\n         ((compose (curry + 2) (curry * 3)) 10) ==> (+ 2 (* 3 10)) ==> 32"), pipe: doc(pipe, "(pipe . fns)\n\n         Higher-order function that creates a new function that applies all functions\n         from left to right and returns the last value. Reverse of compose.\n         e.g.:\n         ((pipe (curry + 2) (curry * 3)) 10) ==> (* 3 (+ 2 10)) ==> 36"), curry: doc(curry, "(curry fn . args)\n\n         Higher-order function that creates a curried version of the function.\n         The result function will have partially applied arguments and it\n         will keep returning one-argument functions until all arguments are provided,\n         then it calls the original function with the accumulated arguments.\n\n         e.g.:\n         (define (add a b c d) (+ a b c d))\n         (define add1 (curry add 1))\n         (define add12 (add 2))\n         (display (add12 3 4))"), gcd: doc("gcd", function e66() {
      for (var t2 = arguments.length, r = new Array(t2), n = 0; n < t2; n++) {
        r[n] = arguments[n];
      }
      typecheck_args("lcm", r, "number");
      return r.reduce(function(e75, t3) {
        return e75.gcd(t3);
      });
    }, "(gcd n1 n2 ...)\n\n        Function that returns the greatest common divisor of the arguments."), lcm: doc("lcm", function e67() {
      for (var t2 = arguments.length, r = new Array(t2), n = 0; n < t2; n++) {
        r[n] = arguments[n];
      }
      typecheck_args("lcm", r, "number");
      var i = r.length, a = abs(r[0]);
      for (var o = 1; o < i; o++) {
        var u = abs(r[o]), s = a;
        while (a && u) {
          a > u ? a %= u : u %= a;
        }
        a = abs(s * r[o]) / (a + u);
      }
      return LNumber(a);
    }, "(lcm n1 n2 ...)\n\n        Function that returns the least common multiple of the arguments."), "odd?": doc("odd?", single_math_op(function(e75) {
      return LNumber(e75).isOdd();
    }), "(odd? number)\n\n         Checks if number is odd."), "even?": doc("even?", single_math_op(function(e75) {
      return LNumber(e75).isEven();
    }), "(even? number)\n\n         Checks if number is even."), "*": doc("*", reduce_math_op(function(e75, t2) {
      return LNumber(e75).mul(t2);
    }, LNumber(1)), "(* . numbers)\n\n        Multiplies all numbers passed as arguments. If single value is passed\n        it will return that value."), "+": doc("+", reduce_math_op(function(e75, t2) {
      return LNumber(e75).add(t2);
    }, LNumber(0)), "(+ . numbers)\n\n        Sums all numbers passed as arguments. If single value is passed it will\n        return that value."), "-": doc("-", function() {
      for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
        t2[r] = arguments[r];
      }
      if (t2.length === 0) {
        throw new Error("-: procedure require at least one argument");
      }
      typecheck_args("-", t2, "number");
      if (t2.length === 1) {
        return LNumber(t2[0]).sub();
      }
      if (t2.length) {
        return t2.reduce(binary_math_op(function(e76, t3) {
          return LNumber(e76).sub(t3);
        }));
      }
    }, "(- n1 n2 ...)\n        (- n)\n\n        Subtracts n2 and subsequent numbers from n1. If only one argument is passed\n        it will negate the value."), "/": doc("/", function() {
      for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
        t2[r] = arguments[r];
      }
      if (t2.length === 0) {
        throw new Error("/: procedure require at least one argument");
      }
      typecheck_args("/", t2, "number");
      if (t2.length === 1) {
        return LNumber(1).div(t2[0]);
      }
      return t2.reduce(binary_math_op(function(e76, t3) {
        return LNumber(e76).div(t3);
      }));
    }, "(/ n1 n2 ...)\n        (/ n)\n\n        Divides n1 by n2 and subsequent arguments one by one. If single argument\n        is passed it will calculate (/ 1 n)."), abs: doc("abs", single_math_op(function(e75) {
      return LNumber(e75).abs();
    }), "(abs number)\n\n         Function that returns the absolute value (magnitude) of number."), truncate: doc("truncate", function(e75) {
      typecheck("truncate", e75, "number");
      if (LNumber.isFloat(e75)) {
        if (e75 instanceof LNumber) {
          e75 = e75.valueOf();
        }
        return LFloat(truncate(e75));
      }
      return e75;
    }, "(truncate n)\n\n        Function that returns the integer part (floor) of a real number."), sqrt: doc("sqrt", single_math_op(function(e75) {
      return LNumber(e75).sqrt();
    }), "(sqrt number)\n\n         Function that returns the square root of the number."), "**": doc("**", binary_math_op(function(e75, t2) {
      e75 = LNumber(e75);
      t2 = LNumber(t2);
      if (LNumber.isInteger(t2)) {
        var r = t2.cmp(0) === -1;
        if (r) {
          t2 = t2.sub();
        }
        if (LNumber.isRational(e75)) {
          if (r) {
            var n = e75.__denom__.pow(t2);
            if (e75.__num__.cmp(1) === 0) {
              return n;
            }
            var i = e75.__num__.pow(t2);
            return LRational({ num: n, denom: i });
          }
          return LRational({ num: e75.__num__.pow(t2), denom: e75.__denom__.pow(t2) });
        }
        if (r) {
          return LRational({ num: 1, denom: e75.pow(t2) });
        }
      }
      if (LNumber.isRational(t2) && e75.cmp(0) === -1) {
        var a = t2.__denom__;
        var o = t2.__num__;
        if (a.cmp(2) === 0) {
          var u = e75.abs().pow(LRational({ num: 1, denom: 2 }));
          var s = e75.coerce(u);
          var c = _slicedToArray(s, 2);
          u = c[1];
          if (t2.cmp(0) === 1) {
            return LComplex({ re: LNumber(0), im: u });
          }
          if (o.cmp(0) === -1) {
            return LComplex({ re: LNumber(0), im: LRational({ num: -1, denom: u }) });
          }
        }
        var l = t2.valueOf();
        var f = l * Math.PI;
        var _ = e75.abs().pow(l);
        var p = _.mul(Math.cos(f));
        var d = _.mul(Math.sin(f));
        return LComplex({ re: p, im: d });
      }
      var h = e75.coerce(t2);
      var m = _slicedToArray(h, 2);
      e75 = m[0];
      t2 = m[1];
      return e75.pow(t2);
    }), "(** a b)\n\n         Function that calculates number a to to the power of b."), "1+": doc("1+", single_math_op(function(e75) {
      return LNumber(e75).add(1);
    }), "(1+ number)\n\n         Function that adds 1 to the number and return result."), "1-": doc(single_math_op(function(e75) {
      return LNumber(e75).sub(1);
    }), "(1- number)\n\n         Function that subtracts 1 from the number and return result."), "%": doc("%", function(e75, t2) {
      typecheck_args("%", [e75, t2], "number");
      return LNumber(e75).rem(t2);
    }, "(% n1 n2)\n\n        Function returns the remainder of n1/n2 (modulo)."), "==": doc("==", function() {
      for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
        t2[r] = arguments[r];
      }
      typecheck_args("==", t2, "number");
      return seq_compare(function(e76, t3) {
        return LNumber(e76).cmp(t3) === 0;
      }, t2);
    }, "(== x1 x2 ...)}\n\n        Function that compares its numerical arguments and checks if they are\n        all equal."), ">": doc(">", function() {
      for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
        t2[r] = arguments[r];
      }
      typecheck_numbers(">", t2, ["bigint", "float", "rational"]);
      return seq_compare(function(e76, t3) {
        return LNumber(e76).cmp(t3) === 1;
      }, t2);
    }, "(> x1 x2 x3 ...)\n\n        Function that compares its numerical arguments and checks if they are\n        monotonically decreasing, i.e. x1 > x2 and x2 > x3 and so on."), "<": doc("<", function() {
      for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
        t2[r] = arguments[r];
      }
      typecheck_numbers("<", t2, ["bigint", "float", "rational"]);
      return seq_compare(function(e76, t3) {
        return LNumber(e76).cmp(t3) === -1;
      }, t2);
    }, "(< x1 x2 ...)\n\n        Function that compares its numerical arguments and checks if they are\n        monotonically increasing, i.e. x1 < x2 and x2 < x3 and so on."), "<=": doc("<=", function() {
      for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
        t2[r] = arguments[r];
      }
      typecheck_numbers("<=", t2, ["bigint", "float", "rational"]);
      return seq_compare(function(e76, t3) {
        return [0, -1].includes(LNumber(e76).cmp(t3));
      }, t2);
    }, "(<= x1 x2 ...)\n\n        Function that compares its numerical arguments and checks if they are\n        monotonically nondecreasing, i.e. x1 <= x2 and x2 <= x3 and so on."), ">=": doc(">=", function() {
      for (var e75 = arguments.length, t2 = new Array(e75), r = 0; r < e75; r++) {
        t2[r] = arguments[r];
      }
      typecheck_numbers(">=", t2, ["bigint", "float", "rational"]);
      return seq_compare(function(e76, t3) {
        return [0, 1].includes(LNumber(e76).cmp(t3));
      }, t2);
    }, "(>= x1 x2 ...)\n\n        Function that compares its numerical arguments and checks if they are\n        monotonically nonincreasing, i.e. x1 >= x2 and x2 >= x3 and so on."), "eq?": doc("eq?", equal, "(eq? a b)\n\n         Function that compares two values if they are identical."), or: doc(new Macro("or", function(e75, t2) {
      var i = t2.use_dynamic, a = t2.error;
      var o = global_env.get("list->array")(e75);
      var u = this;
      var s = u;
      if (!o.length) {
        return false;
      }
      var c;
      return function t3() {
        function e76(e77) {
          c = e77;
          if (!is_false(c)) {
            return c;
          } else {
            return t3();
          }
        }
        if (!o.length) {
          if (!is_false(c)) {
            return c;
          } else {
            return false;
          }
        } else {
          var r = o.shift();
          var n = _evaluate(r, { env: u, dynamic_env: s, use_dynamic: i, error: a });
          return unpromise(n, e76);
        }
      }();
    }), "(or . expressions)\n\n         Macro that executes the values one by one and returns the first that is\n         a truthy value. If there are no expressions that evaluate to true it\n         returns false."), and: doc(new Macro("and", function(e75) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = t2.use_dynamic, n = t2.error;
      var i = global_env.get("list->array")(e75);
      var a = this;
      var o = a;
      if (!i.length) {
        return true;
      }
      var u;
      var s = { env: a, dynamic_env: o, use_dynamic: r, error: n };
      return function t3() {
        function e76(e77) {
          u = e77;
          if (is_false(u)) {
            return u;
          } else {
            return t3();
          }
        }
        if (!i.length) {
          if (!is_false(u)) {
            return u;
          } else {
            return false;
          }
        } else {
          var r2 = i.shift();
          return unpromise(_evaluate(r2, s), e76);
        }
      }();
    }), "(and . expressions)\n\n         Macro that evaluates each expression in sequence and if any value returns false\n         it will stop and return false. If each value returns true it will return the\n         last value. If it's called without arguments it will return true."), "|": doc("|", function(e75, t2) {
      return LNumber(e75).or(t2);
    }, "(| a b)\n\n        Function that calculates the bitwise or operation."), "&": doc("&", function(e75, t2) {
      return LNumber(e75).and(t2);
    }, "(& a b)\n\n        Function that calculates the bitwise and operation."), "~": doc("~", function(e75) {
      return LNumber(e75).neg();
    }, "(~ number)\n\n        Function that calculates the bitwise inverse (flip all the bits)."), ">>": doc(">>", function(e75, t2) {
      return LNumber(e75).shr(t2);
    }, "(>> a b)\n\n        Function that right shifts the value a by value b bits."), "<<": doc("<<", function(e75, t2) {
      return LNumber(e75).shl(t2);
    }, "(<< a b)\n\n        Function that left shifts the value a by value b bits."), not: doc("not", function e68(t2) {
      return !t2;
    }, "(not object)\n\n        Function that returns the Boolean negation of its argument.") }, void 0, "global");
    user_env = global_env.inherit("user-env");
    set_interaction_env(user_env, internal_env);
    global_env.doc("**interaction-environment**", "**interaction-environment**\n\n    Internal dynamic, global variable used to find interpreter environment.\n    It's used so the read and write functions can locate **internal-env**\n    that contains the references to stdin, stdout and stderr.");
    (function() {
      var e75 = { ceil: "ceiling" };
      ["floor", "round", "ceil"].forEach(function(t2) {
        var r = e75[t2] ? e75[t2] : t2;
        global_env.set(r, doc(r, function(e76) {
          typecheck(r, e76, "number");
          if (e76 instanceof LNumber) {
            return e76[t2]();
          }
        }, "(".concat(r, " number)\n\n            Function that calculates the ").concat(r, " of a number.")));
      });
    })();
    combinations(["d", "a"], 2, 5).forEach(function(e75) {
      var t2 = e75.split("");
      var r = t2.slice().reverse();
      var n = t2.map(function(e76) {
        return "(c".concat(e76, "r");
      }).join(" ") + " arg" + ")".repeat(t2.length);
      var i = "c" + e75 + "r";
      global_env.set(i, doc(i, function(e76) {
        return r.reduce(function(e77, t3) {
          typecheck(i, e77, "pair");
          if (t3 === "a") {
            return e77.car;
          } else {
            return e77.cdr;
          }
        }, e76);
      }, "(".concat(i, " arg)\n\n        Function that calculates ").concat(n)));
    });
    noop = function e69() {
    };
    if (is_node()) {
      node_ready = node_specific();
    } else {
      node_ready = Promise.resolve();
      if (typeof window !== "undefined" && window === root) {
        global_env.set("window", window);
        global_env.set("global", void 0);
        global_env.set("self", window);
      } else if (typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined") {
        global_env.set("self", self);
        global_env.set("window", void 0);
        global_env.set("global", void 0);
      }
    }
    type = memoize(type);
    _p_name__ = /* @__PURE__ */ new WeakMap();
    Parameter = function() {
      function n(e75) {
        var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        _classCallCheck(this, n);
        _defineProperty(this, "__value__", void 0);
        _defineProperty(this, "__fn__", void 0);
        _classPrivateFieldInitSpec(this, _p_name__, void 0);
        this.__value__ = e75;
        if (t2) {
          if (!is_function(t2)) {
            throw new Error("Section argument to Parameter need to be function " + "".concat(type(t2), " given"));
          }
          this.__fn__ = t2;
        }
        if (r) {
          _classPrivateFieldSet(_p_name__, this, r);
        }
      }
      return _createClass(n, [{ key: "__name__", get: function e75() {
        return _classPrivateFieldGet(_p_name__, this);
      }, set: function e75(t2) {
        _classPrivateFieldSet(_p_name__, this, t2);
        if (this.__fn__) {
          this.__fn__.__name__ = "fn-".concat(t2);
        }
      } }, { key: "invoke", value: function e75() {
        if (is_function(this.__fn__)) {
          return this.__fn__(this.__value__);
        }
        return this.__value__;
      } }, { key: "inherit", value: function e75(t2) {
        return new n(t2, this.__fn__, this.__name__);
      } }]);
    }();
    LambdaContext = function() {
      function t2(e75) {
        _classCallCheck(this, t2);
        _defineProperty(this, "env", void 0);
        _defineProperty(this, "dynamic_env", void 0);
        _defineProperty(this, "use_dynamic", void 0);
        Object.assign(this, e75);
      }
      return _createClass(t2, [{ key: "__name__", get: function e75() {
        return this.env.__name__;
      } }, { key: "__parent__", get: function e75() {
        return this.env.__parent__;
      } }, { key: "get", value: function e75() {
        var t3;
        return (t3 = this.env).get.apply(t3, arguments);
      } }]);
    }();
    Continuation = function() {
      function t2(e75) {
        _classCallCheck(this, t2);
        _defineProperty(this, "__value__", void 0);
        this.__value__ = e75;
      }
      return _createClass(t2, [{ key: "invoke", value: function e75() {
        if (this.__value__ === null) {
          throw new Error("Continuations are not implemented yet");
        }
      } }]);
    }();
    compile = exec_collect(function(e75) {
      return e75;
    });
    exec = exec_collect(function(e75, t2) {
      return t2;
    });
    current_script = get_current_script();
    serialization_map = { pair: function e70(t2) {
      var r = _slicedToArray(t2, 2), n = r[0], i = r[1];
      return Pair(n, i);
    }, number: function e71(t2) {
      if (LString.isString(t2)) {
        return LNumber([t2, 10]);
      }
      return LNumber(t2);
    }, regex: function e72(t2) {
      var r = _slicedToArray(t2, 2), n = r[0], i = r[1];
      return new RegExp(n, i);
    }, nil: function e73() {
      return _nil;
    }, symbol: function e74(t2) {
      if (LString.isString(t2)) {
        return LSymbol(t2);
      } else if (Array.isArray(t2)) {
        return LSymbol(Symbol["for"](t2[0]));
      }
    }, string: LString, character: LCharacter };
    available_class = Object.keys(serialization_map);
    class_map = {};
    for (_i6 = 0, _Object$entries3 = Object.entries(available_class); _i6 < _Object$entries3.length; _i6++) {
      _Object$entries3$_i = _slicedToArray(_Object$entries3[_i6], 2), i = _Object$entries3$_i[0], cls = _Object$entries3$_i[1];
      class_map[cls] = +i;
    }
    cbor = function() {
      var e75 = { pair: Pair, symbol: LSymbol, number: LNumber, string: LString, character: LCharacter, nil: _nil.constructor, regex: RegExp };
      function t2(e76, t3) {
        return { deserialize: t3, Class: e76 };
      }
      var r = new Encoder();
      var a = {};
      for (var n = 0, i = Object.entries(serialization_map); n < i.length; n++) {
        var o = _slicedToArray(i[n], 2), u = o[0], s = o[1];
        var c = e75[u];
        a[u] = t2(c, s);
      }
      var l = 43311;
      Object.keys(a).forEach(function(e76) {
        var t3 = a[e76];
        if (typeof t3 === "function") {
          var r2 = t3;
          addExtension({ Class: r2, tag: l, encode: function e77(t4, r3) {
            r3(t4.serialize());
          }, decode: function e77(t4) {
            return new r2(t4);
          } });
        } else {
          var n2 = t3.deserialize, i2 = t3.Class;
          addExtension({ Class: i2, tag: l, encode: function e77(t4, r3) {
            if (t4 instanceof RegExp) {
              return r3([t4.source, t4.flags]);
            }
            r3(t4.serialize());
          }, decode: function e77(t4) {
            return n2(t4);
          } });
        }
        l++;
      });
      return r;
    }();
    MAGIC_LENGTH = 7;
    currentScript = typeof window !== "undefined" && window.document && document.currentScript;
    if (typeof window !== "undefined") {
      contentLoaded(window, init);
    }
    banner = function() {
      var e75 = LString("Sat, 10 May 2025 19:46:53 +0000").valueOf();
      var t2 = e75 === "{{DATE}}" ? /* @__PURE__ */ new Date() : new Date(e75);
      var r = function e76(t3) {
        return t3.toString().padStart(2, "0");
      };
      var n = t2.getFullYear();
      var i = [n, r(t2.getMonth() + 1), r(t2.getDate())].join("-");
      var a = "\n  __ __                          __\n / / \\ \\       _    _  ___  ___  \\ \\\n| |   \\ \\     | |  | || . \\/ __>  | |\n| |    > \\    | |_ | ||  _/\\__ \\  | |\n| |   / ^ \\   |___||_||_|  <___/  | |\n \\_\\ /_/ \\_\\                     /_/\n\nLIPS Interpreter DEV (".concat(i, ") <https://lips.js.org>\nCopyright (c) 2018-").concat(n, " Jakub T. Jankiewicz\n\nType (env) to see environment with functions macros and variables. You can also\nuse (help name) to display help for specific function or macro, (apropos name)\nto display list of matched names in environment and (dir object) to list\nproperties of an object.\n").replace(/^.*\n/, "");
      return a;
    }();
    read_only(Ahead, "__class__", "ahead");
    read_only(Pair, "__class__", "pair");
    read_only(Nil, "__class__", "nil");
    read_only(Pattern, "__class__", "pattern");
    read_only(Formatter, "__class__", "formatter");
    read_only(Macro, "__class__", "macro");
    read_only(Syntax, "__class__", "syntax");
    read_only(Syntax.Parameter, "__class__", "syntax-parameter");
    read_only(Environment, "__class__", "environment");
    read_only(InputPort, "__class__", "input-port");
    read_only(OutputPort, "__class__", "output-port");
    read_only(BufferedOutputPort, "__class__", "output-port");
    read_only(OutputStringPort, "__class__", "output-string-port");
    read_only(InputStringPort, "__class__", "input-string-port");
    read_only(InputFilePort, "__class__", "input-file-port");
    read_only(OutputFilePort, "__class__", "output-file-port");
    read_only(LipsError, "__class__", "lips-error");
    [LNumber, LComplex, LRational, LFloat, LBigInteger].forEach(function(e75) {
      read_only(e75, "__class__", "number");
    });
    read_only(LCharacter, "__class__", "character");
    read_only(LSymbol, "__class__", "symbol");
    read_only(LString, "__class__", "string");
    read_only(QuotedPromise, "__class__", "promise");
    read_only(Parameter, "__class__", "parameter");
    version = "DEV";
    date = "Sat, 10 May 2025 19:46:53 +0000";
    parse = compose(uniterate_async, _parse);
    lips = { version, banner, date, exec, parse, tokenize, evaluate: _evaluate, compile, serialize, unserialize, box, unbox, serialize_bin, unserialize_bin, bootstrap, Environment, env: user_env, Worker: Worker2, Interpreter, balanced_parenthesis: balanced, balancedParenthesis: balanced, balanced, Macro, Syntax, Pair, Values, QuotedPromise, Error: LipsError, quote, InputPort, OutputPort, BufferedOutputPort, InputFilePort, OutputFilePort, InputStringPort, OutputStringPort, InputByteVectorPort, OutputByteVectorPort, InputBinaryFilePort, OutputBinaryFilePort, set_fs, Formatter, Parser, Lexer, specials, repr, nil: _nil, eof, LSymbol, LNumber, LFloat, LComplex, LRational, LBigInteger, LCharacter, LString, Parameter, rationalize };
    global_env.set("lips", lips);
  }
});

// src/lipsShim.ts
var FixedParser;
var init_lipsShim = __esm({
  async "src/lipsShim.ts"() {
    "use strict";
    init_lips_esm_min();
    init_lips_esm_min();
    await bootstrap("https://cdn.jsdelivr.net/npm/@jcubic/lips/dist/std.xcb");
    specials.__list__ = {};
    LSymbol.list = new Proxy(LSymbol.list, {
      get: () => void 0
    });
    FixedParser = class extends Parser {
      /* disable datum references */
      match_datum_label(token) {
        return null;
      }
      match_datum_ref(token) {
        return null;
      }
    };
  }
});

// src/common/utils.ts
function base64ToBytes(base64) {
  var binaryString = atob(base64);
  var bytes = new Uint8Array(binaryString.length);
  for (var i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function bytesToBase64(buffer) {
  return btoa(String.fromCharCode.apply(null, buffer));
}
async function parseWithMetadata(source) {
  const parser = new FixedParser({ env: user_env, meta: true });
  parser.prepare(source);
  return await parse(parser);
}
function isEmbedded() {
  return window.self !== window.top;
}
var consToArray, repr2;
var init_utils = __esm({
  async "src/common/utils.ts"() {
    "use strict";
    await init_lipsShim();
    consToArray = user_env.get("list->array");
    repr2 = (x) => user_env.get("format")("~s", x);
  }
});

// src/common/nodeDef.ts
var Port;
var init_nodeDef = __esm({
  "src/common/nodeDef.ts"() {
    "use strict";
    Port = class {
      type;
      initialVal;
      flags;
      constructor(type2, initialVal, flags = []) {
        this.type = type2;
        this.initialVal = initialVal;
        this.flags = flags;
      }
      is(pf) {
        return this.flags.includes(pf);
      }
    };
  }
});

// src/common/otherTypes.ts
var Color, Point;
var init_otherTypes = __esm({
  "src/common/otherTypes.ts"() {
    "use strict";
    Color = class {
      r;
      g;
      b;
      constructor(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
      }
      toString() {
        return `Color(${this.r}, ${this.g}, ${this.b})`;
      }
    };
    Point = class _Point {
      x;
      y;
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      toString() {
        return `Point(${this.x}, ${this.y})`;
      }
      static EMPTY = new _Point(void 0, void 0);
    };
  }
});

// src/nodes/basic.ts
var basic_exports = {};
var init_basic = __esm({
  "src/nodes/basic.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      category: "Basic",
      id: "log",
      inputs: { values: new Port("any", [], ["bus"]) },
      outputs: {},
      doc: "Logs the values whenever one of them updates.",
      update({ app, node }) {
        app.log(node.get("values").join(" "));
      }
    });
  }
});

// src/nodes/flow_control.ts
var flow_control_exports = {};
var init_flow_control = __esm({
  "src/nodes/flow_control.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      category: "Flow Control",
      id: "value",
      template: { T: ["any"] },
      doc: `Emits the same value every time when it is updated
    by the \`:trigger\` input.`,
      inputs: {
        trigger: new Port("signal", void 0),
        value: new Port("T", void 0, ["silent"])
      },
      outputs: {
        value: new Port("T", void 0)
      },
      update({ node }) {
        node.output("value", node.get("value"));
      }
    });
    defNode({
      category: "Flow Control",
      id: "edges",
      doc: `Emits a signal on \`:rising\` when \`:value\` changes from
    false to true, and a signal on \`:falling\` when \`:value\` changes
    from true to false.`,
      inputs: {
        value: new Port("boolean", false)
      },
      outputs: {
        rising: new Port("signal", void 0),
        falling: new Port("signal", void 0)
      },
      stateKeys: ["oldState"],
      setup({ node }) {
        node.state.oldState = false;
      },
      update({ node, changes }) {
        const oldState = node.state.oldState;
        const newState = changes.value;
        node.state.oldState = newState;
        if (oldState !== newState) {
          node.output(newState ? "rising" : "falling");
        }
      }
    });
  }
});

// src/nodes/html.ts
var html_exports = {};
function hexToRgb(hex) {
  const num = parseInt(hex.slice(1), 16);
  const r = num >> 16 & 255;
  const g = num >> 8 & 255;
  const b = num & 255;
  return [r, g, b];
}
function rgbToHex(color) {
  const r = color.r.toString(16).padStart(2, "0");
  const g = color.g.toString(16).padStart(2, "0");
  const b = color.b.toString(16).padStart(2, "0");
  return `#${r}${g}${b}`;
}
var init_html = __esm({
  "src/nodes/html.ts"() {
    "use strict";
    init_vanilla();
    init_nodeDef();
    init_all();
    init_otherTypes();
    defNode({
      category: "User Interface",
      id: "button",
      inputs: {
        text: new Port("string", "Button")
      },
      outputs: {
        pressed: new Port("boolean", false),
        hovering: new Port("boolean", false)
      },
      doc: `Creates a HTML [\`<button>\`](https://developer.mozilla.org/docs/Web/HTML/Element/button)
    element with the given text and outputs \`:pressed\` and \`:hovering\` states when the user
    interacts with it.`,
      stateKeys: ["el"],
      setup({ app, node }) {
        const button = make("button", {}, node.get("text"));
        app.addUI(button);
        node.state.el = button;
        button.addEventListener("pointerdown", () => {
          node.output("pressed", true);
        });
        button.addEventListener("pointerup", () => {
          node.output("pressed", false);
        });
        button.addEventListener("mouseover", () => {
          node.output("hovering", true);
        });
        button.addEventListener("mouseout", () => {
          node.output("hovering", false);
        });
        node.output("hovering", false);
        node.output("pressed", false);
      },
      update({ node }) {
        node.state.el.textContent = node.get("text");
      }
    });
    defNode({
      category: "User Interface",
      id: "select",
      inputs: {
        options: new Port("string", [], ["bus"]),
        label: new Port("string", "Select"),
        value: new Port("string", "")
      },
      outputs: {
        selected: new Port("string", ""),
        index: new Port("number", 0)
      },
      doc: `Creates a HTML [\`<select>\`](https://developer.mozilla.org/docs/Web/HTML/Element/select)
    dropdown. Takes an array of options and outputs the selected value and index.`,
      stateKeys: ["el", "labelText"],
      setup({ app, node }) {
        const labelEl = make("label");
        const labelText = make("span", {}, node.get("label"));
        const select = make("select");
        labelEl.append(labelText, select);
        app.addUI(labelEl);
        node.state.el = select;
        node.state.labelText = labelText;
        (node.get("options") || []).forEach((opt) => {
          const option = make("option", {}, opt);
          select.append(option);
        });
        if (node.get("value")) {
          select.value = node.get("value");
        }
        select.addEventListener("change", () => {
          node.output("selected", select.value);
          node.output("index", select.selectedIndex);
        });
        node.output("selected", select.value);
        node.output("index", select.selectedIndex);
      },
      update({ node, changes }) {
        const select = node.state.el;
        const labelText = node.state.labelText;
        labelText.textContent = node.get("label");
        const oldValue = select.value;
        select.innerHTML = "";
        (node.get("options") || []).forEach((opt) => {
          const option = make("option", {}, opt);
          select.append(option);
        });
        if ("value" in changes) {
          select.value = node.get("value");
        } else {
          select.value = oldValue;
        }
      }
    });
    defNode({
      category: "User Interface",
      id: "number-input",
      inputs: {
        value: new Port("number", 0),
        min: new Port("number", 0),
        max: new Port("number", 100),
        step: new Port("number", 1),
        label: new Port("string", "Number")
      },
      outputs: {
        value: new Port("number", 0)
      },
      doc: `Creates a HTML [\`<input type=number>\`](https://developer.mozilla.org/docs/Web/HTML/Element/input/number)
    element. Outputs the current value.`,
      stateKeys: ["el", "labelText"],
      setup({ app, node }) {
        const labelEl = make("label");
        const labelText = make("span", {}, node.get("label"));
        const input = make("input", { type: "number" });
        labelEl.append(labelText, input);
        app.addUI(labelEl);
        node.state.el = input;
        node.state.labelText = labelText;
        input.min = String(node.get("min"));
        input.max = String(node.get("max"));
        input.step = String(node.get("step"));
        input.value = String(node.get("value"));
        input.addEventListener("change", () => {
          node.output("value", Number(input.value));
        });
        node.output("value", Number(input.value));
      },
      update({ node, changes }) {
        const input = node.state.el;
        const labelText = node.state.labelText;
        labelText.textContent = node.get("label");
        input.min = String(node.get("min"));
        input.max = String(node.get("max"));
        input.step = String(node.get("step"));
        if ("value" in changes) {
          input.value = String(node.get("value"));
        }
      }
    });
    defNode({
      category: "User Interface",
      id: "range",
      inputs: {
        value: new Port("number", 0),
        min: new Port("number", 0),
        max: new Port("number", 100),
        step: new Port("number", 1),
        label: new Port("string", "Range")
      },
      outputs: {
        value: new Port("number", 0)
      },
      doc: `Creates a HTML [\`<input type=range>\`](https://developer.mozilla.org/docs/Web/HTML/Element/input/range)
    slider. Outputs the current value.`,
      stateKeys: ["el", "labelText"],
      setup({ app, node }) {
        const labelEl = make("label");
        const labelText = make("span", {}, node.get("label"));
        labelEl.append(labelText);
        const input = make("input", { type: "range" });
        labelEl.append(input);
        app.addUI(labelEl);
        node.state.el = input;
        node.state.labelText = labelText;
        input.min = String(node.get("min"));
        input.max = String(node.get("max"));
        input.step = String(node.get("step"));
        input.value = String(node.get("value"));
        input.addEventListener("input", () => {
          node.output("value", Number(input.value));
        });
        node.output("value", Number(input.value));
      },
      update({ node, changes }) {
        const input = node.state.el;
        const labelText = node.state.labelText;
        labelText.textContent = node.get("label");
        input.min = String(node.get("min"));
        input.max = String(node.get("max"));
        input.step = String(node.get("step"));
        if ("value" in changes) {
          input.value = String(node.get("value"));
        }
      }
    });
    defNode({
      category: "User Interface",
      id: "output",
      inputs: {
        value: new Port("any", ""),
        label: new Port("string", "Output")
      },
      outputs: {},
      doc: `Creates a HTML [\`<output>\`](https://developer.mozilla.org/docs/Web/HTML/Element/output)
    element to display a value.`,
      stateKeys: ["el", "labelText"],
      setup({ app, node }) {
        const labelEl = make("label");
        const labelText = make("span", {}, node.get("label"));
        const output = make("output");
        labelEl.append(labelText, output);
        app.addUI(labelEl);
        node.state.el = output;
        node.state.labelText = labelText;
        output.textContent = node.get("value");
      },
      update({ node }) {
        const output = node.state.el;
        const labelText = node.state.labelText;
        labelText.textContent = node.get("label");
        output.value = String(node.get("value"));
      }
    });
    defNode({
      category: "User Interface",
      id: "meter",
      inputs: {
        value: new Port("number", 0),
        min: new Port("number", 0),
        max: new Port("number", 100),
        low: new Port("number", 0),
        high: new Port("number", 100),
        optimum: new Port("number", 50),
        label: new Port("string", "Meter")
      },
      outputs: {},
      doc: `Creates a HTML [\`<meter>\`](https://developer.mozilla.org/docs/Web/HTML/Element/meter)
    element to display a numeric measurement.`,
      stateKeys: ["el", "labelText"],
      setup({ app, node }) {
        const labelEl = make("label");
        const labelText = make("span", {}, node.get("label"));
        labelEl.append(labelText);
        const meter = make("meter");
        labelEl.append(meter);
        app.addUI(labelEl);
        node.state.el = meter;
        node.state.labelText = labelText;
        meter.min = node.get("min");
        meter.max = node.get("max");
        meter.low = node.get("low");
        meter.high = node.get("high");
        meter.optimum = node.get("optimum");
        meter.value = node.get("value");
      },
      update({ node, changes }) {
        const meter = node.state.el;
        const labelText = node.state.labelText;
        labelText.textContent = node.get("label");
        meter.min = node.get("min");
        meter.max = node.get("max");
        meter.low = node.get("low");
        meter.high = node.get("high");
        meter.optimum = node.get("optimum");
        if ("value" in changes) {
          meter.value = node.get("value");
        }
      }
    });
    defNode({
      category: "User Interface",
      id: "text-input",
      inputs: {
        label: new Port("string", "Text"),
        value: new Port("string", "")
      },
      outputs: {
        value: new Port("string", "")
      },
      doc: `Creates a HTML [\`<input type=text>\`](https://developer.mozilla.org/docs/Web/HTML/Element/input/text)
    element with a label. Outputs the current value.`,
      stateKeys: ["el", "labelText"],
      setup({ app, node }) {
        const labelEl = make("label");
        const labelText = make("span", {}, node.get("label"));
        const input = make("input", { type: "text" });
        labelEl.append(labelText, input);
        app.addUI(labelEl);
        node.state.el = input;
        node.state.labelText = labelText;
        input.value = node.get("value");
        input.addEventListener("input", () => {
          node.output("value", input.value);
        });
        node.output("value", input.value);
      },
      update({ node, changes }) {
        const input = node.state.el;
        const labelText = node.state.labelText;
        labelText.textContent = node.get("label");
        if ("value" in changes) {
          input.value = node.get("value");
        }
      }
    });
    defNode({
      category: "User Interface",
      id: "color-input",
      inputs: {
        label: new Port("string", "Color"),
        value: new Port("color", new Color(0, 0, 0))
      },
      outputs: {
        value: new Port("color", new Color(0, 0, 0))
      },
      doc: `Creates a HTML [\`<input type=color>\`](https://developer.mozilla.org/docs/Web/HTML/Element/input/color)
    element with a label. Outputs the current color value.`,
      stateKeys: ["el", "labelText"],
      setup({ app, node }) {
        const labelEl = make("label");
        const labelText = make("span", {}, node.get("label"));
        const input = make("input", { type: "color" });
        labelEl.append(labelText, input);
        app.addUI(labelEl);
        node.state.el = input;
        node.state.labelText = labelText;
        input.value = rgbToHex(node.get("value"));
        input.addEventListener("input", () => {
          node.output("value", new Color(...hexToRgb(input.value)));
        });
        node.output("value", new Color(...hexToRgb(input.value)));
      },
      update({ node, changes }) {
        const input = node.state.el;
        const labelText = node.state.labelText;
        labelText.textContent = node.get("label");
        if ("value" in changes) {
          input.value = rgbToHex(node.get("value"));
        }
      }
    });
    defNode({
      category: "User Interface",
      id: "checkbox",
      inputs: {
        label: new Port("string", "Checkbox"),
        checked: new Port("boolean", false)
      },
      outputs: {
        value: new Port("boolean", false)
      },
      doc: `Creates a HTML [\`<input type=checkbox>\`](https://developer.mozilla.org/docs/Web/HTML/Element/input/checkbox)
    element with a label. Outputs the checked state as a boolean.`,
      stateKeys: ["el", "labelText"],
      setup({ app, node }) {
        const labelEl = make("label");
        const labelText = make("span", {}, node.get("label"));
        const input = make("input", { type: "checkbox" });
        labelEl.append(labelText, input);
        app.addUI(labelEl);
        node.state.el = input;
        node.state.labelText = labelText;
        input.checked = !!node.get("checked");
        input.addEventListener("change", () => {
          node.output("value", input.checked);
        });
        node.output("value", input.checked);
      },
      update({ node, changes }) {
        const input = node.state.el;
        const labelText = node.state.labelText;
        labelText.textContent = node.get("label");
        if ("checked" in changes) {
          input.checked = !!node.get("checked");
        }
      }
    });
  }
});

// src/nodes/converters.ts
var converters_exports = {};
var init_converters = __esm({
  "src/nodes/converters.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      category: "Converters",
      id: "string->number",
      inputs: {
        string: new Port("string", "")
      },
      outputs: {
        number: new Port("number", 0)
      },
      doc: `Receives a string representing a number, parses it as a number, and
    outputs that. It uses <code>parseFloat</code> so if you give it a non-number
    string like <code>akjgsd78</code> you will just get 0.`,
      // cSpell: ignore akjgsd
      update({ node, changes }) {
        node.output("number", parseFloat(changes.string.toString()));
      }
    });
    defNode({
      category: "Converters",
      id: "to-string",
      inputs: {
        what: new Port("any", void 0)
      },
      outputs: {
        stringified: new Port("string", "")
      },
      doc: `Receives any object and converts it to a string using the Javascript
    <code>toString()</code> method.`,
      update({ node, changes }) {
        node.output("stringified", changes.what.toString());
      }
    });
    defNode({
      id: "string->boolean",
      category: "Converters",
      inputs: {
        string: new Port("string", "")
      },
      outputs: {
        boolean: new Port("boolean", false)
      },
      doc: `Returns false if the string is the empty string or the string "false", and true otherwise.`,
      update({ node, changes }) {
        const str = changes.string.toString();
        node.output("boolean", str !== "" && str.toLowerCase() !== "false");
      }
    });
  }
});

// src/nodes/features/gps.ts
var gps_exports = {};
var init_gps = __esm({
  "src/nodes/features/gps.ts"() {
    "use strict";
    init_nodeDef();
    init_otherTypes();
    init_all();
    defNode({
      id: "gps",
      category: "Device",
      inputs: {},
      outputs: {
        pos: new Port("point", Point.EMPTY),
        altitude: new Port("number", 0),
        heading: new Port("number", 0),
        speed: new Port("number", 0)
      },
      doc: `Watches your device's GPS position and outputs position and movement data.

    The point that \`gps\` sends for :pos is of the form \`{x: longitude, y: latitude}\`.

    Altitude, heading, and speed may not be available or may be totally incorrect depending on your device.
    (Mine always returns 0 for altitude even though I am most certainly not at sea level.)`,
      setup({ app, node }) {
        navigator.geolocation.watchPosition((arg) => {
          const coords = arg.coords;
          console.log(coords);
          node.output("pos", new Point(coords.longitude, coords.latitude));
          if (coords.altitude !== null) node.output("altitude", coords.altitude);
          if (coords.heading !== null) node.output("heading", coords.heading);
          if (coords.speed !== null) node.output("speed", coords.speed);
        }, (err) => {
          console.error(err);
          switch (err.code) {
            case GeolocationPositionError.PERMISSION_DENIED:
              app.error(err.message ?? "Permission denied to access geolocation data");
              break;
            case GeolocationPositionError.POSITION_UNAVAILABLE:
              app.warn(err.message ?? "Error getting geolocation data");
              break;
            case GeolocationPositionError.TIMEOUT:
              app.warn(err.message ?? "Timed out trying to get geolocation data");
              break;
          }
        });
      }
    });
  }
});

// src/common/feature.ts
var Feature;
var init_feature = __esm({
  "src/common/feature.ts"() {
    "use strict";
    Feature = class {
      #didInit = false;
      doc;
      initializer;
      constructor(init2, methods) {
        Object.assign(this, methods);
        this.initializer = init2;
      }
      async init(flow) {
        if (this.#didInit) return;
        await this.initializer(flow);
        this.#didInit = true;
      }
    };
  }
});

// src/nodes/features/unsafe.ts
var unsafe_exports = {};
var init_unsafe = __esm({
  async "src/nodes/features/unsafe.ts"() {
    "use strict";
    init_vanilla();
    init_feature();
    init_nodeDef();
    await init_utils();
    await init_lipsShim();
    init_all();
    defFeature("unsafe-code", new Feature(async (app) => {
      const btn = make("button", {}, "Yes, run");
      const area = make(
        "div",
        {},
        "This flow runs arbitrary code. ",
        "Please confirm you want to run it: ",
        btn
      );
      app.addConnect(area);
      await new Promise((r) => {
        btn.addEventListener("click", () => r());
      });
    }, {
      doc: `Used by nodes that have access to all of Javascript, meaning that they could do just about anything, including executing malicious code.

    This feature forces the user to confirm they want to run the flow first before anything happens.`
    }));
    defNode({
      id: "fn",
      inputs: {
        inputs: new Port("any", [], ["bus"])
      },
      outputs: {
        outputs: new Port("any", [], ["bus"])
      },
      handlesParams: true,
      features: ["unsafe-code"],
      doc: `Transforms the input and output values using a Scheme function.

    The value of the inputs is available in the variable \`$inputs\`, the node object is available
    in the variable \`$node\`, and the app context is available in the variable \`$app\`.
    Whatever array the function returns will be passed to the output.

    If \`#<void>\` (JS \`undefined\`) is returned, the node will not update its outputs.`,
      async setup({ node, features, args }) {
        const arrayToConsList = user_env.get("vector->list");
        console.log(features["unsafe-code"]);
        const cons = (a, d) => new Pair(a, d);
        const s = (n) => new LSymbol(n);
        const code = cons(
          s("lambda"),
          cons(
            cons(s("$inputs"), cons(s("$node"), cons(s("$app"), _nil))),
            arrayToConsList(args)
          )
        );
        console.log(code.toString());
        node.state.func = (await exec(code))[0];
      },
      async update({ node, app }) {
        const arrayToConsList = user_env.get("vector->list");
        var value;
        try {
          value = await node.state.func(arrayToConsList(node.get("inputs")), node, app);
        } catch (e75) {
          app.error(e75);
          console.error(e75);
          return;
        }
        if (value instanceof Pair) value = consToArray(value);
        else value = [value];
        if (value !== void 0) node.output("outputs", value);
      }
    });
  }
});

// src/nodes/features/gamepad.ts
var gamepad_exports = {};
var MAPPING;
var init_gamepad = __esm({
  "src/nodes/features/gamepad.ts"() {
    "use strict";
    init_nodeDef();
    init_otherTypes();
    init_all();
    defNode({
      id: "gamepad",
      category: "Device",
      inputs: {
        index: new Port("number", 0),
        "rumble-left": new Port("number", 0),
        "rumble-right": new Port("number", 0),
        "rumble-lt": new Port("number", 0),
        "rumble-rt": new Port("number", 0)
      },
      outputs: {
        buttons: new Port("number", [], ["bus"]),
        axes: new Port("number", [], ["bus"]),
        connected: new Port("boolean", false),
        north: new Port("number", 0),
        south: new Port("number", 0),
        east: new Port("number", 0),
        west: new Port("number", 0),
        "dpad-up": new Port("number", 0),
        "dpad-down": new Port("number", 0),
        "dpad-left": new Port("number", 0),
        "dpad-right": new Port("number", 0),
        start: new Port("number", 0),
        select: new Port("number", 0),
        home: new Port("number", 0),
        "left-stick-press": new Port("number", 0),
        "right-stick-press": new Port("number", 0),
        "left-shoulder": new Port("number", 0),
        "right-shoulder": new Port("number", 0),
        "left-trigger": new Port("number", 0),
        "right-trigger": new Port("number", 0),
        "left-stick": new Port("point", new Point(0, 0)),
        "right-stick": new Port("point", new Point(0, 0))
      },
      doc: `Utilizes the [web gamepad API](https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API)
    to access gamepad data. The gamepad index is the index of the gamepad in the list of connected gamepads.
    The rumble inputs are used to control the rumble of the gamepad.
    The buttons and axes outputs are arrays of button and axis values which can be used to access buttons and axes
    when the gamepad is a non-standard layout.`,
      async tick({ node, dt }) {
        const gamepad = navigator.getGamepads()[node.get("index")];
        node.output("connected", !!gamepad);
        if (!gamepad) return;
        node.output("axes", gamepad.axes);
        node.output("buttons", gamepad.buttons.map((b) => b.value));
        for (const [name, index] of Object.entries(MAPPING.buttons)) {
          const value = gamepad.buttons[index]?.value;
          if (value === void 0) continue;
          node.output(name, value);
        }
        for (const [name, index] of Object.entries(MAPPING.sticks)) {
          const x = gamepad.axes[index.x];
          const y = gamepad.axes[index.y];
          if (x === void 0 || y === void 0) continue;
          node.output(name, new Point(x, y));
        }
        const rumbleMotors = (
          // @ts-ignore
          // this is too new for typescript lol
          gamepad.hapticActuators ?? []
        );
        if (gamepad.vibrationActuator) rumbleMotors.push(gamepad.vibrationActuator);
        await Promise.all([
          ...rumbleMotors.map((motor) => {
            try {
              motor.playEffect("dual-rumble", {
                strongMagnitude: node.get("rumble-left"),
                weakMagnitude: node.get("rumble-right"),
                duration: dt
              });
            } catch (e75) {
            }
          }),
          ...rumbleMotors.map((motor) => {
            try {
              motor.playEffect("trigger-rumble", {
                leftTrigger: node.get("rumble-lt"),
                rightTrigger: node.get("rumble-rt"),
                duration: dt
              });
            } catch (e75) {
            }
          })
        ]);
      }
    });
    MAPPING = {
      "buttons": {
        south: 0,
        east: 1,
        west: 2,
        north: 3,
        "left-shoulder": 4,
        "right-shoulder": 5,
        "left-trigger": 6,
        "right-trigger": 7,
        select: 8,
        start: 9,
        "left-stick": 10,
        "right-stick": 11,
        "dpad-up": 12,
        "dpad-down": 13,
        "dpad-left": 14,
        "dpad-right": 15,
        home: 16
      },
      "sticks": {
        "left-stick": { "x": 0, "y": 1 },
        "right-stick": { "x": 2, "y": 3 }
      }
    };
  }
});

// src/nodes/features/battery.ts
var battery_exports = {};
var init_battery = __esm({
  "src/nodes/features/battery.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      id: "battery",
      category: "Device",
      inputs: {},
      outputs: {
        level: new Port("number", 0),
        charging: new Port("boolean", false)
      },
      doc: `Utilizes the [Battery Status API](https://developer.mozilla.org/en-US/docs/Web/API/Battery_Status_API)
    to access battery data. The level output is a number between 0 and 1 representing the battery level.
    The charging output is a boolean indicating if the battery is charging.`,
      async setup({ node, app }) {
        if (!("getBattery" in navigator)) {
          app.error("Battery API not supported");
          return;
        }
        const battery = await navigator.getBattery();
        battery.addEventListener("levelchange", () => {
          node.output("level", battery.level);
        });
        battery.addEventListener("chargingchange", () => {
          node.output("charging", battery.charging);
        });
        node.output("level", battery.level);
        node.output("charging", battery.charging);
      }
    });
  }
});

// src/nodes/math/arithmetic.ts
var arithmetic_exports = {};
var init_arithmetic = __esm({
  "src/nodes/math/arithmetic.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      id: "sum",
      category: "Math",
      template: { T: ["number"] },
      inputs: {
        values: new Port("T", [], ["bus"])
      },
      outputs: {
        sum: new Port("T", 0)
      },
      doc: `Adds a bunch of numbers.`,
      update({ node }) {
        node.output("sum", node.get("values").reduce((a, b) => a + b, 0));
      }
    });
    defNode({
      id: "difference",
      category: "Math",
      template: { T: ["number"] },
      inputs: {
        a: new Port("T", 0),
        b: new Port("T", 0)
      },
      outputs: {
        difference: new Port("T", 0)
      },
      doc: `Subtracts two numbers, a - b.`,
      update({ node }) {
        node.output("difference", node.get("a") - node.get("b"));
      }
    });
    defNode({
      id: "product",
      category: "Math",
      template: { T: ["number"] },
      inputs: {
        values: new Port("T", [], ["bus"])
      },
      outputs: {
        product: new Port("T", 1)
      },
      doc: `Multiplies a bunch of numbers.`,
      update({ node }) {
        node.output("product", node.get("values").reduce((a, b) => a * b, 1));
      }
    });
    defNode({
      id: "quotient",
      category: "Math",
      template: { T: ["number"] },
      inputs: {
        a: new Port("T", 1),
        b: new Port("T", 1)
      },
      outputs: {
        quotient: new Port("T", 1)
      },
      doc: `Divides two numbers, a / b.`,
      update({ node }) {
        node.output("quotient", node.get("a") / node.get("b"));
      }
    });
    defNode({
      id: "modulus",
      category: "Math",
      template: { T: ["number"] },
      inputs: {
        a: new Port("T", 1),
        b: new Port("T", 1)
      },
      outputs: {
        modulus: new Port("T", 1)
      },
      doc: `Calculates the modulus of two numbers, a % b.`,
      update({ node }) {
        node.output("modulus", node.get("a") % node.get("b"));
      }
    });
  }
});

// src/nodes/math/statistics.ts
var statistics_exports = {};
var init_statistics = __esm({
  "src/nodes/math/statistics.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      id: "average",
      category: "Statistics",
      template: { T: ["number"] },
      inputs: {
        values: new Port("T", [], ["bus"])
      },
      outputs: {
        average: new Port("T", 0)
      },
      doc: `Calculates the average (arithmetic mean) of a bunch of numbers.`,
      update({ node }) {
        const values = node.get("values");
        node.output("average", values.reduce((a, b) => a + b, 0) / values.length);
      }
    });
    defNode({
      id: "variance",
      category: "Statistics",
      template: { T: ["number"] },
      inputs: {
        values: new Port("T", [], ["bus"])
      },
      outputs: {
        variance: new Port("T", 0)
      },
      doc: `Calculates the variance of a bunch of numbers.`,
      update({ node }) {
        const values = node.get("values");
        const mean = values.reduce((a, b) => a + b, 0) / values.length;
        node.output("variance", values.reduce((a, b) => a + (b - mean) ** 2, 0) / values.length);
      }
    });
  }
});

// src/nodes/math/random.ts
var random_exports = {};
var init_random = __esm({
  "src/nodes/math/random.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      category: "Math",
      id: "random",
      inputs: { randomize: new Port("signal", void 0) },
      outputs: { value: new Port("number", "a random value") },
      doc: "Outputs a random value in the range [0, 1) when updated.",
      setup({ node }) {
        node.output("value", Math.random());
      },
      update({ node }) {
        node.output("value", Math.random());
      }
    });
  }
});

// src/nodes/math/calculus.ts
var calculus_exports = {};
var init_calculus = __esm({
  "src/nodes/math/calculus.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      id: "integrate",
      category: "Calculus",
      inputs: {
        df: new Port("number", 0)
      },
      outputs: {
        f: new Port("number", 0)
      },
      doc: `Calculates the time integral of the input value.`,
      tick({ node, dt }) {
        node.output("f", node.get("df") * dt + node.outputCurrentValues.f);
      }
    });
    defNode({
      id: "derivative",
      category: "Calculus",
      inputs: {
        f: new Port("number", 0)
      },
      outputs: {
        df: new Port("number", 0)
      },
      stateKeys: ["old_df"],
      doc: `Calculates the time derivative of the input value.`,
      setup({ node }) {
        node.state.old_df = 0;
      },
      tick({ node, dt }) {
        const f = node.get("f");
        node.output("df", (f - node.state.old_df) / dt);
        node.state.old_df = f;
      }
    });
  }
});

// src/nodes/math/trig.ts
var trig_exports = {};
var init_trig = __esm({
  "src/nodes/math/trig.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      id: "cos",
      inputs: {
        angle: new Port("number", 0)
      },
      outputs: {
        value: new Port("number", 0)
      },
      update({ node }) {
        const angle = node.get("angle");
        node.output("value", Math.cos(angle));
      },
      doc: `Outputs the cosine of the input angle measured in radians.`
    });
    defNode({
      id: "sin",
      inputs: {
        angle: new Port("number", 0)
      },
      outputs: {
        value: new Port("number", 0)
      },
      update({ node }) {
        const angle = node.get("angle");
        node.output("value", Math.sin(angle));
      },
      doc: `Outputs the sine of the input angle measured in radians.`
    });
    defNode({
      id: "tan",
      inputs: {
        angle: new Port("number", 0)
      },
      outputs: {
        value: new Port("number", 0)
      },
      update({ node }) {
        const angle = node.get("angle");
        node.output("value", Math.tan(angle));
      },
      doc: `Outputs the tangent of the input angle measured in radians.`
    });
    defNode({
      id: "acos",
      inputs: {
        value: new Port("number", 0)
      },
      outputs: {
        angle: new Port("number", 0)
      },
      update({ node }) {
        const value = node.get("value");
        node.output("angle", Math.acos(value));
      },
      doc: `Outputs the inverse cosine of the input value as an angle in radians or NaN if the value is outside the range [-1, 1].`
    });
    defNode({
      id: "asin",
      inputs: {
        value: new Port("number", 0)
      },
      outputs: {
        angle: new Port("number", 0)
      },
      update({ node }) {
        const value = node.get("value");
        node.output("angle", Math.asin(value));
      },
      doc: `Outputs the inverse sine of the input value as an angle in radians or NaN if the value is outside the range [-1, 1].`
    });
    defNode({
      id: "atan",
      inputs: {
        value: new Port("number", 0)
      },
      outputs: {
        angle: new Port("number", 0)
      },
      update({ node }) {
        const value = node.get("value");
        node.output("angle", Math.atan(value));
      },
      doc: `Outputs the inverse tangent of the input value as an angle in radians.`
    });
    defNode({
      id: "radians->degrees",
      inputs: {
        radians: new Port("number", 0)
      },
      outputs: {
        degrees: new Port("number", 0)
      },
      update({ node }) {
        const radians = node.get("radians");
        node.output("degrees", radians * (180 / Math.PI));
      },
      doc: `Converts radians to degrees.`
    });
    defNode({
      id: "degrees->radians",
      inputs: {
        degrees: new Port("number", 0)
      },
      outputs: {
        radians: new Port("number", 0)
      },
      update({ node }) {
        const degrees = node.get("degrees");
        node.output("radians", degrees * (Math.PI / 180));
      },
      doc: `Converts degrees to radians.`
    });
  }
});

// src/nodes/math/geometry.ts
var geometry_exports = {};
var init_geometry = __esm({
  "src/nodes/math/geometry.ts"() {
    "use strict";
    init_nodeDef();
    init_otherTypes();
    init_all();
    defNode({
      id: "distance",
      category: "Geometry",
      inputs: {
        a: new Port("point", new Point(0, 0)),
        b: new Port("point", new Point(0, 0))
      },
      outputs: {
        distance: new Port("number", 0)
      },
      doc: `Calculates the distance between two points.`,
      update({ node }) {
        const a = node.get("a");
        const b = node.get("b");
        const distance = Math.hypot(b.x - a.x, b.y - a.y);
        node.output("distance", distance);
      }
    });
    defNode({
      id: "centroid",
      category: "Geometry",
      inputs: {
        points: new Port("point", [], ["bus"])
      },
      outputs: {
        centroid: new Port("point", new Point(0, 0))
      },
      doc: `Calculates the centroid of a set of points. If there are only two points, it returns the midpoint.`,
      update({ node }) {
        const points = node.get("points");
        if (points.length === 0) {
          node.output("centroid", new Point(0, 0));
          return;
        }
        const sum = points.reduce((acc, point) => {
          acc.x += point.x;
          acc.y += point.y;
          return acc;
        }, new Point(0, 0));
        const centroid = new Point(sum.x / points.length, sum.y / points.length);
        node.output("centroid", centroid);
      }
    });
    defNode({
      id: "xy->point",
      category: "Geometry",
      inputs: {
        x: new Port("number", 0),
        y: new Port("number", 0)
      },
      outputs: {
        point: new Port("point", new Point(0, 0))
      },
      doc: `Converts x and y coordinates to a point.`,
      update({ node }) {
        node.output("point", new Point(node.get("x"), node.get("y")));
      }
    });
    defNode({
      id: "point->xy",
      category: "Geometry",
      inputs: {
        point: new Port("point", new Point(0, 0))
      },
      outputs: {
        x: new Port("number", 0),
        y: new Port("number", 0)
      },
      doc: `Converts a point to x and y coordinates.`,
      update({ node }) {
        const point = node.get("point");
        node.output("x", point.x);
        node.output("y", point.y);
      }
    });
  }
});

// src/nodes/electronics/clock.ts
var clock_exports = {};
var init_clock = __esm({
  "src/nodes/electronics/clock.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      category: "Timing",
      id: "clock",
      inputs: {
        interval: new Port("number", 1e3),
        paused: new Port("boolean", false),
        reset: new Port("signal", void 0)
      },
      outputs: {
        clock: new Port("signal", void 0)
      },
      stateKeys: ["elapsedTime"],
      doc: "Updates connected nodes every N milliseconds.",
      setup({ node }) {
        node.state.elapsedTime = 0;
      },
      update({ node, changes }) {
        if (changes.reset) {
          node.state.elapsedTime = 0;
        }
      },
      tick({ node, dt }) {
        if (!node.get("paused")) {
          node.state.elapsedTime += dt * 1e3;
        }
        if (node.state.elapsedTime >= node.get("interval")) {
          node.state.elapsedTime -= node.get("interval");
          node.output("clock");
        }
      }
    });
  }
});

// src/nodes/electronics/logic.ts
var logic_exports = {};
var init_logic = __esm({
  "src/nodes/electronics/logic.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      category: "Logic",
      id: "not",
      inputs: {
        input: new Port("boolean", false)
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs the inverse of its input.",
      update({ node, changes }) {
        node.output("output", !changes.input);
      }
    });
    defNode({
      category: "Logic",
      id: "and",
      inputs: {
        a: new Port("boolean", false),
        b: new Port("boolean", false)
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs true if both inputs are true and false otherwise.",
      update({ node, changes }) {
        node.output("output", !!(changes.a && changes.b));
      }
    });
    defNode({
      category: "Logic",
      id: "every",
      inputs: {
        inputs: new Port("boolean", [], ["bus"])
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs true if all inputs are true and false otherwise. This is the any-number-of-inputs version of the AND gate.",
      update({ node, changes }) {
        node.output("output", Array.isArray(changes.inputs) ? changes.inputs.every(Boolean) : false);
      }
    });
    defNode({
      category: "Logic",
      id: "or",
      inputs: {
        a: new Port("boolean", false),
        b: new Port("boolean", false)
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs false if both inputs are false and true otherwise.",
      update({ node, changes }) {
        node.output("output", !!(changes.a || changes.b));
      }
    });
    defNode({
      category: "Logic",
      id: "some",
      inputs: {
        inputs: new Port("boolean", [], ["bus"])
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs false if all inputs are false and true otherwise. This is the any-number-of-inputs version of the OR gate.",
      update({ node, changes }) {
        node.output("output", changes.inputs.some(Boolean));
      }
    });
    defNode({
      category: "Logic",
      id: "xor",
      inputs: {
        a: new Port("boolean", false),
        b: new Port("boolean", false)
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs true if the inputs are different and false if they are the same.",
      update({ node, changes }) {
        node.output("output", !!changes.a === !changes.b);
      }
    });
    defNode({
      category: "Logic",
      id: "parity-1",
      inputs: {
        inputs: new Port("boolean", [], ["bus"])
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs true if an odd number of inputs are true and false if an even number of inputs are true. This is the any-number-of-inputs version of the XOR gate.",
      update({ node, changes }) {
        const count = changes.inputs.filter(Boolean).length;
        node.output("output", count % 2 === 1);
      }
    });
    defNode({
      category: "Logic",
      id: "nand",
      inputs: {
        a: new Port("boolean", false),
        b: new Port("boolean", false)
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs true if at least one input is false and false if both inputs are true.",
      update({ node, changes }) {
        node.output("output", !(changes.a && changes.b));
      }
    });
    defNode({
      category: "Logic",
      id: "not-all",
      inputs: {
        inputs: new Port("boolean", [], ["bus"])
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs true if at least one input is false and false if all inputs are true. This is the any-number-of-inputs version of the NAND gate.",
      update({ node, changes }) {
        node.output("output", !changes.inputs.every(Boolean));
      }
    });
    defNode({
      category: "Logic",
      id: "nor",
      inputs: {
        a: new Port("boolean", false),
        b: new Port("boolean", false)
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs true if both inputs are false and false otherwise.",
      update({ node, changes }) {
        node.output("output", !(changes.a || changes.b));
      }
    });
    defNode({
      category: "Logic",
      id: "none",
      inputs: {
        inputs: new Port("boolean", [], ["bus"])
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs true if all inputs are false and false if any are true. This is the any-number-of-inputs version of the NOR gate.",
      update({ node, changes }) {
        node.output("output", !changes.inputs.some(Boolean));
      }
    });
    defNode({
      category: "Logic",
      id: "xnor",
      inputs: {
        a: new Port("boolean", false),
        b: new Port("boolean", false)
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs true if both inputs are the same.",
      update({ node, changes }) {
        node.output("output", !!changes.a === !!changes.b);
      }
    });
    defNode({
      category: "Logic",
      id: "parity-0",
      inputs: {
        inputs: new Port("boolean", [], ["bus"])
      },
      outputs: {
        output: new Port("boolean", true)
      },
      doc: "Outputs true if an even number of inputs are true and false if an odd number of inputs are true. This is the any-number-of-inputs version of the XNOR gate.",
      update({ node, changes }) {
        const count = changes.inputs.filter(Boolean).length;
        node.output("output", count % 2 === 0);
      }
    });
  }
});

// src/nodes/electronics/latches.ts
var latches_exports = {};
var init_latches = __esm({
  "src/nodes/electronics/latches.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      category: "Logic",
      id: "d-latch",
      template: { T: ["any"] },
      inputs: {
        d: new Port("T", void 0),
        enable: new Port("boolean", false)
      },
      outputs: {
        q: new Port("T", void 0)
      },
      stateKeys: ["q"],
      doc: `D latch (transparent latch). When \`:enable\` is true, \`:q\` mirrors \`:d\`. When \`:enable\` is false, \`:q\` holds its value.`,
      update({ node }) {
        if (node.get("enable")) {
          const oldQ = node.state.q;
          node.state.q = node.get("d");
          if (oldQ !== node.state.q)
            node.output("q", node.state.q);
        }
      }
    });
    defNode({
      category: "Logic",
      id: "d-flipflop",
      template: { T: ["any"] },
      inputs: {
        d: new Port("T", void 0, ["silent"]),
        clock: new Port("signal", void 0)
      },
      outputs: {
        q: new Port("T", false)
      },
      stateKeys: ["q"],
      doc: `D flip-flop. When updated by \`:clock\`, \`:q\` is set to \`:d\`.`,
      update({ node }) {
        node.output("q", node.get("d"));
      }
    });
    defNode({
      category: "Logic",
      id: "jk-flipflop",
      inputs: {
        j: new Port("boolean", false, ["silent"]),
        k: new Port("boolean", false, ["silent"]),
        clock: new Port("signal", void 0)
      },
      outputs: {
        q: new Port("boolean", false)
      },
      stateKeys: ["q"],
      doc: `JK flip-flop. When updated by \`:clock\`, \`:q\` is set if \`:j\` is true or
    cleared if \`:k\` is true. If both are true at the same time, \`:q\` toggles.`,
      setup({ node }) {
        node.state.q = false;
        node.output("q", false);
      },
      update({ node }) {
        node.state.q = node.get("j") && !node.state.q || !node.get("k") && node.state.q;
        node.output("q", node.state.q);
      }
    });
  }
});

// src/nodes/electronics/mux.ts
var mux_exports = {};
var init_mux = __esm({
  "src/nodes/electronics/mux.ts"() {
    "use strict";
    init_nodeDef();
    init_all();
    defNode({
      id: "demultiplexer",
      category: "Flow Control",
      template: { T: ["any"] },
      inputs: {
        value: new Port("T", void 0),
        select: new Port("number", 0)
      },
      outputs: {
        out: new Port("T", [], ["bus"])
      },
      doc: `A demultiplexer. Takes a single input and routes it to one of several outputs based on the select input.`,
      update({ node }) {
        node.output("out", node.get("value"), node.get("select"));
      }
    });
    defNode({
      id: "multiplexer",
      category: "Flow Control",
      template: { T: ["any"] },
      inputs: {
        select: new Port("number", 0),
        in: new Port("T", [], ["bus"])
      },
      outputs: {
        out: new Port("T", void 0)
      },
      doc: `A multiplexer. Takes several inputs and routes one of them to the output based on the select input.`,
      update({ node }) {
        const oldValue = node.outputCurrentValues.out;
        const newValue = node.get("in")[node.get("select")];
        if (oldValue !== newValue) {
          node.output("out", newValue);
        }
      }
    });
  }
});

// src/nodes/all.ts
async function loadAllNodes(app) {
  await modulesReady;
  for (var node of NODES) {
    app.defineNode(node);
  }
  for (var [name, fun] of FEATURES) {
    app.defineFeature(name, fun);
  }
  console.log("Initialized nodes and features");
  console.log(app.nodeDefs, app.features);
}
function defNode(node) {
  NODES.push(node);
}
function defFeature(name, feat) {
  FEATURES.push([name, feat]);
}
var modulesReady, NODES, FEATURES;
var init_all = __esm({
  "src/nodes/all.ts"() {
    "use strict";
    modulesReady = Promise.all([
      Promise.resolve().then(() => (init_basic(), basic_exports)),
      Promise.resolve().then(() => (init_flow_control(), flow_control_exports)),
      Promise.resolve().then(() => (init_html(), html_exports)),
      Promise.resolve().then(() => (init_converters(), converters_exports)),
      Promise.resolve().then(() => (init_gps(), gps_exports)),
      init_unsafe().then(() => unsafe_exports),
      Promise.resolve().then(() => (init_gamepad(), gamepad_exports)),
      Promise.resolve().then(() => (init_battery(), battery_exports)),
      Promise.resolve().then(() => (init_arithmetic(), arithmetic_exports)),
      Promise.resolve().then(() => (init_statistics(), statistics_exports)),
      Promise.resolve().then(() => (init_random(), random_exports)),
      Promise.resolve().then(() => (init_calculus(), calculus_exports)),
      Promise.resolve().then(() => (init_trig(), trig_exports)),
      Promise.resolve().then(() => (init_geometry(), geometry_exports)),
      Promise.resolve().then(() => (init_clock(), clock_exports)),
      Promise.resolve().then(() => (init_logic(), logic_exports)),
      Promise.resolve().then(() => (init_latches(), latches_exports)),
      Promise.resolve().then(() => (init_mux(), mux_exports))
    ]);
    NODES = [];
    FEATURES = [];
  }
});

// src/editor/main.ts
var ace3 = __toESM(require_ace(), 1);
init_vanilla();

// src/common/compress.ts
async function compress(str) {
  const stream = new Blob([str]).stream();
  const compressedStream = stream.pipeThrough(
    new CompressionStream("deflate")
  );
  const reader = compressedStream.getReader();
  const chunks = [];
  for (; ; ) {
    const result = await reader.read();
    if (result.done) break;
    chunks.push(result.value);
  }
  return await concatUint8Arrays(chunks);
}
async function decompress(compressedBytes) {
  const stream = new Blob([compressedBytes]).stream();
  const decompressedStream = stream.pipeThrough(
    new DecompressionStream("deflate")
  );
  const reader = decompressedStream.getReader();
  const chunks = [];
  for (; ; ) {
    const result = await reader.read();
    if (result.done) break;
    chunks.push(result.value);
  }
  const stringBytes = await concatUint8Arrays(chunks);
  return new TextDecoder().decode(stringBytes);
}
async function concatUint8Arrays(uint8arrays) {
  const blob = new Blob(uint8arrays);
  const buffer = await blob.arrayBuffer();
  return new Uint8Array(buffer);
}

// src/common/constants.ts
var LYNX_FILE_EXT = ".scm";
var LINK_COMMAND_NAME = "chain";
var METADATA_NAME_RE = /^\*([a-z-_+]+)\*$/i;
var LOCAL_SAVE_KEY = "lynx_localsaves";
var AUTOSAVE_KEY = "lynx_autosave";
var ONLINE_EXAMPLES_GH_ENDPOINT = "https://api.github.com/repos/dragoncoder047/lynx/contents/examples/files/";

// src/common/autoload.ts
await init_utils();
async function loadFromHash() {
  if (location.hash === "") return;
  const source = await decompress(base64ToBytes(location.hash.slice(1)));
  return {
    source,
    title: isEmbedded() ? "New Flow" : "Shared Flow"
  };
}
async function loadFromLocalStorage() {
  const params = new URLSearchParams(location.search);
  const key = params.get("saved");
  if (!localStorage.getItem(LOCAL_SAVE_KEY)) localStorage[LOCAL_SAVE_KEY] = "{}";
  const store = JSON.parse(localStorage[LOCAL_SAVE_KEY]);
  if (!key) return;
  if (!(key in store))
    throw new Error(`No save slot "${key}"`);
  const source = await decompress(base64ToBytes(store[key]));
  return {
    source,
    title: `Saved flow '${key}'`
  };
}
async function loadFromURL() {
  const params = new URLSearchParams(location.search);
  const url = params.get("url");
  if (!url) return;
  try {
    const response = await fetch(url, { mode: "cors", cache: "reload", redirect: "follow" });
    if (response.status === 404)
      throw new Error(`"${url}" got a 404`);
    const source = await response.text();
    return {
      source,
      title: `Linked flow from ${url}`
    };
  } catch (_) {
    throw new Error(`CORS blocked loading "${url}"`);
  }
}
async function loadFromExample() {
  const params = new URLSearchParams(location.search);
  const key = params.get("example");
  if (!key) return;
  const response = await fetch(import.meta.resolve(`../examples/files/${key}${LYNX_FILE_EXT}`), { cache: "reload" });
  if (response.status === 404)
    throw new Error(`Failed to fetch example "${key}"`);
  const source = await response.text();
  return {
    source,
    title: `Example flow '${key}'`
  };
}
async function loadAutosaved() {
  if (!localStorage[AUTOSAVE_KEY]) return;
  return {
    source: await decompress(base64ToBytes(localStorage[AUTOSAVE_KEY])),
    title: "Autosaved"
  };
}
var LOADERS = [
  [loadFromHash, "share hash"],
  [loadFromLocalStorage, "save slot"],
  [loadFromURL, "external URL"],
  [loadFromExample, "example"],
  [loadAutosaved, "autosaved app"]
];
async function autoloadString() {
  const errors = [];
  for (var [loader, name] of LOADERS) {
    try {
      const val = await loader();
      if (val !== void 0 && errors.length === 0)
        return val.source.replace(/\n?$/, "\n");
    } catch (e75) {
      console.error(e75);
      errors.push(`;; ${name}: ${e75}`);
    }
  }
  if (errors.length > 0) {
    errors.unshift(";;");
    errors.unshift(";; ERROR");
  }
  return errors.join("\n") + "\n";
}

// src/editor/main.ts
await init_utils();

// src/common/getMetadata.ts
await init_lipsShim();
function getMeta(forms) {
  const out = {
    title: void 0,
    category: "Uncategorized",
    author: void 0,
    "author-url": void 0,
    version: void 0,
    description: void 0
  };
  const toArray = user_env.get("list->array");
  for (var form of forms) {
    const formA = toArray(form);
    if (formA.length === 3 && LSymbol.is(formA[0], "define") && formA[1] instanceof LSymbol) {
      const key = formA[1].__name__;
      const match2 = METADATA_NAME_RE.exec(key);
      if (match2 === null) continue;
      out[match2[1]] = formA[2].valueOf();
    }
  }
  return out;
}

// src/examples.ts
await init_utils();
var EXAMPLES = [];
async function fetchFromGithub() {
  const response = await fetch(ONLINE_EXAMPLES_GH_ENDPOINT).then((response2) => response2.json());
  if (!Array.isArray(response)) return [];
  return response.map((f) => f.name);
}
async function fetchFromPythonHTTPServer() {
  const response = await fetch(import.meta.resolve("../examples/files/"));
  if (response.status === 404) return [];
  const links = Array.from(new DOMParser().parseFromString(await response.text(), "text/html").querySelectorAll("a[href]"));
  return links.map((link) => link.textContent);
}
var files = (await Promise.all(
  [
    fetchFromGithub(),
    fetchFromPythonHTTPServer()
  ]
)).flat(1).filter((name) => name.endsWith(LYNX_FILE_EXT));
for (filename of files) {
  const id = filename.replace(/\.[^/.]+$/, "");
  const meta = await fetch(
    import.meta.resolve(`../examples/files/${filename}`),
    { cache: "reload" }
  ).then((resp) => resp.text()).then((text) => parseWithMetadata(text)).then((forms) => getMeta(forms));
  if (meta.hidden) continue;
  EXAMPLES.push({ filename, id, ...meta });
}
var filename;

// src/editor/lint.ts
var ace2 = __toESM(require_ace(), 1);

// src/common/flow.ts
init_vanilla();

// src/common/parseNodes.ts
await init_lipsShim();

// src/common/errors.ts
init_vanilla();
var LynxError = class extends Error {
  line;
  col;
  len;
  severity;
  constructor(message, severity, line, col, len = 1) {
    super(message);
    this.severity = severity;
    this.name = this.constructor.name;
    this.line = line;
    this.col = col;
    this.len = len;
  }
  equals(other) {
    return [
      this.message === other.message,
      this.name === other.name,
      this.line === other.line,
      this.col === other.col,
      this.len === other.len
    ].reduce((a, b) => a && b, true);
  }
  static BAD_SYNTAX = 50;
  static UNDEFINED_NAME = 30;
  static BAD_CONN_SPEC = 20;
  static TYPE_MISMATCH = 10;
  static INPUT_CONFLICT = 0;
};
var LynxMultiError = class _LynxMultiError extends LynxError {
  subErrors;
  constructor(subErrors) {
    super(null, null, null, null, null);
    const flattenedErrors = subErrors.flatMap((e75) => e75 instanceof _LynxMultiError ? e75.subErrors : [e75]);
    const dedupedErrors = [];
    outer: for (var subErr of flattenedErrors) {
      for (var alreadySeen of dedupedErrors) {
        if (subErr.equals(alreadySeen)) continue outer;
      }
      dedupedErrors.push(subErr);
    }
    this.subErrors = dedupedErrors;
  }
};
function makePosError(message, offending, severity = 1) {
  const { __line__, __col__ } = offending;
  const len = offending?.valueOf()?.length ?? 1;
  const line = __line__ !== void 0 ? __line__ + 1 : void 0;
  return new LynxError(message, severity, line, __col__, len);
}

// src/common/node.ts
var LynxNode = class {
  name;
  def;
  where;
  #changes;
  connections;
  inputCurrentValues;
  state;
  outputCurrentValues;
  args;
  constructor(name, def, where, params) {
    this.name = name;
    this.def = def;
    this.where = where;
    this.#changes = {};
    this.connections = {};
    this.inputCurrentValues = {};
    this.state = {};
    this.outputCurrentValues = {};
    this.args = params;
  }
  /**
   * Must be called AFTER {@link connect} is called to establish connections
   */
  async setup(app) {
    for (var n in this.def.outputs) {
      const val = this.def.outputs[n].initialVal;
      this.outputCurrentValues[n] = val;
      this.output(n, val, void 0, true);
    }
    await this.def.setup?.({
      app,
      node: this,
      features: Object.fromEntries(
        await Promise.all(
          this.def.features !== void 0 ? this.def.features.map(
            async (f) => [f, await app.feature(f)]
          ) : []
        )
      ),
      args: this.args
    });
    for (var out in this.connections) {
      for (var { node, port, busNOut, busNIn } of this.connections[out]) {
        await this.def.connect?.({
          app,
          nodeFrom: this,
          outFrom: out,
          nodeTo: node,
          inTo: port,
          busNOut,
          busNIn
        });
      }
    }
  }
  send(name, value, bi, silent) {
    if (bi === void 0) this.inputCurrentValues[name] = value;
    else {
      this.inputCurrentValues[name] ??= [];
      this.inputCurrentValues[name][bi] = value;
    }
    console.log("receiving", value, "on", name, "is silent:", this.def.inputs[name]?.is("silent") || silent);
    if (this.def.inputs[name]?.is("silent") || silent) return;
    if (this.def.inputs[name]?.type === "signal") value = true;
    if (bi === void 0) this.#changes[name] = value;
    else this.#changes[name] = this.inputCurrentValues[name].with(bi, value);
    console.log("updated change", name, this.#changes[name]);
  }
  async tick(app, dt) {
    if (this.def === void 0)
      nodeComplain(this, "Node has no definition");
    await this.def.tick?.({
      app,
      node: this,
      dt
    });
    if (Object.keys(this.#changes).length > 0) {
      await this.def.update?.({
        app,
        node: this,
        changes: this.#changes
      });
    }
    this.#changes = {};
  }
  output(outName, value, bo, forceSilent) {
    const isBus = Array.isArray(this.outputCurrentValues[outName]);
    if (isBus && !Array.isArray(value)) {
      if (bo === void 0)
        nodeComplain(this, `Output :${outName} is a bus. You must specify an index, or give the whole array at once.`);
      this.outputCurrentValues[outName][bo] = value;
    } else this.outputCurrentValues[outName] = value;
    const connections = this.connections[outName] ?? [];
    const silent = forceSilent || this.def.outputs[outName].is("silent");
    for (var conn of connections) {
      var theValue = this.outputCurrentValues[outName];
      if (isBus && conn.busNOut !== void 0) {
        if (bo === void 0 || conn.busNOut === bo)
          theValue = theValue[conn.busNOut];
        else continue;
      }
      console.log("sending", theValue, "from", outName, "to", conn.port, conn.busNIn, "is silent:", silent);
      conn.node.send(conn.port, theValue, conn.busNIn, silent);
    }
  }
  get(inName) {
    if (!(inName in this.inputCurrentValues)) return this.def.inputs[inName].initialVal;
    return this.inputCurrentValues[inName];
  }
  connect(outFrom, nodeTo, inTo, busOut, busIn) {
    console.log("connecting", this, outFrom, nodeTo, inTo, busOut, busIn);
    this.connections[outFrom] ??= [];
    this.connections[outFrom].push({
      node: nodeTo,
      port: inTo,
      busNIn: busIn,
      busNOut: busOut
    });
  }
};
function makeNodeComplain(node, msg, severity = 1) {
  return new LynxError(
    msg,
    severity,
    node.where?.line,
    node.where?.col,
    node.name.length
  );
}
function nodeComplain(node, msg, severity = 1) {
  throw makeNodeComplain(node, msg, severity);
}

// src/common/parseNodes.ts
init_nodeDef();

// src/common/types.ts
await init_lipsShim();
init_otherTypes();
function typeOf(obj) {
  if (obj === void 0 || obj === null) return "signal";
  if (typeof obj !== "object") return typeof obj;
  if (obj instanceof AudioNode) return "audio";
  if (obj instanceof Color) return "color";
  if (obj instanceof Point) return "point";
  if (obj instanceof LNumber) return "number";
  if (obj instanceof LString) return "string";
  if (obj instanceof LSymbol) return "symbol";
  return "unknown";
}
function fixTypeOf(obj) {
  const color_regex = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i;
  if (typeof obj === "string") {
    const res = color_regex.exec(obj);
    if (res) {
      const [, r, g, b] = res;
      return { fixedVal: new Color(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)), realType: "color" };
    }
  }
  return { fixedVal: obj, realType: typeOf(obj) };
}
function getGroundTypes(type2) {
  if (type2 === "any") return ["number", "bigint", "string", "symbol", "boolean", "color", "point"];
  if (type2 === "number") return ["number", "bigint", "boolean"];
  return [type2];
}
function canConnect(output, input) {
  if (input === "any") return true;
  else if (Array.isArray(input)) {
    if (Array.isArray(output)) return output.every((t2) => input.includes(t2));
    else return input.includes(output);
  } else if (Array.isArray(output)) return false;
  return output === input;
}

// src/common/parseNodes.ts
await init_utils();
var NodeAsWritten = class {
  name;
  args;
  isInvalidPlaceholder;
  constructor(name, args, invalid = false) {
    this.name = name;
    this.args = args;
    this.isInvalidPlaceholder = invalid;
  }
};
var PortRef = class {
  sym;
  name;
  busNum;
  constructor(sym, metasym) {
    var name, busNum;
    if (sym instanceof LSymbol) {
      const res = /^:(?<name>.*?)(:(?<busNum>\d+))?$/.exec(sym.valueOf());
      name = res.groups.name;
      busNum = res.groups.busNum;
    } else {
      name = sym;
      busNum = void 0;
    }
    this.sym = new LSymbol(name);
    this.sym.__line__ = (metasym ?? sym).__line__;
    this.sym.__col__ = metasym?.__line__ ? metasym.__line__ : sym.__col__ + 1;
    this.sym.__offset__ = metasym?.__offset__ ? metasym.__offset__ : sym.__offset__ + 1;
    this.name = name;
    if (busNum !== void 0) {
      this.busNum = new LNumber(BigInt(busNum));
      this.busNum.__line__ = (metasym ?? sym).__line__;
      this.busNum.__col__ = metasym?.__line__ ? metasym.__line__ : sym.__col__ + sym.__name__.length + 2;
      this.busNum.__offset__ = metasym?.__offset__ ? metasym.__offset__ : sym.__offset__ + sym.__name__.length + 2;
    }
  }
};
function createNodes(app, forms) {
  const chains = [];
  const namedNodes = {};
  const errors = [];
  for (var form of forms) {
    if (!(form instanceof Pair)) {
      errors.push(makePosError(
        `Unknown ${user_env.get("type")(form)} ${repr2(form)} at top level`,
        form,
        LynxError.BAD_SYNTAX
      ));
      continue;
    }
    const first = form.car, rest = form.cdr;
    const name = first.__name__;
    switch (name) {
      case "define":
        if (rest === _nil || rest.length() < 2) {
          errors.push(makePosError("Truncated definition", first, LynxError.BAD_SYNTAX));
          continue;
        }
        if (rest.car instanceof Pair)
          makeHON(app, rest);
        else if (!METADATA_NAME_RE.test(rest.car.toString())) {
          if (rest.cdr.car instanceof Pair)
            namedNodes[rest.car.toString()] = makeNode(rest.cdr.car);
          else errors.push(notValidHere(rest.cdr.car));
        }
        break;
      case LINK_COMMAND_NAME:
        const specialRes = processSpecialsAndPortrefs(consToArray(rest));
        chains.push(...specialRes.chains);
        errors.push(...specialRes.errors);
        break;
      default:
        errors.push(makePosError(
          `Unknown top-level invocation "${name}"`,
          first,
          LynxError.BAD_SYNTAX
        ));
    }
  }
  for (var i = 0; i < chains.length; i++) {
    errors.push(...processNamed(chains[i], namedNodes));
  }
  const superRes = getSuperpositions(chains, app.nodeDefs);
  const virtual = getParamImplicitNodes(superRes.superpos);
  superRes.superpos.push(...virtual.nodes);
  superRes.connections.push(...virtual.links);
  errors.push(...superRes.errors);
  errors.push(...virtual.errors);
  const sSet = new Set(superRes.superpos);
  const cSet = new Set(superRes.connections);
  const final = wfc(sSet, cSet);
  errors.push(...final.errors);
  errors.push(...validateConnections(final.realNodes, [...final.connections]));
  if (errors.length > 0) {
    throw new LynxMultiError(errors);
  }
  console.info(final);
  return createAndConnectNodes(final.realNodes, final.connections);
}
function makeHON(app, def) {
  console.error(new RangeError("not implemented make HON"));
}
function makeNode(value) {
  return new NodeAsWritten(value.car, consToArray(value.cdr));
}
var SPECIALS = /* @__PURE__ */ new Map([
  // port ref symbol (the general case)
  [/^:/, (_m, el, _out, zip, _errors) => {
    zip.push(new PortRef(el));
  }],
  // stop linking
  [/^~$/, (_m, _el, out, zip, _errors) => {
    out.push(zip.slice());
    zip.length = 0;
  }],
  // backreference
  [/^@/, (_m, el, out, zip, errors) => {
    const reffed = el.valueOf().slice(1);
    const prevNodes = out.flat(1).concat(zip);
    const n = prevNodes.findLast((x) => x instanceof NodeAsWritten && x.name.valueOf() === reffed);
    if (n === void 0)
      errors.push(makePosError(
        `Backreference to "${reffed}" node, but there weren't any previous to here`,
        el,
        LynxError.UNDEFINED_NAME
      ));
    else zip.push(n);
  }]
]);
function processSpecialsAndPortrefs(elements) {
  const chains = [];
  var curZip = [];
  const errors = [];
  outer: for (var el of elements) {
    if (el instanceof Pair) {
      curZip.push(makeNode(el));
      continue;
    }
    if (el instanceof LSymbol) {
      for (var [regex, handler] of SPECIALS) {
        const m = regex.exec(el.toString());
        if (m) {
          handler(m, el, chains, curZip, errors);
          continue outer;
        }
      }
    }
    curZip.push(el);
  }
  if (curZip.length > 0) {
    chains.push(curZip);
  }
  return { chains, errors };
}
function processNamed(chain, named) {
  const errors = [];
  for (var i = 0; i < chain.length; i++) {
    const val = chain[i];
    if (val instanceof LSymbol) {
      const reffed = named[val.valueOf()];
      if (reffed === void 0) {
        errors.push(makePosError(
          `Named node ${val} not defined.`,
          val,
          LynxError.UNDEFINED_NAME
        ));
        chain[i] = new NodeAsWritten(val, [], true);
      } else chain[i] = reffed;
    }
  }
  return errors;
}
function getParamImplicitNodes(writtenNodes) {
  const errors = [];
  const nodes = [];
  const links = [];
  for (var s of writtenNodes) {
    if ([...s.concretes].some((c) => c.def.handlesParams)) continue;
    const res = implicit1(s);
    errors.push(...res.errors);
    nodes.push(...res.nodes);
    links.push(...res.links);
  }
  return { nodes, links, errors };
}
function implicit1(s) {
  const errors = [];
  const nodes = [];
  const links = [];
  if (s.asWritten.args.length === 1) {
    const allInputs = [...s.concretes].map((c) => Object.entries(c.def.inputs));
    const matchingInputs = allInputs.flatMap((inputs) => {
      if (inputs.length === 1) return inputs;
      const paramOnly = inputs.filter(([_, p]) => p.is("paramOnly"));
      if (paramOnly.length === 1) return paramOnly;
      return [];
    });
    if (new Set(matchingInputs.map(([name, p]) => name)).size === 1) {
      s.asWritten.args.unshift(new LSymbol(":" + matchingInputs[0][0]));
    }
  }
  for (var i = 0; i < s.asWritten.args.length; i += 2) {
    const keyName = s.asWritten.args[i];
    const keyVal = s.asWritten.args[i + 1];
    if (!(keyName instanceof LSymbol)) {
      errors.push(makePosError(
        `Invalid init port name ${keyName} (expected a symbol)`,
        keyName,
        LynxError.BAD_SYNTAX
      ));
      continue;
    }
    if (keyVal === void 0) {
      errors.push(makePosError(
        `Missing init value for ${keyName}`,
        keyName,
        LynxError.BAD_SYNTAX
      ));
      break;
    }
    const { fixedVal, realType } = fixTypeOf(keyVal);
    const implicitNode = createImplicitSuperposition(s.asWritten, keyName, fixedVal, realType);
    nodes.push(implicitNode);
    links.push({
      from: implicitNode,
      to: s,
      portRefs: [new PortRef("value", fixedVal), new PortRef(keyName)],
      isImplicitConnection: true
    });
  }
  return { nodes, links, errors };
}
function createImplicitSuperposition(a, sym, value, type2) {
  const name = new PortRef(sym).name;
  return {
    sym,
    asWritten: new NodeAsWritten(a.name, []),
    args: [],
    concretes: /* @__PURE__ */ new Set([{
      sym,
      genericChoices: /* @__PURE__ */ new Map(),
      def: {
        id: `__implicit_arg_${name}__`,
        inputs: {},
        outputs: {
          value: new Port(type2, value, ["silent"])
        },
        doc: `Implicit node created by init arg :${name}`
      }
    }])
  };
}
function getSuperpositions(chains, allNDs) {
  const connections = [];
  const errors = [];
  const seen = /* @__PURE__ */ new Map();
  outer: for (var chain of chains) {
    var i = 0, j = 0;
    while (!(chain[i] instanceof NodeAsWritten)) {
      errors.push(notValidHere(chain[i]));
      i++;
    }
    const res = createOrGetCached(seen, chain[i], allNDs);
    var prev = res.super;
    errors.push(...res.errors);
    while (i < chain.length) {
      j = chain.findIndex((v, j2) => j2 > i && v instanceof NodeAsWritten);
      if (j === -1) {
        for (var k = i + 1; k < chain.length; k++) {
          errors.push(notValidHere(chain[k]));
        }
        continue outer;
      }
      const curNAW = chain[j];
      const slice = chain.slice(i + 1, j);
      const res2 = createOrGetCached(seen, curNAW, allNDs);
      const cur = res2.super;
      errors.push(...res2.errors);
      connections.push({
        from: prev,
        to: cur,
        portRefs: slice.filter((x) => x instanceof PortRef),
        isImplicitConnection: false
      });
      prev = cur;
      i = j;
    }
  }
  return { superpos: [...seen.values()], connections, errors };
}
function createOrGetCached(s, n, d) {
  var ret;
  var errors = [];
  if (s.has(n)) ret = s.get(n);
  else {
    const res = createInitialSuperpos(n, d);
    ret = res.super;
    errors = res.errors;
    s.set(n, ret);
  }
  return { errors, super: ret };
}
function notValidHere(what) {
  const astNode = what instanceof PortRef ? what.sym : what;
  return makePosError(
    `${repr2(astNode)} not valid here`,
    astNode,
    LynxError.BAD_SYNTAX
  );
}
function createInitialSuperpos(naw, allNDs) {
  const matchingDefs = naw.isInvalidPlaceholder ? [] : allNDs.filter((nd) => nd.id === naw.name.valueOf());
  const errors = [];
  if (matchingDefs.length === 0 && !naw.isInvalidPlaceholder) {
    errors.push(makePosError(
      `Node type "${naw.name}" doesn't exist`,
      naw.name,
      LynxError.UNDEFINED_NAME
    ));
  }
  return {
    super: {
      sym: naw.name,
      args: naw.args,
      asWritten: naw,
      concretes: new Set(getConcretes(matchingDefs, naw.name))
    },
    errors
  };
}
function* getConcretes(defs, sym) {
  for (var def of defs) {
    for (var cMap of choicesMap(Object.entries(def.template || {}))) {
      yield { def, genericChoices: new Map(cMap), sym };
    }
  }
}
function* choicesMap(choices) {
  if (choices.length === 0) {
    yield [];
    return;
  }
  const [choice1, ...otherChoices] = choices;
  const [choice1Name, choice1Values] = choice1;
  for (var nextChoices of choicesMap(otherChoices)) {
    for (var choice1Value of choice1Values.flatMap(getGroundTypes)) {
      yield [[choice1Name, choice1Value], ...nextChoices];
    }
  }
}
function wfc(nodes, connections) {
  const connCache = /* @__PURE__ */ new Map();
  const superCache = /* @__PURE__ */ new Map();
  const errors = [];
  for (var conn of connections) {
    for (var c1 of conn.from.concretes) {
      for (var c2 of conn.to.concretes) {
        var res = getCache(connCache, c1, c2, conn);
        if (res === void 0) {
          res = tryConnect(c1, c2, conn.portRefs, conn.isImplicitConnection);
          putCache(connCache, c1, c2, conn, res);
          saveSuperCache(superCache, nodes, c1, res);
          saveSuperCache(superCache, nodes, c2, res);
        }
      }
    }
  }
  const realNodes = /* @__PURE__ */ new Map();
  const realConnections = [];
  for (var node of nodes) {
    if (node.concretes.size < 1) {
      continue;
    }
    const res2 = superCache.get(node);
    if (res2 === void 0) {
      if (new Set([...node.concretes].map((c) => c.def)).size > 1) {
        errors.push(makePosError(
          `Could not resolve variant of isolated node "${node.asWritten.name}". Try connecting something to it.`,
          node.sym,
          LynxError.BAD_CONN_SPEC
        ));
      } else realNodes.set(node, [...node.concretes][0].def);
      continue;
    }
    const csNoErrors = [...res2].flatMap(([c, r]) => r.every((r2) => r2 instanceof LynxError) ? [] : [c]);
    if (csNoErrors.length === 0) {
      errors.push(...[...res2].flatMap(([_, r]) => r.filter((r2) => r2 instanceof LynxError)));
      continue;
    }
    const defsSet = new Set(csNoErrors.map((c) => c.def));
    const firstConcrete = csNoErrors[0];
    const firstDef = firstConcrete.def;
    if (defsSet.size > 1) {
      errors.push(makePosError(
        `Could not resolve variant of node "${node.asWritten.name}". Try connecting something else to it.`,
        node.sym,
        LynxError.BAD_CONN_SPEC
      ));
      continue;
    }
    realNodes.set(node, firstDef);
  }
  for (var conn of connections) {
    const tgtLeft = realNodes.get(conn.from);
    const tgtRight = realNodes.get(conn.to);
    if (tgtLeft === void 0 || tgtRight === void 0) {
      continue;
    }
    const pair = findSuccessfulConcretePair(conn.from, tgtLeft, conn.to, tgtRight, conn, connCache);
    if (!pair) continue;
    const { fc, tc } = pair;
    const res2 = getCache(connCache, fc, tc, conn);
    if (res2 instanceof LynxError) {
      continue;
    }
    if (res2 === void 0) {
      throw new RangeError("unreachable");
    }
    realConnections.push({
      from: conn.from,
      to: conn.to,
      outPort: res2[0],
      inPort: res2[1]
    });
  }
  return {
    errors,
    realNodes,
    connections: realConnections
  };
}
function saveSuperCache(cache, superpositions, d, res) {
  for (var s of superpositions) {
    const cache1 = cache.get(s) ?? /* @__PURE__ */ new Map();
    cache.set(s, cache1);
    for (var c of s.concretes) {
      if (c === d) {
        const arr = cache1.get(c) ?? [];
        arr.push(res);
        cache1.set(c, arr);
      }
    }
  }
}
function putCache(cache, left, right, conn, value) {
  if (!cache.has(left)) cache.set(left, /* @__PURE__ */ new Map());
  const cache2 = cache.get(left);
  if (!cache2.has(right)) cache2.set(right, /* @__PURE__ */ new Map());
  const cache3 = cache2.get(right);
  cache3.set(conn, value);
}
function getCache(cache, left, right, conn) {
  return cache.get(left)?.get(right)?.get(conn);
}
function findSuccessfulConcretePair(fromSuper, fromDef, toSuper, toDef, conn, connCache) {
  for (const fc of fromSuper.concretes) {
    if (fc.def !== fromDef) continue;
    for (const tc of toSuper.concretes) {
      if (tc.def !== toDef) continue;
      const res = getCache(connCache, fc, tc, conn);
      if (res && !(res instanceof LynxError)) {
        return { fc, tc };
      }
    }
  }
  return void 0;
}
function tryConnect(from, to, refs, isImplicitParamConnection) {
  const typeChoices = [];
  const ports1 = resolvePortTypes(from.def.outputs, from.genericChoices);
  const ports2 = resolvePortTypes(to.def.inputs, to.genericChoices);
  const ports1Obj = Object.fromEntries(ports1);
  const ports2Obj = Object.fromEntries(ports2);
  for (var [n1, t1] of ports1) {
    for (var [n2, t2] of ports2) {
      if (t2.is("paramOnly") && !isImplicitParamConnection) continue;
      if (canConnect(t1.type, t2.type)) {
        typeChoices.push([new PortRef(n1, from.sym), new PortRef(n2, to.sym)]);
      }
    }
  }
  if (typeChoices.length === 0) {
    return makePosError(
      `No outputs of "${from.def.id}" match the type of any input of "${to.def.id}". Try inserting a converter node in between.`,
      refs[0]?.sym ?? from.sym,
      LynxError.TYPE_MISMATCH
    );
  }
  var successPorts;
  const refsWithName = refs.filter((ref) => ref.name !== "");
  const refsWithoutName = refs.filter((ref) => ref.name === "");
  var needToGuessBusNumberAssignment = false;
  portswitch: switch (refsWithName.length) {
    case 0: {
      if (typeChoices.length > 1) {
        return makePosError(
          `Multiple ways to connect "${from.def.id}" to "${to.def.id}" and none was specified`,
          from.sym,
          LynxError.BAD_CONN_SPEC
        );
      }
      successPorts = typeChoices[0];
      needToGuessBusNumberAssignment = true;
      break;
    }
    case 1: {
      const sPort = refsWithName[0];
      const tPortLeft = ports1Obj[sPort.name];
      const tPortRight = ports2Obj[sPort.name];
      const connWithNameOnLeft = typeChoices.filter(([o, _]) => o.name === sPort.name);
      const connWithNameOnRight = typeChoices.filter(([_, i]) => i.name === sPort.name);
      if (tPortLeft === void 0 && tPortRight === void 0) {
        return makePosError(
          `No port :${sPort.name} exists on outputs of "${from.def.id}" or inputs of "${to.def.id}"`,
          sPort.sym,
          LynxError.UNDEFINED_NAME
        );
      }
      if (tPortLeft !== void 0 && tPortRight !== void 0) {
        if (connWithNameOnLeft.length === 1) {
          successPorts = connWithNameOnLeft[0].with(0, sPort);
          if (refsWithoutName.length > 0) successPorts[1].busNum = refsWithoutName[0].busNum;
          break portswitch;
        }
        if (connWithNameOnRight.length === 1) {
          successPorts = connWithNameOnRight[0].with(1, sPort);
          if (refsWithoutName.length > 0) successPorts[0].busNum = refsWithoutName[0].busNum;
          break portswitch;
        }
        return makePosError(
          `Write ':${sPort.name} :${sPort.name}' if you intend to connect :${sPort.name} of "${from.def.id}" to :${sPort.name} of "${to.def.id}". There are multiple other ports that each of these could be connected to.`,
          sPort.sym,
          LynxError.BAD_CONN_SPEC
        );
      }
      if (tPortLeft !== void 0) {
        if (connWithNameOnLeft.length === 1) {
          const conn = connWithNameOnLeft[0];
          if (to.def.inputs[conn[1].name].is("paramOnly")) {
            return makePosError(
              `Output :${sPort.name} (${tPortLeft}) of "${from.def.id}" can only connect to :${conn[1]} of "${to.def.id}", but it is initialize-only`,
              sPort.sym,
              LynxError.INPUT_CONFLICT
            );
          }
          successPorts = conn.with(0, sPort);
          if (refsWithoutName.length > 0) successPorts[1].busNum = refsWithoutName[0].busNum;
          break portswitch;
        } else if (connWithNameOnLeft.length === 0)
          return makePosError(
            `No inputs to "${to.def.id}" can be connected to output :${sPort.name} (${tPortLeft}) of "${from.def.id}"`,
            sPort.sym,
            LynxError.TYPE_MISMATCH
          );
        else return makePosError(
          `Multiple inputs to "${to.def.id}" (${connWithNameOnLeft.map(([_, i]) => i)}) can be connected to output :${sPort.name} (${tPortLeft}) of "${from.def.id}" - use two symbols to specify.`,
          sPort.sym,
          LynxError.BAD_CONN_SPEC
        );
      }
      if (tPortRight !== void 0) {
        if (to.def.inputs[sPort.name].is("paramOnly")) {
          return makePosError(
            `Input :${sPort.name} (${tPortLeft}) of "${to.def.id}" is initialize-only`,
            sPort.sym,
            LynxError.INPUT_CONFLICT
          );
        }
        if (connWithNameOnRight.length === 1) {
          successPorts = connWithNameOnRight[0].with(1, sPort);
          if (refsWithoutName.length > 0) successPorts[0].busNum = refsWithoutName[0].busNum;
          break portswitch;
        } else if (connWithNameOnRight.length === 0)
          return makePosError(
            `No outputs of "${from.def.id}" can be connected to input :${sPort.name} (${tPortRight}) of "${to.def.id}"`,
            sPort.sym,
            LynxError.TYPE_MISMATCH
          );
        else return makePosError(
          `Multiple outputs of "${from.def.id}" (${connWithNameOnRight.map(([i, _]) => i)}) can be connected to input :${sPort.name} (${tPortRight}) of "${to.def.id}" - use two symbols to specify.`,
          sPort.sym,
          LynxError.BAD_CONN_SPEC
        );
      }
      throw "unreachable";
    }
    case 2: {
      const p1 = refsWithName[0];
      const p2 = refsWithName[1];
      const tPortLeft = ports1Obj[p1.name];
      const tPortRight = ports2Obj[p2.name];
      const errors2 = [];
      if (tPortLeft === void 0) {
        errors2.push(makePosError(
          `Node "${from.def.id}" has no output port :${p1.name}`,
          p1.sym,
          LynxError.UNDEFINED_NAME
        ));
      }
      if (tPortRight === void 0) {
        errors2.push(makePosError(
          `Node "${to.def.id}" has no input port :${p2.name}`,
          p2.sym,
          LynxError.UNDEFINED_NAME
        ));
      }
      if (errors2.length === 0 && !canConnect(tPortLeft.type, tPortRight.type)) {
        return makePosError(
          `Cannot connect output :${p1.name} (${tPortLeft}) of "${from.def.id}" node to :${p2.name} (${tPortRight}) of "${to.def.id}"`,
          p2.sym,
          LynxError.TYPE_MISMATCH
        );
      }
      if (errors2.length === 2) return new LynxMultiError(errors2);
      else if (errors2.length === 1) return errors2[0];
      successPorts = [p1, p2];
      break;
    }
    default:
      return makePosError("Too many port references", refs[2].sym, LynxError.BAD_CONN_SPEC);
  }
  const [pLeft, pRight] = [ports1.get(successPorts[0].name), ports2.get(successPorts[1].name)];
  const [leftIsBus, rightIsBus] = [pLeft.is("bus"), pRight.is("bus")];
  const refsWithBus = refs.filter((ref) => ref.busNum !== void 0);
  const errors = [];
  if (!leftIsBus && !rightIsBus) {
    if (needToGuessBusNumberAssignment) {
      if (refsWithBus.length > 0) {
        return makePosError(
          `Number not allowed here. Neither output :${successPorts[0].sym} of "${from.def.id}" nor input :${successPorts[1].sym} of "${to.def.id}" is a bus.`,
          refsWithBus[0].busNum,
          LynxError.BAD_CONN_SPEC
        );
      }
    } else {
      if (successPorts[0].busNum !== void 0)
        errors.push(makePosError(
          `Output :${successPorts[0].sym} of "${from.def.id}" is not a bus`,
          successPorts[0].busNum,
          LynxError.TYPE_MISMATCH
        ));
      if (successPorts[1].busNum !== void 0)
        errors.push(makePosError(
          `Input :${successPorts[1].sym} of "${to.def.id}" is not a bus`,
          successPorts[1].busNum,
          LynxError.TYPE_MISMATCH
        ));
    }
  } else if (leftIsBus && rightIsBus) {
    if (needToGuessBusNumberAssignment) {
      successPorts[0].busNum = refsWithBus[0]?.busNum;
      successPorts[1].busNum = refsWithBus[1]?.busNum;
    }
    if (successPorts[0].busNum !== void 0 === (successPorts[1].busNum !== void 0)) {
    } else
      return makePosError(
        `Both output :${successPorts[0].sym} of "${from.def.id}" and input :${successPorts[1].sym} of "${to.def.id}" are busses, you must specify two numbers or none`,
        successPorts[0].busNum ?? successPorts[1].busNum,
        LynxError.TYPE_MISMATCH
      );
  } else {
    const [b, nb] = leftIsBus ? [0, 1] : [1, 0];
    const [iinL, iinR] = leftIsBus ? ["", "not "] : ["not ", ""];
    if (needToGuessBusNumberAssignment) {
      if (refsWithBus.length === 2) {
        successPorts[0].busNum = refsWithBus[0]?.busNum;
        successPorts[1].busNum = refsWithBus[1]?.busNum;
      } else {
        successPorts[b].busNum = refsWithBus[0]?.busNum;
      }
    }
    if (successPorts[b].busNum === void 0)
      errors.push(makePosError(
        `Output :${successPorts[0].sym} of "${from.def.id}" is ${iinL}a bus, and input :${successPorts[1].sym} of "${to.def.id}" is ${iinR}a bus, so a number is required here`,
        successPorts[b].sym,
        LynxError.TYPE_MISMATCH
      ));
    if (successPorts[nb].busNum !== void 0)
      errors.push(makePosError(
        `Output :${successPorts[0].sym} of "${from.def.id}" is ${iinL}a bus, and input :${successPorts[1].sym} of "${to.def.id}" is ${iinR}a bus, so a number is not allowed here`,
        successPorts[nb].busNum,
        LynxError.TYPE_MISMATCH
      ));
  }
  return errors.length > 0 ? errors.length === 1 ? errors[0] : new LynxMultiError(errors) : successPorts;
}
function resolvePortTypes(portSide, concrete) {
  const out = /* @__PURE__ */ new Map();
  for (var name of Object.keys(portSide)) {
    const thePort = portSide[name];
    const theType = concrete.get(thePort.type) ?? thePort.type;
    out.set(name, new Port(theType, thePort.initialVal, thePort.flags));
  }
  return out;
}
function validateConnections(nodes, links) {
  const errors = [];
  for (var [s, def] of nodes) {
    const toThisNode = links.filter((c2) => c2.to === s);
    for (var i in def.inputs) {
      const thisPort = def.inputs[i];
      const toThisPort = toThisNode.filter((c2) => c2.inPort.name === i);
      if (thisPort.is("bus")) {
        const wholeBusConnections = toThisPort.filter((c2) => c2.inPort.busNum === void 0);
        if (wholeBusConnections.length > 0) {
          if (wholeBusConnections.length > 1 || toThisPort.length > 1) {
            for (const c2 of toThisPort) {
              errors.push(makePosError(
                `Multiple outputs are connected to input :${i} of node "${def.id}" (whole-bus connection)`,
                c2.outPort.sym,
                LynxError.INPUT_CONFLICT
              ));
            }
          }
        } else {
          const seenBI = /* @__PURE__ */ new Set();
          for (const c2 of toThisPort) {
            const busNumStr = c2.inPort.busNum.valueOf();
            if (seenBI.has(busNumStr)) {
              errors.push(makePosError(
                `Multiple outputs are connected to the same bus index (${busNumStr}) of input :${i} of node "${def.id}"`,
                c2.outPort.sym,
                LynxError.INPUT_CONFLICT
              ));
            } else {
              seenBI.add(busNumStr);
            }
          }
        }
      } else if (!thisPort.is("eventReceiver")) {
        if (toThisPort.length > 1) {
          for (var c of toThisPort) {
            errors.push(makePosError(
              `Multiple outputs are connected to input :${i} of node "${def.id}"`,
              c.outPort.sym,
              LynxError.INPUT_CONFLICT
            ));
          }
        }
      }
    }
  }
  return errors;
}
function createAndConnectNodes(nodes, links) {
  const sToI = /* @__PURE__ */ new Map();
  for (var [n, def] of nodes) {
    sToI.set(n, new LynxNode(def.id, def, { line: n.sym.__line__, col: n.sym.__col__ }, n.args));
  }
  for (var link of links) {
    const { from, to, inPort, outPort } = link;
    const fromNode = sToI.get(from);
    const toNode = sToI.get(to);
    fromNode.connect(outPort.name, toNode, inPort.name, outPort.busNum?.valueOf(), inPort.busNum?.valueOf());
  }
  return [...sToI.values()];
}

// src/common/flow.ts
await init_utils();
var LynxFlow = class {
  nodeDefs;
  features;
  mainEl;
  titleEl;
  logEl;
  connectEl;
  constructor(mainEl, titleEl, logEl, connectEl) {
    this.nodeDefs = [];
    this.features = {};
    this.mainEl = mainEl;
    this.titleEl = titleEl;
    this.logEl = logEl;
    this.connectEl = connectEl;
  }
  defineNode(def) {
    this.nodeDefs.push(def);
  }
  defineFeature(featureID, feature) {
    if (this.features[featureID] !== void 0) {
      throw new Error(`Feature "${featureID}" is already defined`);
    }
    this.features[featureID] = feature;
  }
  async feature(id) {
    const f = this.features[id];
    if (!f) {
      throw new Error(`Feature "${id}" doesn't exist`);
    }
    await f.init(this);
    return f;
  }
  build(data) {
    return createNodes(this, data);
  }
  async run(nodes) {
    console.log("Running nodes", nodes);
    var last = performance.now();
    for (; ; ) {
      const now = performance.now();
      const dt = (now - last) / 1e3;
      last = now;
      const iter = await Promise.allSettled(nodes.map((node) => node.tick(this, dt)));
      for (var res of iter) {
        if (res.status === "rejected") {
          console.error(res.reason);
        }
      }
      await new Promise((r) => setTimeout(r, 0));
    }
  }
  async setup({ source, title }) {
    const def = await parseWithMetadata(source);
    const nodes = this.build(def);
    const meta = getMeta(def);
    console.log("Got metadata", meta);
    this.setTitle(meta.title ?? title);
    await Promise.all(nodes.map((node) => node.setup(this)));
    if (this.connectEl) this.connectEl.innerHTML = "";
    return nodes;
  }
  setTitle(title) {
    document.title = `${title} | Lynx`;
    if (this.titleEl) this.titleEl.textContent = title;
  }
  addUI(content) {
    this.mainEl?.append(content);
    return content;
  }
  /**
   * @template T
   * @param {T} content
   * @returns {T}
   */
  addConnect(content) {
    this.connectEl?.append(content);
    return content;
  }
  log(content, timeout = 5e3) {
    const now = new Date(Date.now());
    const stamp = `${now.getHours().toString().padStart(2, "0")}:${now.getMinutes().toString().padStart(2, "0")}:${now.getSeconds().toString().padStart(2, "0")}.${now.getMilliseconds().toString().padStart(3, "0")}`;
    const node = make("span.log", { "data-timestamp": stamp }, content);
    this.logEl?.append(node);
    if (timeout > 0) setTimeout(() => node.remove(), timeout);
    return content;
  }
  warn(message, timeout) {
    this.log(make("span.warning", {}, message), timeout);
  }
  error(message, timeout) {
    this.log(make("span.error", {}, message), timeout);
  }
  info(message, timeout) {
    this.log(make("span.info", {}, message), timeout);
  }
};

// src/editor/lint.ts
await init_utils();
init_all();
async function lint(source, editSession) {
  const app = new LynxFlow(null, null, null, null);
  await loadAllNodes(app);
  const errors = [];
  var nodes;
  try {
    nodes = app.build(await parseWithMetadata(source));
  } catch (e75) {
    if (e75.__code__) {
      console.log("LIPS Error on line", e75.__line__, e75.message, e75.__offset__);
      errors.push(new LynxError(e75.message, Infinity, (e75.__line__ || 0) + 1, e75.__col__ || 0));
    } else if (e75 instanceof LynxMultiError) errors.push(...e75.subErrors);
    else if (e75 instanceof LynxError) errors.push(e75);
    else throw e75;
  }
  console.warn(errors);
  showLint(editSession, errors);
  highlightNodes(editSession, nodes);
}
function showLint(editSession, errors) {
  const onlySev = errors;
  editSession.clearAnnotations();
  editSession.setAnnotations(onlySev.map((err2) => {
    return {
      row: (err2.line ?? 1) - 1,
      column: err2.col ?? 0,
      text: err2.message ?? `${err2.line}:${err2.col}(${err2.len}) ${err2.message}`,
      type: "error"
    };
  }));
  const markers = editSession.getMarkers();
  for (var id of Object.keys(markers)) {
    editSession.removeMarker(+id);
  }
  const seenMarkers = /* @__PURE__ */ new Set();
  for (var err of onlySev) {
    const marker = new ace2.Range(err.line - 1, err.col, err.line - 1, err.col + Math.max(1, err.len));
    if (seenMarkers.has(marker.toString())) continue;
    seenMarkers.add(marker.toString());
    editSession.addMarker(marker, "lint-error", "line");
  }
}
function highlightNodes(editSession, nodes) {
}

// src/editor/main.ts
populateProjects();
ace3.config.set("basePath", "https://cdn.jsdelivr.net/npm/ace-builds@1/src-noconflict/");
var editor = ace3.edit("editor", {
  mode: "ace/mode/scheme"
});
editor.setTheme({
  cssClass: "ace-lynx",
  isDark: true
});
editor.commands.removeCommand("showSettingsMenu", false);
editor.session.setOption("wrap", "free");
editor.session.setOption("wrap", "off");
var changeText = function(text) {
  changeText.isRunning = true;
  try {
    editor.setValue(text, -1);
  } finally {
    changeText.isRunning = false;
  }
};
editor.on("change", async () => {
  if (!changeText.isRunning) {
    localStorage[AUTOSAVE_KEY] = await getCompressed();
    changeURL("", "");
  }
  await lint(editor.getValue(), editor.getSession());
});
changeText(await autoloadString());
var runIframe = get("#loader");
bind("#browse", "click", () => {
  open(import.meta.resolve("../examples"), "_blank");
});
async function run() {
  runIframe.src = "../runner#" + await getCompressed();
}
bind("#run", "click", run);
editor.commands.addCommand({
  name: "runApp",
  bindKey: { mac: "Cmd+S|Cmd+R", win: "Ctrl+S|Ctrl+R" },
  exec: run
});
bind("#save-url", "click", async () => {
  changeURL("", "#" + await getCompressed());
});
bind("#help", "click", () => {
  open("../docs", "_blank");
});
bind("#open-full", "click", async () => {
  window.location = "../runner#" + await getCompressed();
});
bind("#save", "click", async () => {
  const name = prompt("Name for app:");
  if (name === null) return;
  const store = JSON.parse(localStorage[LOCAL_SAVE_KEY]);
  store[name] = await getCompressed();
  localStorage[LOCAL_SAVE_KEY] = JSON.stringify(store);
  changeURL("?saved=" + name, "");
  populateProjects();
});
bind("#share", "click", async () => {
  await navigator.share({
    url: new URL("../runner#" + await getCompressed(), location.href),
    text: editor.getValue(),
    title: "Lynx App"
    // files: [new File([editor.getValue()], "app" + LYNX_FILE_EXT)]
  });
});
bind("#projects", "change", async () => {
  const proj = get("#projects");
  const which = proj.value;
  proj.value = "";
  if (!which) return;
  const { saved, example } = JSON.parse(which);
  console.log(saved, example);
  changeURL(saved ? "?saved=" + saved : "?example=" + example, "");
  changeText(await autoloadString());
});
async function getCompressed() {
  return bytesToBase64(await compress(editor.getValue()));
}
function populateProjects() {
  const el = get("#projects");
  el.innerHTML = "";
  el.append(make(
    "option",
    { value: "", selected: "true" },
    "--select app--"
  ));
  const groups = [];
  localStorage[LOCAL_SAVE_KEY] ??= "{}";
  const stored = Object.keys(JSON.parse(localStorage[LOCAL_SAVE_KEY])).sort();
  if (stored.length > 0)
    groups.push(
      make(
        "optgroup",
        { label: "Local Saves" },
        ...stored.map(
          (slot) => make(
            "option",
            { value: JSON.stringify({ saved: slot }) },
            slot
          )
        )
      )
    );
  const gc = Object.groupBy(EXAMPLES, (x) => x.category);
  for (var category of Object.keys(gc).sort()) {
    const examples = gc[category];
    groups.push(
      make(
        "optgroup",
        { label: "Examples " + category },
        ...examples.map(
          (ex) => make(
            "option",
            { value: JSON.stringify({ example: ex.id }) },
            ex.title ?? ex.id
          )
        )
      )
    );
  }
  el.append(...groups);
}
function changeURL(search, hash) {
  const url = new URL(window.location.href);
  url.search = search;
  url.hash = hash;
  history.replaceState(null, "", url);
}
/*! Bundled license information:

ace-builds/src-noconflict/ace.js:
  (*
  * based on code from:
  *
  * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
  * Available via the MIT or new BSD license.
  * see: http://github.com/jrburke/requirejs for details
  *)

@jcubic/lips/dist/lips.esm.min.js:
  (**@license
   *   __ __                          __
   *  / / \ \       _    _  ___  ___  \ \
   * | |   \ \     | |  | || . \/ __>  | |
   * | |    > \    | |_ | ||  _/\__ \  | |
   * | |   / ^ \   |___||_||_|  <___/  | |
   *  \_\ /_/ \_\                     /_/ v. DEV
   *
   * LIPS is Pretty Simple - Scheme based Powerful LISP in JavaScript
   *
   * Copyright (c) 2018-2024 Jakub T. Jankiewicz <https://jcubic.pl/me>
   * Released under the MIT license
   *
   * includes:
   *
   * unfetch by Jason Miller (@developit) MIT License
   *
   * contentloaded.js
   *
   * Author: Diego Perini (diego.perini at gmail.com)
   * Summary: cross-browser wrapper for DOMContentLoaded
   * Updated: 20101020
   * License: MIT
   * Version: 1.2
   *
   * URL:
   * http://javascript.nwbox.com/ContentLoaded/
   * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
   *
   * dist file generated by Babel includes code
   * Copyright (c) 2014-present, Facebook, Inc.
   * released under MIT license
   *
   * build: Sat, 10 May 2025 19:46:53 +0000
   *)
  (**@license
   *
   * No Dependency fast and small LZJB Compression for Browser and Node
   *
   * Copyright (c) 2021 Jakub T. Jankiewicz https://jcubic.pl/me
   * Released under BSD-3-Clause License
   *
   * build: Wed, 27 Oct 2021 10:43:10 GMT
   *)
*/
//# sourceMappingURL=editor_main.js.map
